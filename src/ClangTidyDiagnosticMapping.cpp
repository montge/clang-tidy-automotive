//===--- tools/extra/clang-tidy/ClangTidyDiagnosticMapping.cpp -----------=== //
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#include "ClangTidyDiagnosticMapping.h"
#include "ClangTidy.h"
#include "clang/Basic/DiagnosticIDs.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/MemoryBuffer.h"

namespace clang::tidy {

namespace {

class DiagnosticMappingReader {
public:
  DiagnosticMappingReader(ClangTidyDiagnosticMapping *Mapping)
      : Mapping(Mapping) {}

  void readMappingFile(llvm::StringRef Path);

private:
  void readMappingArray(llvm::json::Object *Root);

  ClangTidyDiagnosticMapping *Mapping;
};

void DiagnosticMappingReader::readMappingFile(llvm::StringRef Path) {
  auto Buffer = llvm::MemoryBuffer::getFile(Path);
  if (Buffer) {
    auto JSONData = llvm::json::parse(Buffer.get()->getBuffer());

    if (JSONData) {
      if (auto *Root = JSONData->getAsObject()) {
        readMappingArray(Root);
      }
    }
  }
}

void DiagnosticMappingReader::readMappingArray(llvm::json::Object *Root) {
  if (auto *Array = Root->getArray("diagnostic-mappings")) {
    for (const auto &Element : *Array) {
      if (auto *Item = Element.getAsObject()) {
        auto AltDiagName = Item->getString("name");
        auto OrgDiagName = Item->getString("replace");

        /* Check all the required fields. */
        if (OrgDiagName && AltDiagName) {
          auto Message = Item->getString("message");
          auto DiagnosticFlag = Item->getString("flag");

          auto CustomDiagnostic = std::make_unique<ClangTidyCustomDiagnostic>(
              OrgDiagName.value(), AltDiagName.value());

          CustomDiagnostic->setMessage(Message);
          Mapping->addCustomDiagnostic(std::move(CustomDiagnostic));

          if (DiagnosticFlag) {
            Mapping->addDiagnosticFlag(DiagnosticFlag.value());
          }

        } else {

          // TODO: Log the fault via diagnostic
        }
      }
    }
  }
}

} // namespace

void ClangTidyCustomDiagnostic::setMessage(std::optional<StringRef> Message) {
  this->Message = Message ? Message->str() : "";
}

ClangTidyDiagnosticMapping::ClangTidyDiagnosticMapping(
    ClangTidyContext &Context, DiagnosticConsumer &DiagConsumer)
    : Context(Context), DiagConsumer(DiagConsumer) {

  readMappingOptions();
}

void ClangTidyDiagnosticMapping::readMappingOptions() {
  const auto &Options = Context.getOptions();

  if (Options.MappingFiles) {

    for (const auto &MappingFilename : *Options.MappingFiles) {
      // TODO: This needs to read the relative file path somehow.
      readMappingFile(MappingFilename);
    }
  }
}

void ClangTidyDiagnosticMapping::clear() { DiagConsumer.clear(); }

void ClangTidyDiagnosticMapping::BeginSourceFile(const LangOptions &LangOpts,
                                                 const Preprocessor *PP) {
  DiagConsumer.BeginSourceFile(LangOpts, PP);
}

void ClangTidyDiagnosticMapping::EndSourceFile() {
  DiagConsumer.EndSourceFile();
}

void ClangTidyDiagnosticMapping::finish() { DiagConsumer.finish(); }

bool ClangTidyDiagnosticMapping::IncludeInDiagnosticCounts() const {
  return DiagConsumer.IncludeInDiagnosticCounts();
}

void ClangTidyDiagnosticMapping::HandleDiagnostic(
    DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) {

  // The mapping functionality does not work without a diagnostic engine.
  assert(Context.DiagEngine &&
         "diagnostic mapping requires a diagnostic engine to work");

  auto CheckName = Context.getCheckName(Info.getID());
  auto it = DiagnosticMapping.find(CheckName);

  if (it != DiagnosticMapping.end()) {
    const CustomDiagnosticEntry &Entry = it->second;

    // Check if the original diagnostic message should remain.
    if (Entry.keepOriginalDiagnostic()) {
      DiagConsumer.HandleDiagnostic(DiagLevel, Info);
    }

    // Temporarily switch the diagnostic client to prevent recursion and
    // avoid analyzing diagnostics generated by DiagnosticMapping itself.
    // This ensures that only diagnostics emitted from other sources
    // are analyzed and potentially remapped to a different ID.
    Context.DiagEngine->setClient(&DiagConsumer, false);

    for (const auto &DiagPtr : Entry.getDiagnostics()) {
      const ClangTidyCustomDiagnostic &Diag = *DiagPtr;
      Context.diag(Diag.getAltDiagName(), Info.getLocation(),
                   Diag.getMessage());
    }

    // Restore the diagnostic client to be able to intercept all
    // diagnostics with the DiagnosticMapping class.
    Context.DiagEngine->setClient(this, false);
  } else {
    DiagConsumer.HandleDiagnostic(DiagLevel, Info);
  }

  // Update all the diagnostic statistics from the original diagnostic
  // consumer since this class is unaware of it.
  NumWarnings = DiagConsumer.getNumWarnings();
  NumErrors = DiagConsumer.getNumErrors();
}

void ClangTidyDiagnosticMapping::readMappingFile(StringRef Filename) {
  DiagnosticMappingReader Reader(this);
  Reader.readMappingFile(Filename);
}

void ClangTidyDiagnosticMapping::addCustomDiagnostic(
    std::unique_ptr<ClangTidyCustomDiagnostic> Diagnostic) {

  CustomDiagnosticEntry &Entry =
      DiagnosticMapping[Diagnostic->getOrigDiagName()];
  Entry.addDiagnostic(std::move(Diagnostic));
}

void ClangTidyDiagnosticMapping::addDiagnosticFlag(StringRef DiagnosticFlag) {
  DiagnosticFlags.insert(DiagnosticFlag);
}

clang::tooling::ArgumentsAdjuster
ClangTidyDiagnosticMapping::getArgumentsAdjuster() const {
  return [Flags =
              DiagnosticFlags](const clang::tooling::CommandLineArguments &Args,
                               llvm::StringRef /* unused */) {
    clang::tooling::CommandLineArguments AdjustedArgs = Args;
    for (const auto &Flag : Flags) {
      AdjustedArgs.push_back(Flag.getKey().str());
    }
    return AdjustedArgs;
  };
}

} // namespace clang::tidy
