/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidReservedIdentifierDeclarationCheck.cpp:
    1|       |//===--- AvoidReservedIdentifierDeclarationCheck.cpp - clang-tidy ---------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidReservedIdentifierDeclarationCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "llvm/ADT/StringSet.h"
   13|       |#include <cctype>
   14|       |
   15|       |using namespace clang::ast_matchers;
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |namespace {
   20|       |
   21|       |// Standard library reserved names that should not be declared
   22|       |const llvm::StringSet<> ReservedNames = {"errno",        "math_errhandling",
   23|       |                                         "setjmp",       "va_arg",
   24|       |                                         "va_copy",      "va_end",
   25|       |                                         "va_start",     "offsetof",
   26|       |                                         "NULL",         "true",
   27|       |                                         "false",        "bool",
   28|       |                                         "FILE",         "fpos_t",
   29|       |                                         "size_t",       "ptrdiff_t",
   30|       |                                         "wchar_t",      "int8_t",
   31|       |                                         "int16_t",      "int32_t",
   32|       |                                         "int64_t",      "uint8_t",
   33|       |                                         "uint16_t",     "uint32_t",
   34|       |                                         "uint64_t",     "intptr_t",
   35|       |                                         "uintptr_t",    "intmax_t",
   36|       |                                         "uintmax_t",    "div_t",
   37|       |                                         "ldiv_t",       "lldiv_t",
   38|       |                                         "sig_atomic_t", "time_t",
   39|       |                                         "clock_t",      "tm",
   40|       |                                         "jmp_buf",      "va_list"};
   41|       |
   42|  2.37k|bool isReservedIdentifier(StringRef Name) {
   43|  2.37k|  if (Name.empty())
  ------------------
  |  Branch (43:7): [True: 0, False: 2.37k]
  ------------------
   44|      0|    return false;
   45|       |
   46|       |  // Check for underscore followed by uppercase or another underscore
   47|       |  // These are reserved for any use
   48|  2.37k|  if (Name.size() >= 2 && Name[0] == '_') {
  ------------------
  |  Branch (48:7): [True: 1.83k, False: 542]
  |  Branch (48:27): [True: 7, False: 1.82k]
  ------------------
   49|      7|    if (std::isupper(static_cast<unsigned char>(Name[1])) || Name[1] == '_')
  ------------------
  |  Branch (49:9): [True: 3, False: 4]
  |  Branch (49:62): [True: 3, False: 1]
  ------------------
   50|      6|      return true;
   51|      7|  }
   52|       |
   53|       |  // Check for known standard library names
   54|  2.36k|  return ReservedNames.contains(Name);
   55|  2.37k|}
   56|       |
   57|       |} // anonymous namespace
   58|       |
   59|       |void AvoidReservedIdentifierDeclarationCheck::registerMatchers(
   60|    131|    MatchFinder *Finder) {
   61|       |  // Match variable declarations
   62|    131|  Finder->addMatcher(varDecl(unless(isImplicit())).bind("var"), this);
   63|       |
   64|       |  // Match function declarations
   65|    131|  Finder->addMatcher(functionDecl(unless(isImplicit())).bind("func"), this);
   66|       |
   67|       |  // Match typedef declarations
   68|    131|  Finder->addMatcher(typedefDecl(unless(isImplicit())).bind("typedef"), this);
   69|       |
   70|       |  // Match type alias declarations (using)
   71|    131|  Finder->addMatcher(typeAliasDecl(unless(isImplicit())).bind("alias"), this);
   72|       |
   73|       |  // Match record declarations (struct, union, enum)
   74|    131|  Finder->addMatcher(recordDecl(unless(isImplicit())).bind("record"), this);
   75|       |
   76|       |  // Match enum declarations
   77|    131|  Finder->addMatcher(enumDecl().bind("enum"), this);
   78|    131|}
   79|       |
   80|       |void AvoidReservedIdentifierDeclarationCheck::check(
   81|  35.6k|    const MatchFinder::MatchResult &Result) {
   82|  35.6k|  const NamedDecl *Decl = nullptr;
   83|  35.6k|  StringRef DeclType;
   84|       |
   85|  35.6k|  if (const auto *Var = Result.Nodes.getNodeAs<VarDecl>("var")) {
  ------------------
  |  Branch (85:19): [True: 18.2k, False: 17.3k]
  ------------------
   86|  18.2k|    Decl = Var;
   87|  18.2k|    DeclType = "variable";
   88|  18.2k|  } else if (const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("func")) {
  ------------------
  |  Branch (88:26): [True: 9.00k, False: 8.37k]
  ------------------
   89|  9.00k|    Decl = Func;
   90|  9.00k|    DeclType = "function";
   91|  9.00k|  } else if (const auto *TD = Result.Nodes.getNodeAs<TypedefDecl>("typedef")) {
  ------------------
  |  Branch (91:26): [True: 3.86k, False: 4.51k]
  ------------------
   92|  3.86k|    Decl = TD;
   93|  3.86k|    DeclType = "typedef";
   94|  4.51k|  } else if (const auto *TA = Result.Nodes.getNodeAs<TypeAliasDecl>("alias")) {
  ------------------
  |  Branch (94:26): [True: 1.16k, False: 3.34k]
  ------------------
   95|  1.16k|    Decl = TA;
   96|  1.16k|    DeclType = "type alias";
   97|  3.34k|  } else if (const auto *RD = Result.Nodes.getNodeAs<RecordDecl>("record")) {
  ------------------
  |  Branch (97:26): [True: 3.14k, False: 201]
  ------------------
   98|  3.14k|    Decl = RD;
   99|  3.14k|    DeclType = RD->isUnion() ? "union" : "struct";
  ------------------
  |  Branch (99:16): [True: 62, False: 3.08k]
  ------------------
  100|  3.14k|  } else if (const auto *ED = Result.Nodes.getNodeAs<EnumDecl>("enum")) {
  ------------------
  |  Branch (100:26): [True: 201, False: 0]
  ------------------
  101|    201|    Decl = ED;
  102|    201|    DeclType = "enum";
  103|    201|  }
  104|       |
  105|  35.6k|  if (!Decl)
  ------------------
  |  Branch (105:7): [True: 0, False: 35.6k]
  ------------------
  106|      0|    return;
  107|       |
  108|       |  // Skip declarations in system headers
  109|  35.6k|  if (Result.SourceManager->isInSystemHeader(Decl->getLocation()))
  ------------------
  |  Branch (109:7): [True: 32.4k, False: 3.16k]
  ------------------
  110|  32.4k|    return;
  111|       |
  112|       |  // Skip unnamed declarations
  113|  3.16k|  if (!Decl->getIdentifier())
  ------------------
  |  Branch (113:7): [True: 793, False: 2.37k]
  ------------------
  114|    793|    return;
  115|       |
  116|  2.37k|  StringRef Name = Decl->getName();
  117|  2.37k|  if (isReservedIdentifier(Name)) {
  ------------------
  |  Branch (117:7): [True: 7, False: 2.36k]
  ------------------
  118|      7|    diag(Decl->getLocation(), "%0 declaration uses reserved identifier '%1'")
  119|      7|        << DeclType << Name;
  120|      7|  }
  121|  2.37k|}
  122|       |
  123|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidUninitializedReadCheck.cpp:
    1|       |//===--- AvoidUninitializedReadCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidUninitializedReadCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidUninitializedReadCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match DeclRefExpr that refers to a local variable (automatic storage)
   19|       |  // that does not have an initializer.
   20|       |  // We look for variables in the initializer of other variables or in
   21|       |  // expressions that are not themselves initializers.
   22|       |
   23|       |  // Match uninitialized local variables being read
   24|       |  // Exclude function parameters (ParmVarDecl) - they are initialized by caller
   25|    131|  Finder->addMatcher(declRefExpr(to(varDecl(hasAutomaticStorageDuration(),
   26|    131|                                            unless(hasInitializer(anything())),
   27|    131|                                            unless(parmVarDecl()))
   28|    131|                                        .bind("uninit_var")),
   29|       |                                 // Ensure we're in a context where the variable
   30|       |                                 // is being read (not just declared)
   31|    131|                                 unless(hasParent(declStmt())))
   32|    131|                         .bind("ref"),
   33|    131|                     this);
   34|    131|}
   35|       |
   36|       |void AvoidUninitializedReadCheck::check(
   37|    457|    const MatchFinder::MatchResult &Result) {
   38|    457|  const auto *Ref = Result.Nodes.getNodeAs<DeclRefExpr>("ref");
   39|    457|  const auto *Var = Result.Nodes.getNodeAs<VarDecl>("uninit_var");
   40|       |
   41|    457|  if (!Ref || !Var)
  ------------------
  |  Branch (41:7): [True: 0, False: 457]
  |  Branch (41:15): [True: 0, False: 457]
  ------------------
   42|      0|    return;
   43|       |
   44|       |  // Skip if in system header
   45|    457|  if (Result.SourceManager->isInSystemHeader(Ref->getLocation()))
  ------------------
  |  Branch (45:7): [True: 202, False: 255]
  ------------------
   46|    202|    return;
   47|       |
   48|       |  // Check if this is truly a read operation
   49|       |  // We want to avoid false positives for address-of operations
   50|       |  // or when the variable is on the left-hand side of an assignment
   51|       |
   52|       |  // Get the parent context to determine if this is a read or write
   53|    255|  const auto Parents = Result.Context->getParents(*Ref);
   54|    255|  if (Parents.empty())
  ------------------
  |  Branch (54:7): [True: 0, False: 255]
  ------------------
   55|      0|    return;
   56|       |
   57|    255|  const auto *Parent = Parents[0].get<Stmt>();
   58|    255|  if (!Parent)
  ------------------
  |  Branch (58:7): [True: 0, False: 255]
  ------------------
   59|      0|    return;
   60|       |
   61|       |  // If the parent is a unary operator & (address-of), this might be okay
   62|       |  // as it could be an out-parameter being initialized
   63|    255|  if (const auto *UnaryOp = dyn_cast<UnaryOperator>(Parent)) {
  ------------------
  |  Branch (63:19): [True: 5, False: 250]
  ------------------
   64|      5|    if (UnaryOp->getOpcode() == UO_AddrOf)
  ------------------
  |  Branch (64:9): [True: 4, False: 1]
  ------------------
   65|      4|      return;
   66|      5|  }
   67|       |
   68|       |  // If the parent is a binary operator and this is the LHS of an assignment,
   69|       |  // it's being written to, not read
   70|    251|  if (const auto *BinOp = dyn_cast<BinaryOperator>(Parent)) {
  ------------------
  |  Branch (70:19): [True: 123, False: 128]
  ------------------
   71|    123|    if (BinOp->isAssignmentOp() && BinOp->getLHS() == Ref)
  ------------------
  |  Branch (71:9): [True: 123, False: 0]
  |  Branch (71:36): [True: 123, False: 0]
  ------------------
   72|    123|      return;
   73|    123|  }
   74|       |
   75|       |  // If we reach here, this appears to be a read of an uninitialized variable
   76|    128|  diag(Ref->getLocation(),
   77|    128|       "value of object '%0' with automatic storage duration is read "
   78|    128|       "before it has been initialized")
   79|    128|      << Var->getName();
   80|       |
   81|    128|  diag(Var->getLocation(), "variable '%0' declared here", DiagnosticIDs::Note)
   82|    128|      << Var->getName();
   83|    128|}
   84|       |
   85|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/MissingStaticForInternalCheck.h:
    1|       |//===--- MissingStaticForInternalCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGSTATICFORINTERNALCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGSTATICFORINTERNALCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects functions and objects that could be declared static.
   17|       |///
   18|       |/// MISRA C:2025 Rule 8.7 (Advisory) recommends that functions and objects
   19|       |/// that are only referenced within a single translation unit should be
   20|       |/// declared with internal linkage (static). This reduces the risk of
   21|       |/// naming collisions and improves encapsulation.
   22|       |///
   23|       |/// Example of non-compliant code:
   24|       |/// \code
   25|       |///   // In file.c - helper function only used in this file
   26|       |///   int helper_function(int x) { return x * 2; }
   27|       |///   int public_function(void) { return helper_function(21); }
   28|       |/// \endcode
   29|       |///
   30|       |/// Example of compliant code:
   31|       |/// \code
   32|       |///   static int helper_function(int x) { return x * 2; }
   33|       |///   int public_function(void) { return helper_function(21); }
   34|       |/// \endcode
   35|       |///
   36|       |/// Note: This check flags functions and file-scope objects without the
   37|       |/// static keyword that have no external declaration. It cannot perform
   38|       |/// whole-program analysis to verify they're truly unused externally.
   39|       |class MissingStaticForInternalCheck : public ClangTidyCheck {
   40|       |public:
   41|       |  /// Constructs the check with the given name and context.
   42|       |  MissingStaticForInternalCheck(StringRef Name, ClangTidyContext *Context)
   43|    131|      : ClangTidyCheck(Name, Context) {}
   44|       |
   45|       |  /// Destructor.
   46|    131|  ~MissingStaticForInternalCheck() override = default;
   47|       |
   48|       |  /// Registers AST matchers for function and variable declarations.
   49|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   50|       |
   51|       |  /// Handles matched declarations and emits diagnostics.
   52|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   53|       |};
   54|       |
   55|       |} // namespace clang::tidy::automotive
   56|       |
   57|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGSTATICFORINTERNALCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidGlobalObjectCheck.cpp:
    1|       |//===--- AvoidGlobalObjectCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidGlobalObjectCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidGlobalObjectCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match file-scope static variables (internal linkage)
   19|       |  // that are not const-qualified
   20|    131|  Finder->addMatcher(varDecl(hasGlobalStorage(), isStaticStorageClass(),
   21|    131|                             unless(hasAncestor(functionDecl())),
   22|    131|                             unless(isConstexpr()),
   23|    131|                             unless(hasType(qualType(isConstQualified()))))
   24|    131|                         .bind("staticvar"),
   25|    131|                     this);
   26|       |
   27|       |  // Match references to static file-scope variables within functions
   28|       |  // Filter out const variables as they are typically intentional constants
   29|    131|  Finder->addMatcher(
   30|    131|      declRefExpr(to(varDecl(hasGlobalStorage(), isStaticStorageClass(),
   31|    131|                             unless(hasAncestor(functionDecl())),
   32|    131|                             unless(hasType(qualType(isConstQualified()))))
   33|    131|                         .bind("refvar")),
   34|    131|                  hasAncestor(functionDecl().bind("func")))
   35|    131|          .bind("ref"),
   36|    131|      this);
   37|    131|}
   38|       |
   39|     35|void AvoidGlobalObjectCheck::check(const MatchFinder::MatchResult &Result) {
   40|     35|  SM = Result.SourceManager;
   41|       |
   42|       |  // Handle static file-scope variable declarations
   43|     35|  if (const auto *StaticVar = Result.Nodes.getNodeAs<VarDecl>("staticvar")) {
  ------------------
  |  Branch (43:19): [True: 18, False: 17]
  ------------------
   44|     18|    if (SM->isInSystemHeader(StaticVar->getLocation()))
  ------------------
  |  Branch (44:9): [True: 0, False: 18]
  ------------------
   45|      0|      return;
   46|       |
   47|       |    // Track this variable if not already tracked
   48|     18|    if (VarUsages.find(StaticVar) == VarUsages.end()) {
  ------------------
  |  Branch (48:9): [True: 18, False: 0]
  ------------------
   49|     18|      VarUsages[StaticVar] = {};
   50|     18|      FileVars.push_back(StaticVar);
   51|     18|    }
   52|     18|    return;
   53|     18|  }
   54|       |
   55|       |  // Handle references to static variables within functions
   56|     17|  if (Result.Nodes.getNodeAs<DeclRefExpr>("ref")) {
  ------------------
  |  Branch (56:7): [True: 17, False: 0]
  ------------------
   57|     17|    const auto *RefVar = Result.Nodes.getNodeAs<VarDecl>("refvar");
   58|     17|    const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("func");
   59|       |
   60|     17|    if (!RefVar || !Func)
  ------------------
  |  Branch (60:9): [True: 0, False: 17]
  |  Branch (60:20): [True: 0, False: 17]
  ------------------
   61|      0|      return;
   62|       |
   63|     17|    if (SM->isInSystemHeader(RefVar->getLocation()))
  ------------------
  |  Branch (63:9): [True: 0, False: 17]
  ------------------
   64|      0|      return;
   65|       |
   66|       |    // Track which function uses this variable
   67|     17|    auto It = VarUsages.find(RefVar);
   68|     17|    if (It == VarUsages.end()) {
  ------------------
  |  Branch (68:9): [True: 0, False: 17]
  ------------------
   69|      0|      VarUsages[RefVar] = {};
   70|      0|      FileVars.push_back(RefVar);
   71|      0|    }
   72|     17|    VarUsages[RefVar].insert(Func->getCanonicalDecl());
   73|     17|  }
   74|     17|}
   75|       |
   76|    131|void AvoidGlobalObjectCheck::onEndOfTranslationUnit() {
   77|    131|  for (const VarDecl *Var : FileVars) {
  ------------------
  |  Branch (77:27): [True: 18, False: 131]
  ------------------
   78|     18|    auto It = VarUsages.find(Var);
   79|     18|    if (It == VarUsages.end())
  ------------------
  |  Branch (79:9): [True: 0, False: 18]
  ------------------
   80|      0|      continue;
   81|       |
   82|     18|    const auto &Functions = It->second;
   83|       |
   84|       |    // If used by exactly one function, suggest moving to block scope
   85|     18|    if (Functions.size() == 1) {
  ------------------
  |  Branch (85:9): [True: 9, False: 9]
  ------------------
   86|      9|      const FunctionDecl *Func = *Functions.begin();
   87|      9|      diag(Var->getLocation(),
   88|      9|           "file-scope object '%0' is only used in function '%1'; "
   89|      9|           "consider defining it at block scope")
   90|      9|          << Var->getName() << Func->getName();
   91|      9|    }
   92|     18|  }
   93|       |
   94|       |  // Clear for next TU
   95|    131|  VarUsages.clear();
   96|    131|  FileVars.clear();
   97|    131|}
   98|       |
   99|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidRestrictTypeCheck.cpp:
    1|       |//===--- AvoidRestrictTypeCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidRestrictTypeCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/AST/ASTContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void AvoidRestrictTypeCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(typeLoc(loc(qualType(automotive::isRestrictType())))
   20|    131|                         .bind("restrictTypeLoc"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|  1.18k|void AvoidRestrictTypeCheck::check(const MatchFinder::MatchResult &Result) {
   25|  1.18k|  const auto *MatchedTypeLoc =
   26|  1.18k|      Result.Nodes.getNodeAs<TypeLoc>("restrictTypeLoc");
   27|       |
   28|  1.18k|  if (MatchedTypeLoc) {
  ------------------
  |  Branch (28:7): [True: 1.18k, False: 0]
  ------------------
   29|  1.18k|    SourceLocation Loc = MatchedTypeLoc->getBeginLoc();
   30|  1.18k|    if (Loc.isValid()) {
  ------------------
  |  Branch (30:9): [True: 1.18k, False: 0]
  ------------------
   31|  1.18k|      diag(Loc, "avoid restrict type");
   32|  1.18k|    }
   33|  1.18k|  }
   34|  1.18k|}
   35|       |
   36|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidReservedIdentifierDeclarationCheck.h:
    1|       |//===--- AvoidReservedIdentifierDeclarationCheck.h - clang-tidy -*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDIDENTIFIERDECLARATIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDIDENTIFIERDECLARATIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-storage
   17|       |/// @brief Detects declarations that use reserved identifiers.
   18|       |///
   19|       |/// Reserved identifiers (those starting with underscore followed by uppercase
   20|       |/// or another underscore, or identifiers reserved by the C standard library)
   21|       |/// shall not be declared. Such declarations may cause undefined behavior
   22|       |/// and conflict with compiler or library internals.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 21.2
   25|       |/// A reserved identifier or macro name shall not be declared.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   int _Reserved;      // Warning: starts with underscore + uppercase
   31|       |///   void __internal();  // Warning: starts with double underscore
   32|       |///   int errno;          // Warning: standard library name
   33|       |///   typedef int size_t; // Warning: standard library type
   34|       |/// @endcode
   35|       |class AvoidReservedIdentifierDeclarationCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidReservedIdentifierDeclarationCheck(StringRef Name,
   38|       |                                          ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidReservedIdentifierDeclarationCheck() override = default;
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDIDENTIFIERDECLARATIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/storage/StorageComponent.cpp:
    1|       |//===--- StorageComponent.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "StorageComponent.h"
   10|       |#include "AvoidGlobalObjectCheck.h"
   11|       |#include "AvoidReservedIdentifierDeclarationCheck.h"
   12|       |#include "AvoidRestrictTypeCheck.h"
   13|       |#include "AvoidUninitializedReadCheck.h"
   14|       |#include "MissingStaticForInternalCheck.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |void StorageComponent::addCheckFactories(
   19|    262|    ClangTidyCheckFactories &CheckFactories) {
   20|       |
   21|       |  // Rule 21.2 - Reserved identifier declarations (Required)
   22|    262|  CheckFactories.registerCheck<AvoidReservedIdentifierDeclarationCheck>(
   23|    262|      "automotive-c23-req-21.2");
   24|       |
   25|       |  // Rule 8.9 - Object at block scope (Advisory)
   26|    262|  CheckFactories.registerCheck<AvoidGlobalObjectCheck>(
   27|    262|      "automotive-c23-adv-8.9");
   28|       |
   29|       |  // Rule 9.1 - Uninitialized read (Required)
   30|    262|  CheckFactories.registerCheck<AvoidUninitializedReadCheck>(
   31|    262|      "automotive-c23-req-9.1");
   32|       |
   33|    262|  CheckFactories.registerCheck<AvoidRestrictTypeCheck>(
   34|    262|      "automotive-avoid-restrict-type");
   35|       |
   36|       |  // Rule 8.7 - Static for internal linkage (Advisory)
   37|    262|  CheckFactories.registerCheck<MissingStaticForInternalCheck>(
   38|    262|      "automotive-c23-adv-8.7");
   39|    262|}
   40|       |
   41|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidUninitializedReadCheck.h:
    1|       |//===--- AvoidUninitializedReadCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNINITIALIZEDREADCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNINITIALIZEDREADCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-storage
   17|       |/// @brief Detects reads from uninitialized local variables.
   18|       |///
   19|       |/// Objects with automatic storage duration must be initialized before their
   20|       |/// value is read. Reading from an uninitialized variable leads to undefined
   21|       |/// behavior.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 9.1
   24|       |/// The value of an object with automatic storage duration shall not be read
   25|       |/// before it has been set.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   void func() {
   31|       |///       int x;
   32|       |///       int y = x;  // Warning: reading uninitialized variable 'x'
   33|       |///   }
   34|       |///
   35|       |///   // Compliant:
   36|       |///   void func() {
   37|       |///       int x = 0;  // OK: initialized before use
   38|       |///       int y = x;
   39|       |///   }
   40|       |/// @endcode
   41|       |class AvoidUninitializedReadCheck : public ClangTidyCheck {
   42|       |public:
   43|       |  AvoidUninitializedReadCheck(StringRef Name, ClangTidyContext *Context)
   44|    131|      : ClangTidyCheck(Name, Context) {}
   45|       |
   46|       |  /// Destructor.
   47|    131|  ~AvoidUninitializedReadCheck() override = default;
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNINITIALIZEDREADCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidGlobalObjectCheck.h:
    1|       |//===--- AvoidGlobalObjectCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGLOBALOBJECTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGLOBALOBJECTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "llvm/ADT/DenseMap.h"
   14|       |#include "llvm/ADT/SmallPtrSet.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |/// @ingroup misra-c25-storage
   19|       |/// @brief Detects file-scope objects that could be defined at block scope.
   20|       |///
   21|       |/// An object should be defined at block scope if its identifier only appears
   22|       |/// in a single function. This improves locality and makes the code easier to
   23|       |/// understand and maintain.
   24|       |///
   25|       |/// @par MISRA C:2025 Rule 8.9
   26|       |/// An object should be defined at block scope if its identifier only appears
   27|       |/// in a single function.
   28|       |/// @par Category: Advisory
   29|       |///
   30|       |/// Example:
   31|       |/// @code
   32|       |///   static int counter;  // Warning if only used in one function
   33|       |///
   34|       |///   void increment() {
   35|       |///       counter++;
   36|       |///   }
   37|       |///
   38|       |///   // Better: move to block scope
   39|       |///   void increment() {
   40|       |///       static int counter = 0;  // OK: defined at block scope
   41|       |///       counter++;
   42|       |///   }
   43|       |/// @endcode
   44|       |class AvoidGlobalObjectCheck : public ClangTidyCheck {
   45|       |public:
   46|       |  AvoidGlobalObjectCheck(StringRef Name, ClangTidyContext *Context)
   47|    131|      : ClangTidyCheck(Name, Context) {}
   48|       |
   49|       |  /// Destructor.
   50|    131|  ~AvoidGlobalObjectCheck() override = default;
   51|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   52|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   53|       |  void onEndOfTranslationUnit() override;
   54|       |
   55|       |private:
   56|       |  /// Maps file-scope variables to the functions that reference them
   57|       |  llvm::DenseMap<const VarDecl *, llvm::SmallPtrSet<const FunctionDecl *, 4>>
   58|       |      VarUsages;
   59|       |  /// Store variable declarations for end-of-TU reporting
   60|       |  llvm::SmallVector<const VarDecl *, 16> FileVars;
   61|       |  /// Source manager pointer for end-of-TU reporting
   62|       |  const SourceManager *SM = nullptr;
   63|       |};
   64|       |
   65|       |} // namespace clang::tidy::automotive
   66|       |
   67|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGLOBALOBJECTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/storage/MissingStaticForInternalCheck.cpp:
    1|       |//===--- MissingStaticForInternalCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingStaticForInternalCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void MissingStaticForInternalCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match function definitions without static that are not main
   19|       |  // In C, functions without static have external linkage by default, but if
   20|       |  // they have no prior declaration in a header, they should be static.
   21|    131|  Finder->addMatcher(functionDecl(isDefinition(), unless(isMain()),
   22|    131|                                  unless(isStaticStorageClass()),
   23|    131|                                  unless(isInline()),
   24|    131|                                  hasParent(translationUnitDecl()))
   25|    131|                         .bind("func"),
   26|    131|                     this);
   27|       |
   28|       |  // Match file-scope variable definitions without static at file scope
   29|       |  // Note: isExternC() matches all C declarations (C linkage), so don't use it
   30|    131|  Finder->addMatcher(varDecl(hasGlobalStorage(), unless(isStaticStorageClass()),
   31|    131|                             hasParent(translationUnitDecl()))
   32|    131|                         .bind("var"),
   33|    131|                     this);
   34|    131|}
   35|       |
   36|       |void MissingStaticForInternalCheck::check(
   37|    609|    const MatchFinder::MatchResult &Result) {
   38|       |  // Check function declarations
   39|    609|  if (const auto *FD = Result.Nodes.getNodeAs<FunctionDecl>("func")) {
  ------------------
  |  Branch (39:19): [True: 532, False: 77]
  ------------------
   40|    532|    if (Result.SourceManager->isInSystemHeader(FD->getLocation()))
  ------------------
  |  Branch (40:9): [True: 0, False: 532]
  ------------------
   41|      0|      return;
   42|       |
   43|       |    // Skip functions that have a prior declaration (likely in header)
   44|    532|    if (FD->getPreviousDecl())
  ------------------
  |  Branch (44:9): [True: 11, False: 521]
  ------------------
   45|     11|      return;
   46|       |
   47|       |    // Skip inline functions (they may need external linkage for ODR)
   48|    521|    if (FD->isInlined())
  ------------------
  |  Branch (48:9): [True: 0, False: 521]
  ------------------
   49|      0|      return;
   50|       |
   51|    521|    diag(FD->getLocation(),
   52|    521|         "function %0 has no external declaration; consider declaring it "
   53|    521|         "static for internal linkage")
   54|    521|        << FD;
   55|    521|    return;
   56|    521|  }
   57|       |
   58|       |  // Check variable declarations
   59|     77|  if (const auto *VD = Result.Nodes.getNodeAs<VarDecl>("var")) {
  ------------------
  |  Branch (59:19): [True: 77, False: 0]
  ------------------
   60|     77|    if (Result.SourceManager->isInSystemHeader(VD->getLocation()))
  ------------------
  |  Branch (60:9): [True: 15, False: 62]
  ------------------
   61|     15|      return;
   62|       |
   63|       |    // Skip extern declarations
   64|     62|    if (VD->hasExternalStorage())
  ------------------
  |  Branch (64:9): [True: 10, False: 52]
  ------------------
   65|     10|      return;
   66|       |
   67|       |    // Skip variables that have a prior declaration
   68|     52|    if (VD->getPreviousDecl())
  ------------------
  |  Branch (68:9): [True: 0, False: 52]
  ------------------
   69|      0|      return;
   70|       |
   71|     52|    diag(VD->getLocation(),
   72|     52|         "file-scope object %0 has no external declaration; consider "
   73|     52|         "declaring it static for internal linkage")
   74|     52|        << VD;
   75|     52|  }
   76|     77|}
   77|       |
   78|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/storage/AvoidRestrictTypeCheck.h:
    1|       |//===--- AvoidRestrictTypeCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESTRICTTYPECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESTRICTTYPECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the restrict type qualifier.
   17|       |///
   18|       |/// The restrict keyword is a C99 feature that provides optimization hints
   19|       |/// to the compiler about pointer aliasing. However, incorrect use of restrict
   20|       |/// can lead to undefined behavior if the aliasing guarantees are violated.
   21|       |/// Its use should be carefully considered and limited to performance-critical
   22|       |/// code where aliasing behavior is well-understood.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 8.14 - The restrict type qualifier shall not
   25|       |/// be used.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   void func(int *restrict ptr) { }  // Warning: restrict used
   30|       |/// \endcode
   31|       |class AvoidRestrictTypeCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidRestrictTypeCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidRestrictTypeCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for restrict qualified types.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched restrict qualifiers and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESTRICTTYPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidApiHandler.h:
    1|       |//===--- AvoidApiHandler.h - clang-tidy -------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPIHANDLER_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPIHANDLER_H
   11|       |
   12|       |#include "clang/Basic/SourceLocation.h"
   13|       |#include "clang/Lex/PPCallbacks.h"
   14|       |#include "llvm/ADT/StringRef.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |class MatchHeaderInfo {
   19|       |public:
   20|       |  const StringRef Name;
   21|       |  const clang::SourceLocation Location;
   22|       |  const Token &Tok;
   23|       |  const bool IsAngled;
   24|       |};
   25|       |
   26|       |class MatchMacroInfo {
   27|       |public:
   28|       |  const StringRef Name;
   29|       |  const MatchHeaderInfo *Header;
   30|       |  const Token &Tok;
   31|       |};
   32|       |
   33|       |class AvoidApiHandler {
   34|       |public:
   35|       |  virtual ~AvoidApiHandler() = default;
   36|       |
   37|       |  /// Override to check header inclusions. Default: no-op.
   38|       |  // LCOV_EXCL_START - default no-op implementations, subclasses override
   39|      0|  virtual void checkHeader(const MatchHeaderInfo &Result) {}
   40|       |
   41|       |  /// Override to check macro usage. Default: no-op.
   42|      0|  virtual void checkMacro(const MatchMacroInfo &Result) {}
   43|       |
   44|       |  /// Override to check function calls. Default: no-op.
   45|      0|  virtual void checkFunction(const MatchMacroInfo &Result) {}
   46|       |  // LCOV_EXCL_STOP
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPIHANDLER_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidApiCheck.h:
    1|       |//===--- AvoidApiCheck.h - clang-tidy --------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPICHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPICHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "AvoidApiHandler.h"
   14|       |#include "llvm/ADT/ArrayRef.h"
   15|       |#include "llvm/ADT/StringRef.h"
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |/// Base class for checks that detect usage of specific standard library APIs.
   20|       |///
   21|       |/// This check provides a framework for detecting and warning about the use
   22|       |/// of specific standard library functions and headers that may be prohibited
   23|       |/// in safety-critical code. Derived checks specify which functions and headers
   24|       |/// to flag.
   25|       |///
   26|       |/// Related MISRA C:2025 Rule: Various rules related to standard library usage.
   27|       |///
   28|       |/// Example:
   29|       |/// \code
   30|       |///   // Derived checks will flag specific function calls
   31|       |/// \endcode
   32|       |class AvoidApiCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Registers preprocessor callbacks for header inclusion checking.
   35|       |  /// \param SM The source manager.
   36|       |  /// \param PP The preprocessor instance.
   37|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   38|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   39|       |                           Preprocessor *ModuleExpanderPP) override;
   40|       |
   41|       |  /// Registers AST matchers for function calls.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched function calls and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |
   49|       |protected:
   50|       |  /// Constructs the check with header and function names.
   51|       |  /// \param Name The name of the check as registered.
   52|       |  /// \param Context The clang-tidy context for configuration.
   53|       |  /// \param Header The header file to check for.
   54|       |  /// \param FunctionNames List of function names to flag.
   55|       |  AvoidApiCheck(StringRef Name, ClangTidyContext *Context, StringRef Header,
   56|       |                const std::initializer_list<llvm::StringRef> &FunctionNames)
   57|    131|      : ClangTidyCheck(Name, Context) {}
   58|       |
   59|       |  /// Destructor.
   60|    262|  ~AvoidApiCheck() override = default;
   61|       |
   62|       |  /// Constructs the check with function names only.
   63|       |  /// \param Name The name of the check as registered.
   64|       |  /// \param Context The clang-tidy context for configuration.
   65|       |  /// \param FunctionNames List of function names to flag.
   66|       |  AvoidApiCheck(StringRef Name, ClangTidyContext *Context,
   67|       |                const std::initializer_list<llvm::StringRef> &FunctionNames)
   68|      0|      : ClangTidyCheck(Name, Context) {}
   69|       |
   70|       |  /// Constructs the check with header and function name array.
   71|       |  /// \param Name The name of the check as registered.
   72|       |  /// \param Context The clang-tidy context for configuration.
   73|       |  /// \param HeaderName The header file to check for.
   74|       |  /// \param FunctionNames Array of function names to flag.
   75|       |  AvoidApiCheck(StringRef Name, ClangTidyContext *Context, StringRef HeaderName,
   76|       |                ArrayRef<StringRef> FunctionNames)
   77|    131|      : ClangTidyCheck(Name, Context), FunctionNames(FunctionNames),
   78|    131|        HeaderName(HeaderName) {}
   79|       |
   80|       |private:
   81|       |  ArrayRef<StringRef> FunctionNames;
   82|       |  StringRef HeaderName;
   83|       |};
   84|       |
   85|       |} // namespace clang::tidy::automotive
   86|       |
   87|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAPICHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidstdlibsystemcallCheck.cpp:
    1|       |//===--- AvoidstdlibsystemcallCheck.cpp - clang-tidy ----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidstdlibsystemcallCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidstdlibsystemcallCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      callExpr(callee(functionDecl(hasName("system")))).bind("func"), this);
   20|    131|}
   21|       |
   22|      1|void AvoidstdlibsystemcallCheck::check(const MatchFinder::MatchResult &Result) {
   23|      1|  const auto *MatchedCall = Result.Nodes.getNodeAs<CallExpr>("func");
   24|      1|  if (MatchedCall) {
  ------------------
  |  Branch (24:7): [True: 1, False: 0]
  ------------------
   25|      1|    diag(MatchedCall->getBeginLoc(), "Avoid '%0' call from stdlib")
   26|      1|        << MatchedCall->getDirectCallee()->getNameAsString();
   27|      1|  }
   28|      1|}
   29|       |
   30|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/ExitCheck.cpp:
    1|       |//===--- AtoXCheck.cpp - clang-tidy --------------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ExitCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void ExitCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(callExpr(callee(functionDecl(hasAnyName(
   19|    131|                                  "abort", "exit", "_Exit", "quick_exit"))))
   20|    131|                         .bind("func"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|      4|void ExitCheck::check(const MatchFinder::MatchResult &Result) {
   25|      4|  const auto *MatchedCall = Result.Nodes.getNodeAs<CallExpr>("func");
   26|      4|  if (MatchedCall) {
  ------------------
  |  Branch (26:7): [True: 4, False: 0]
  ------------------
   27|      4|    diag(MatchedCall->getBeginLoc(), "Avoid termination function '%0'")
   28|      4|        << MatchedCall->getDirectCallee()->getNameAsString();
   29|      4|  }
   30|      4|}
   31|       |
   32|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidSetjmpHeaderCheck.cpp:
    1|       |//===--- AvoidSetjmpHeaderCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSetjmpHeaderCheck.h"
   10|       |
   11|       |namespace clang::tidy::automotive {
   12|       |
   13|       |static const StringRef AvoidFunctions[] = {"setjmp", "longjmp"};
   14|       |
   15|       |AvoidSetjmpHeaderCheck::AvoidSetjmpHeaderCheck(StringRef Name,
   16|       |                                               ClangTidyContext *Context)
   17|    131|    : AvoidApiCheck(Name, Context, "setjmp.h", AvoidFunctions) {}
   18|       |
   19|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidSetjmpHeaderCheck.h:
    1|       |//===--- AvoidSetjmpHeaderCheck.h - clang-tidy -----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_SETJMPCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_SETJMPCHECK_H
   11|       |
   12|       |#include "AvoidApiCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of setjmp/longjmp functions from setjmp.h header.
   17|       |///
   18|       |/// The setjmp and longjmp functions provide non-local jumps that bypass
   19|       |/// normal function call/return mechanisms. This can lead to undefined
   20|       |/// behavior, resource leaks, and makes program flow difficult to analyze.
   21|       |/// They are particularly problematic in safety-critical code.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.4 - The standard header file <setjmp.h>
   24|       |/// shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   #include <setjmp.h>  // Warning: setjmp.h usage
   29|       |///   jmp_buf env;
   30|       |///   setjmp(env);         // Warning: setjmp usage
   31|       |/// \endcode
   32|       |class AvoidSetjmpHeaderCheck : public AvoidApiCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  AvoidSetjmpHeaderCheck(StringRef Name, ClangTidyContext *Context);
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidSetjmpHeaderCheck() override = default;
   41|       |};
   42|       |
   43|       |} // namespace clang::tidy::automotive
   44|       |
   45|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_SETJMPCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidstdlibsystemcallCheck.h:
    1|       |//===--- AvoidstdlibsystemcallCheck.h - clang-tidy --------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBSYSTEMCALLCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBSYSTEMCALLCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the system() function from stdlib.h.
   17|       |///
   18|       |/// The system() function executes external commands, which poses security
   19|       |/// risks and makes program behavior dependent on the environment. It can
   20|       |/// lead to command injection vulnerabilities and makes the program's behavior
   21|       |/// unpredictable and difficult to verify in safety-critical systems.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.8 - The library functions system and abort
   24|       |/// shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   system("ls");  // Warning: system() function call
   29|       |/// \endcode
   30|       |class AvoidstdlibsystemcallCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidstdlibsystemcallCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidstdlibsystemcallCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for system() calls.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched system() calls and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBSYSTEMCALLCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidApiCheck.cpp:
    1|       |//===--- AvoidApiCheck.cpp - clang-tidy ----------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidApiCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "clang/Lex/PPCallbacks.h"
   13|       |#include "clang/Lex/Preprocessor.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |using namespace clang::ast_matchers;
   18|       |
   19|       |class AvoidApiPPCallbacks : public PPCallbacks {
   20|       |public:
   21|       |  AvoidApiPPCallbacks(AvoidApiCheck &Check, StringRef HeaderName,
   22|       |                      ArrayRef<StringRef> MacroNames)
   23|    262|      : Check(Check), MacroNames(MacroNames), HeaderName(HeaderName) {}
   24|       |
   25|       |  void InclusionDirective(SourceLocation DirectiveLoc,
   26|       |                          const Token &IncludeToken, StringRef IncludedFilename,
   27|       |                          bool IsAngled, CharSourceRange FilenameRange,
   28|       |                          OptionalFileEntryRef IncludedFile,
   29|       |                          StringRef SearchPath, StringRef RelativePath,
   30|       |                          const Module *SuggestedModule, bool ModuleImported,
   31|       |                          SrcMgr::CharacteristicKind FileType) override;
   32|       |
   33|       |  void MacroExpands(const Token &MacroNameTok, const MacroDefinition &MD,
   34|       |                    SourceRange Range, const MacroArgs *Args) override;
   35|       |
   36|       |private:
   37|       |  [[maybe_unused]] AvoidApiCheck
   38|       |      &Check; // Will be used when callbacks are implemented
   39|       |  ArrayRef<StringRef> MacroNames;
   40|       |  StringRef HeaderName;
   41|       |};
   42|       |
   43|       |void AvoidApiCheck::registerPPCallbacks(const SourceManager &SM,
   44|       |                                        Preprocessor *PP,
   45|    262|                                        Preprocessor *ModuleExpanderPP) {
   46|       |
   47|    262|  PP->addPPCallbacks(
   48|    262|      std::make_unique<AvoidApiPPCallbacks>(*this, HeaderName, FunctionNames));
   49|    262|}
   50|       |
   51|    262|void AvoidApiCheck::registerMatchers(MatchFinder *Finder) {
   52|    262|  Finder->addMatcher(callExpr(callee(functionDecl(hasAnyName(FunctionNames))))
   53|    262|                         .bind("functionCall"),
   54|    262|                     this);
   55|    262|}
   56|       |
   57|      1|void AvoidApiCheck::check(const MatchFinder::MatchResult &Result) {
   58|       |  // Implementation deferred - matches handled via PP callbacks
   59|      1|}
   60|       |
   61|       |void AvoidApiPPCallbacks::InclusionDirective(
   62|       |    SourceLocation DirectiveLoc, const Token &IncludeToken,
   63|       |    StringRef IncludedFilename, bool IsAngled, CharSourceRange FilenameRange,
   64|       |    OptionalFileEntryRef IncludedFile, StringRef SearchPath,
   65|       |    StringRef RelativePath, const Module *SuggestedModule, bool ModuleImported,
   66|  3.25k|    SrcMgr::CharacteristicKind FileType) {
   67|       |  // Header inclusion checking not yet implemented
   68|  3.25k|}
   69|       |
   70|       |void AvoidApiPPCallbacks::MacroExpands(const Token &MacroNameTok,
   71|       |                                       const MacroDefinition &MD,
   72|       |                                       SourceRange Range,
   73|  42.4k|                                       const MacroArgs *Args) {
   74|       |  // Macro expansion checking not yet implemented
   75|  42.4k|}
   76|       |
   77|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidStdlibRandCheck.h:
    1|       |//===--- AvoidStdlibRandCheck.h - clang-tidy ----------.---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBRANDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBRANDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of rand() and srand() functions from stdlib.h.
   17|       |///
   18|       |/// The rand() function produces pseudo-random numbers with implementation-
   19|       |/// defined quality and is not suitable for security-critical applications.
   20|       |/// The sequence is deterministic and predictable, making it inappropriate
   21|       |/// for cryptographic purposes or safety-critical random number generation.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.24 - The random number generator functions
   24|       |/// of <stdlib.h> shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int x = rand();  // Warning: rand() usage
   29|       |///   srand(time(0));  // Warning: srand() usage
   30|       |/// \endcode
   31|       |class AvoidStdlibRandCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidStdlibRandCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidStdlibRandCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for rand/srand calls.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched rand/srand calls and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBRANDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidSignalHeaderCheck.h:
    1|       |//===--- AvoidSignalHeaderCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNALHEADERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNALHEADERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of signal handling functions from signal.h header.
   17|       |///
   18|       |/// Signal handlers introduce asynchronous control flow and have severe
   19|       |/// restrictions on what can be safely executed within them. They can lead
   20|       |/// to undefined behavior, race conditions, and are difficult to test and
   21|       |/// verify, making them unsuitable for safety-critical systems.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.5 - The standard header file <signal.h>
   24|       |/// shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   #include <signal.h>  // Warning: signal.h usage
   29|       |///   signal(SIGINT, handler);  // Warning: signal() usage
   30|       |/// \endcode
   31|       |class AvoidSignalHeaderCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidSignalHeaderCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidSignalHeaderCheck() override = default;
   41|       |
   42|       |  /// Registers preprocessor callbacks for signal.h inclusion.
   43|       |  /// \param SM The source manager.
   44|       |  /// \param PP The preprocessor instance.
   45|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   46|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   47|       |                           Preprocessor *ModuleExpanderPP) override;
   48|       |
   49|       |  /// Registers AST matchers for signal function calls.
   50|       |  /// \param Finder The match finder to register matchers with.
   51|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   52|       |
   53|       |  /// Handles matched signal calls and emits diagnostics.
   54|       |  /// \param Result The match result containing the matched AST node.
   55|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   56|       |};
   57|       |
   58|       |} // namespace clang::tidy::automotive
   59|       |
   60|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNALHEADERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidSignalHeaderCheck.cpp:
    1|       |//===--- AvoidSignalHeaderCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSignalHeaderCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |namespace clang::tidy::automotive {
   14|       |
   15|       |using namespace clang::ast_matchers;
   16|       |
   17|       |static const StringRef ForbiddenFunctionNames[] = {
   18|       |    "bsd_signal",  "kill",       "killpg",    "pthread_kill", "pthread_sigmask",
   19|       |    "raise",       "sigaction",  "sigaddset", "sigaltstack",  "sigdelset",
   20|       |    "sigemptyset", "sigfillset", "sighold",   "sigignore",    "siginterrupt",
   21|       |    "sigismember", "signal",     "sigpause",  "sigpending",   "sigprocmask",
   22|       |    "sigqueue",    "sigrelse",   "sigset",    "sigsuspend",   "sigtimedwait",
   23|       |    "sigwait",     "sigwaitinfo"};
   24|       |
   25|       |void AvoidSignalHeaderCheck::registerPPCallbacks(
   26|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   27|       |  // TODO: Add preprocessor support for the forbidden functions.
   28|       |  //  PP->addPPCallbacks(std::make_unique<AvoidApiPPCallbacks>(
   29|       |  //      *this, *PP, "signal.h", ForbiddenFunctionNames));
   30|    131|}
   31|       |
   32|    131|void AvoidSignalHeaderCheck::registerMatchers(MatchFinder *Finder) {
   33|    131|  Finder->addMatcher(
   34|    131|      callExpr(callee(functionDecl(hasAnyName(ForbiddenFunctionNames))))
   35|    131|          .bind("forbiddenFunctionCall"),
   36|    131|      this);
   37|    131|}
   38|       |
   39|     21|void AvoidSignalHeaderCheck::check(const MatchFinder::MatchResult &Result) {
   40|     21|  if (const auto *Call =
  ------------------
  |  Branch (40:19): [True: 21, False: 0]
  ------------------
   41|     21|          Result.Nodes.getNodeAs<CallExpr>("forbiddenFunctionCall")) {
   42|     21|    const FunctionDecl *Func = Call->getDirectCallee();
   43|     21|    if (Func) {
  ------------------
  |  Branch (43:9): [True: 21, False: 0]
  ------------------
   44|     21|      diag(Call->getBeginLoc(), "Avoid function '%0' from <signal.h>")
   45|     21|          << Func->getName();
   46|     21|    }
   47|     21|  }
   48|     21|}
   49|       |
   50|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/ExitCheck.h:
    1|       |//===--- ExitCheck.h - clang-tidy ------------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXITCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXITCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of exit(), abort(), and _Exit() functions.
   17|       |///
   18|       |/// These functions cause abrupt program termination without returning to
   19|       |/// the caller, bypassing normal cleanup and resource deallocation. In
   20|       |/// safety-critical and embedded systems, controlled shutdown is essential,
   21|       |/// and abrupt termination can leave the system in an undefined state.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.8 - The library functions abort, exit,
   24|       |/// and _Exit shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   exit(1);    // Warning: exit() usage
   29|       |///   abort();    // Warning: abort() usage
   30|       |/// \endcode
   31|       |class ExitCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  ExitCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~ExitCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for exit/abort calls.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched exit/abort calls and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXITCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidStdlibMemoryCheck.h:
    1|       |//===--- AvoidStdlibMemoryCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBMEMORYCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBMEMORYCHECK_H
   11|       |
   12|       |#include "AvoidApiCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-stdlib
   17|       |/// @brief Detects usage of dynamic memory allocation functions from stdlib.h.
   18|       |///
   19|       |/// Dynamic memory allocation (malloc, calloc, realloc, free) can lead to
   20|       |/// memory leaks, fragmentation, and allocation failures that are difficult
   21|       |/// to handle. In safety-critical systems, static memory allocation is
   22|       |/// preferred for predictable behavior and deterministic execution.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 21.3
   25|       |/// The memory allocation and deallocation functions of <stdlib.h> shall not
   26|       |/// be used.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// \code
   31|       |///   int *p = malloc(sizeof(int));  // Warning: malloc usage
   32|       |///   free(p);                       // Warning: free usage
   33|       |/// \endcode
   34|       |class AvoidStdlibMemoryCheck : public AvoidApiCheck {
   35|       |public:
   36|       |  /// Constructs the check with the given name and context.
   37|       |  /// \param Name The name of the check as registered.
   38|       |  /// \param Context The clang-tidy context for configuration.
   39|       |  AvoidStdlibMemoryCheck(StringRef Name, ClangTidyContext *Context)
   40|    131|      : AvoidApiCheck(
   41|    131|            Name, Context, "pelle.h",
   42|    131|            {"calloc", "malloc", "realloc", "aligned_alloc", "free"}) {}
   43|       |
   44|       |  /// Destructor.
   45|    131|  ~AvoidStdlibMemoryCheck() override = default;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDLIBMEMORYCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidStdargHeaderCheck.h:
    1|       |//===--- AvoidStdargHeaderCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDARGHEADERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDARGHEADERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of variable argument facilities from stdarg.h header.
   17|       |///
   18|       |/// Variable argument functions (va_list, va_start, va_arg, va_end) bypass
   19|       |/// type safety and make it impossible for the compiler to verify correct
   20|       |/// argument types and counts. This can lead to undefined behavior and
   21|       |/// security vulnerabilities. Fixed-argument functions are type-safe and
   22|       |/// more reliable.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 17.1 - The features of <stdarg.h> shall not
   25|       |/// be used.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   #include <stdarg.h>  // Warning: stdarg.h usage
   30|       |/// \endcode
   31|       |class AvoidStdargHeaderCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidStdargHeaderCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidStdargHeaderCheck() override = default;
   41|       |
   42|       |  /// Registers preprocessor callbacks for stdarg.h inclusion.
   43|       |  /// \param SM The source manager.
   44|       |  /// \param PP The preprocessor instance.
   45|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   46|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   47|       |                           Preprocessor *ModuleExpanderPP) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTDARGHEADERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidStdargHeaderCheck.cpp:
    1|       |//===--- AvoidStdargHeaderCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidStdargHeaderCheck.h"
   10|       |
   11|       |namespace clang::tidy::automotive {
   12|       |
   13|       |void AvoidStdargHeaderCheck::registerPPCallbacks(
   14|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   15|       |  // Header inclusion detection not yet implemented
   16|    131|}
   17|       |
   18|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AtoXCheck.cpp:
    1|       |//===--- AtoXCheck.cpp - clang-tidy --------------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AtoXCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AtoXCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(callExpr(callee(functionDecl(
   19|    131|                                  hasAnyName("atof", "atoi", "atol", "atoll"))))
   20|    131|                         .bind("func"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|      4|void AtoXCheck::check(const MatchFinder::MatchResult &Result) {
   25|      4|  const auto *MatchedCall = Result.Nodes.getNodeAs<CallExpr>("func");
   26|      4|  if (MatchedCall) {
  ------------------
  |  Branch (26:7): [True: 4, False: 0]
  ------------------
   27|      4|    diag(MatchedCall->getBeginLoc(),
   28|      4|         "Avoid function '%0' that has undefined behavior")
   29|      4|        << MatchedCall->getDirectCallee()->getNameAsString();
   30|      4|  }
   31|      4|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AvoidStdlibRandCheck.cpp:
    1|       |//===--- AvoidStdlibRandCheck.h.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidStdlibRandCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidStdlibRandCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      callExpr(callee(functionDecl(hasName("rand")))).bind("func"), this);
   20|    131|}
   21|       |
   22|      2|void AvoidStdlibRandCheck::check(const MatchFinder::MatchResult &Result) {
   23|      2|  const auto *MatchedCall = Result.Nodes.getNodeAs<CallExpr>("func");
   24|      2|  if (MatchedCall) {
  ------------------
  |  Branch (24:7): [True: 2, False: 0]
  ------------------
   25|      2|    diag(MatchedCall->getBeginLoc(), "Avoid '%0' call from stdlib")
   26|      2|        << MatchedCall->getDirectCallee()->getNameAsString();
   27|      2|  }
   28|      2|}
   29|       |
   30|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/StdlibComponent.cpp:
    1|       |//===--- StdlibComponent.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "StdlibComponent.h"
   10|       |#include "AtoXCheck.h"
   11|       |#include "AvoidSetjmpHeaderCheck.h"
   12|       |#include "AvoidSignalHeaderCheck.h"
   13|       |#include "AvoidStdargHeaderCheck.h"
   14|       |#include "AvoidStdlibMemoryCheck.h"
   15|       |#include "AvoidStdlibRandCheck.h"
   16|       |#include "AvoidstdlibsystemcallCheck.h"
   17|       |#include "ExitCheck.h"
   18|       |
   19|       |namespace clang::tidy::automotive {
   20|       |
   21|       |void StdlibComponent::addCheckFactories(
   22|    262|    ClangTidyCheckFactories &CheckFactories) {
   23|       |
   24|    262|  CheckFactories.registerCheck<AvoidStdargHeaderCheck>(
   25|    262|      "automotive-avoid-stdarg-header");
   26|    262|  CheckFactories.registerCheck<AvoidSetjmpHeaderCheck>(
   27|    262|      "automotive-avoid-setjmp-header");
   28|    262|  CheckFactories.registerCheck<AvoidSignalHeaderCheck>(
   29|    262|      "automotive-avoid-signal-header");
   30|    262|  CheckFactories.registerCheck<AtoXCheck>("automotive-avoid-ascii-to-number");
   31|    262|  CheckFactories.registerCheck<ExitCheck>("automotive-avoid-stdlib-exit");
   32|       |
   33|    262|  CheckFactories.registerCheck<AvoidstdlibsystemcallCheck>(
   34|    262|      "automotive-avoid-stdlib-system");
   35|    262|  CheckFactories.registerCheck<AvoidStdlibRandCheck>(
   36|    262|      "automotive-avoid-stdlib-rand");
   37|       |
   38|       |  // Rule 21.3 / Dir 4.12 - Dynamic memory allocation (Required)
   39|    262|  CheckFactories.registerCheck<AvoidStdlibMemoryCheck>(
   40|    262|      "automotive-c23-req-21.3");
   41|    262|}
   42|       |
   43|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/stdlib/AtoXCheck.h:
    1|       |//===--- AtoXCheck.h - clang-tidy ------------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ATOXCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ATOXCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of atoi(), atof(), and atol() string conversion functions.
   17|       |///
   18|       |/// The atoi family of functions has undefined behavior on conversion errors,
   19|       |/// provides no error reporting mechanism, and cannot distinguish between
   20|       |/// a valid result of 0 and a conversion failure. The strtol/strtod family
   21|       |/// should be used instead as they provide proper error handling.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 21.7 - The atof, atoi, atol and atoll functions
   24|       |/// of <stdlib.h> shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int x = atoi("123");    // Warning: atoi() usage
   29|       |///   double y = atof("1.5"); // Warning: atof() usage
   30|       |/// \endcode
   31|       |class AtoXCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AtoXCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AtoXCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for atoi/atof/atol calls.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched conversion function calls and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ATOXCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/DuplicateTypedefNameCheck.cpp:
    1|       |//===--- DuplicateTypedefNameCheck.cpp - clang-tidy ----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "DuplicateTypedefNameCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void DuplicateTypedefNameCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(typedefDecl().bind("typedef"), this);
   18|    131|}
   19|       |
   20|  4.51k|void DuplicateTypedefNameCheck::check(const MatchFinder::MatchResult &Result) {
   21|  4.51k|  const auto *MatchedDecl = Result.Nodes.getNodeAs<TypedefDecl>("typedef");
   22|  4.51k|  if (!MatchedDecl || MatchedDecl->isImplicit())
  ------------------
  |  Branch (22:7): [True: 0, False: 4.51k]
  |  Branch (22:23): [True: 655, False: 3.86k]
  ------------------
   23|    655|    return;
   24|       |
   25|  3.86k|  StringRef TypedefName = MatchedDecl->getName();
   26|  3.86k|  auto It = SeenTypedefs.find(TypedefName);
   27|       |
   28|  3.86k|  if (It != SeenTypedefs.end()) {
  ------------------
  |  Branch (28:7): [True: 1.44k, False: 2.41k]
  ------------------
   29|  1.44k|    const TypedefDecl *FirstDecl = It->second;
   30|  1.44k|    diag(MatchedDecl->getLocation(),
   31|  1.44k|         "duplicate typedef name '%0', previously declared")
   32|  1.44k|        << TypedefName;
   33|  1.44k|    diag(FirstDecl->getLocation(), "previous declaration is here",
   34|  1.44k|         DiagnosticIDs::Note);
   35|  2.41k|  } else {
   36|  2.41k|    SeenTypedefs[TypedefName] = MatchedDecl;
   37|  2.41k|  }
   38|  3.86k|}
   39|       |
   40|    131|void DuplicateTypedefNameCheck::onEndOfTranslationUnit() {
   41|       |  // Clear the map for the next translation unit
   42|    131|  SeenTypedefs.clear();
   43|    131|}
   44|       |
   45|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/UniqueEnumValuesCheck.h:
    1|       |//===--- UniqueEnumValuesCheck.h - clang-tidy -------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNIQUEENUMVALUESCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNIQUEENUMVALUESCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects duplicate values in enumeration constants.
   17|       |///
   18|       |/// Each enumerator in an enumeration should have a unique value. Duplicate
   19|       |/// values can make the code confusing and error-prone, as multiple enum
   20|       |/// constants evaluate to the same value, which defeats the purpose of using
   21|       |/// named constants and can lead to logic errors in switch statements.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 9.5 - Each enumerator within an enumeration
   24|       |/// shall have a unique value.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   enum Status {
   29|       |///     OK = 0,
   30|       |///     SUCCESS = 0  // Warning: duplicate value
   31|       |///   };
   32|       |/// \endcode
   33|       |class UniqueEnumValuesCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  UniqueEnumValuesCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~UniqueEnumValuesCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for enum declarations.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched enumerations and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNIQUEENUMVALUESCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/UniqueEnumValuesCheck.cpp:
    1|       |//===--- UniqueEnumValuesCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UniqueEnumValuesCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UniqueEnumValuesCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(enumDecl().bind("enum"), this);
   18|    131|}
   19|       |
   20|    201|void UniqueEnumValuesCheck::check(const MatchFinder::MatchResult &Result) {
   21|    201|  const auto *MatchedEnum = Result.Nodes.getNodeAs<EnumDecl>("enum");
   22|    201|  if (!MatchedEnum)
  ------------------
  |  Branch (22:7): [True: 0, False: 201]
  ------------------
   23|      0|    return;
   24|       |
   25|    201|  llvm::DenseMap<int64_t, const EnumConstantDecl *> UsedValues;
   26|    201|  int64_t LastValue = -1;
   27|       |
   28|    346|  for (const auto *EnumConst : MatchedEnum->enumerators()) {
  ------------------
  |  Branch (28:30): [True: 346, False: 201]
  ------------------
   29|    346|    int64_t CurrentValue = EnumConst->getInitExpr()
  ------------------
  |  Branch (29:28): [True: 261, False: 85]
  ------------------
   30|    346|                               ? EnumConst->getInitVal().getSExtValue()
   31|    346|                               : LastValue + 1;
   32|       |
   33|    346|    auto It = UsedValues.find(CurrentValue);
   34|    346|    if (It != UsedValues.end()) {
  ------------------
  |  Branch (34:9): [True: 6, False: 340]
  ------------------
   35|      6|      const EnumConstantDecl *PreviousEnum = It->second;
   36|      6|      diag(EnumConst->getLocation(), "duplicate enum value '%0' from '%1'")
   37|      6|          << CurrentValue << PreviousEnum->getName();
   38|      6|      diag(PreviousEnum->getLocation(), "declaration of '%0'",
   39|      6|           DiagnosticIDs::Note)
   40|      6|          << PreviousEnum->getName();
   41|    340|    } else {
   42|    340|      UsedValues[CurrentValue] = EnumConst;
   43|    340|    }
   44|       |
   45|    346|    LastValue = CurrentValue;
   46|    346|  }
   47|    201|}
   48|       |
   49|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/UnusedTypeCheck.cpp:
    1|       |//===--- UnusedTypeCheck.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedTypeCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UnusedTypeCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(typedefDecl().bind("typedef"), this);
   18|    131|}
   19|       |
   20|  4.51k|void UnusedTypeCheck::check(const MatchFinder::MatchResult &Result) {
   21|  4.51k|  const auto *MatchedDecl = Result.Nodes.getNodeAs<TypedefDecl>("typedef");
   22|       |
   23|  4.51k|  if (!MatchedDecl) {
  ------------------
  |  Branch (23:7): [True: 0, False: 4.51k]
  ------------------
   24|      0|    return;
   25|      0|  }
   26|       |
   27|  4.51k|  if (MatchedDecl->isImplicit()) {
  ------------------
  |  Branch (27:7): [True: 655, False: 3.86k]
  ------------------
   28|    655|    return;
   29|    655|  }
   30|       |
   31|  3.86k|  if (MatchedDecl->getMostRecentDecl()->isReferenced()) {
  ------------------
  |  Branch (31:7): [True: 1.43k, False: 2.42k]
  ------------------
   32|  1.43k|    return;
   33|  1.43k|  }
   34|       |
   35|  2.42k|  diag(MatchedDecl->getLocation(), "unused type declaration '%0'")
   36|  2.42k|      << MatchedDecl->getName();
   37|  2.42k|}
   38|       |
   39|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/ExplicitEnumeratorValuesCheck.cpp:
    1|       |//===--- ExplicitEnumeratorValuesCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ExplicitEnumeratorValuesCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void ExplicitEnumeratorValuesCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(enumDecl().bind("enum"), this);
   19|    131|}
   20|       |
   21|       |void ExplicitEnumeratorValuesCheck::check(
   22|    201|    const MatchFinder::MatchResult &Result) {
   23|    201|  const auto *ED = Result.Nodes.getNodeAs<EnumDecl>("enum");
   24|    201|  if (!ED)
  ------------------
  |  Branch (24:7): [True: 0, False: 201]
  ------------------
   25|      0|    return;
   26|       |
   27|       |  // Skip system headers
   28|    201|  if (Result.SourceManager->isInSystemHeader(ED->getLocation()))
  ------------------
  |  Branch (28:7): [True: 139, False: 62]
  ------------------
   29|    139|    return;
   30|       |
   31|       |  // Skip forward declarations
   32|     62|  if (!ED->isCompleteDefinition())
  ------------------
  |  Branch (32:7): [True: 1, False: 61]
  ------------------
   33|      1|    return;
   34|       |
   35|       |  // Check each enumerator for an explicit initializer
   36|    184|  for (const auto *Enumerator : ED->enumerators()) {
  ------------------
  |  Branch (36:31): [True: 184, False: 61]
  ------------------
   37|       |    // getInitExpr() returns null if no explicit initializer was provided
   38|    184|    if (!Enumerator->getInitExpr()) {
  ------------------
  |  Branch (38:9): [True: 85, False: 99]
  ------------------
   39|     85|      diag(Enumerator->getLocation(),
   40|     85|           "enumerator %0 has implicit value; each enumerator should have an "
   41|     85|           "explicit value")
   42|     85|          << Enumerator;
   43|     85|    }
   44|    184|  }
   45|     61|}
   46|       |
   47|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/AvoidPointerTypedefCheck.cpp:
    1|       |//===--- AvoidPointerTypedefCheck.cpp - clang-tidy ------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidPointerTypedefCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidPointerTypedefCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match typedef declarations
   19|    131|  Finder->addMatcher(typedefDecl().bind("typedef"), this);
   20|       |
   21|       |  // Also match type alias declarations (C++11 using)
   22|    131|  Finder->addMatcher(typeAliasDecl().bind("alias"), this);
   23|    131|}
   24|       |
   25|  5.68k|void AvoidPointerTypedefCheck::check(const MatchFinder::MatchResult &Result) {
   26|       |  // Check typedef declarations
   27|  5.68k|  if (const auto *TD = Result.Nodes.getNodeAs<TypedefDecl>("typedef")) {
  ------------------
  |  Branch (27:19): [True: 4.51k, False: 1.16k]
  ------------------
   28|  4.51k|    checkTypedefDecl(TD, *Result.SourceManager);
   29|  4.51k|    return;
   30|  4.51k|  }
   31|       |
   32|       |  // Check type alias declarations
   33|  1.16k|  if (const auto *TAD = Result.Nodes.getNodeAs<TypeAliasDecl>("alias"))
  ------------------
  |  Branch (33:19): [True: 1.16k, False: 0]
  ------------------
   34|  1.16k|    checkTypeAliasDecl(TAD, *Result.SourceManager);
   35|  1.16k|}
   36|       |
   37|       |void AvoidPointerTypedefCheck::checkTypedefDecl(const TypedefDecl *TD,
   38|  4.51k|                                                const SourceManager &SM) {
   39|       |  // Skip built-in types and system headers
   40|  4.51k|  if (!TD->getLocation().isValid() || SM.isInSystemHeader(TD->getLocation()))
  ------------------
  |  Branch (40:7): [True: 655, False: 3.86k]
  |  Branch (40:7): [True: 4.42k, False: 94]
  |  Branch (40:39): [True: 3.76k, False: 94]
  ------------------
   41|  4.42k|    return;
   42|       |
   43|     94|  QualType UnderlyingType = TD->getUnderlyingType();
   44|     94|  if (!UnderlyingType->isPointerType())
  ------------------
  |  Branch (44:7): [True: 61, False: 33]
  ------------------
   45|     61|    return;
   46|       |
   47|       |  // Skip function pointers - these are commonly typedef'd and acceptable
   48|     33|  if (UnderlyingType->getPointeeType()->isFunctionType())
  ------------------
  |  Branch (48:7): [True: 16, False: 17]
  ------------------
   49|     16|    return;
   50|       |
   51|     17|  diag(TD->getLocation(),
   52|     17|       "typedef %0 hides pointer type; consider making the pointer "
   53|     17|       "explicit at point of use")
   54|     17|      << TD;
   55|     17|}
   56|       |
   57|       |void AvoidPointerTypedefCheck::checkTypeAliasDecl(const TypeAliasDecl *TAD,
   58|  1.16k|                                                  const SourceManager &SM) {
   59|       |  // Skip built-in types and system headers
   60|  1.16k|  if (!TAD->getLocation().isValid() || SM.isInSystemHeader(TAD->getLocation()))
  ------------------
  |  Branch (60:7): [True: 0, False: 1.16k]
  |  Branch (60:7): [True: 1.15k, False: 15]
  |  Branch (60:40): [True: 1.15k, False: 15]
  ------------------
   61|  1.15k|    return;
   62|       |
   63|     15|  QualType UnderlyingType = TAD->getUnderlyingType();
   64|     15|  if (!UnderlyingType->isPointerType())
  ------------------
  |  Branch (64:7): [True: 7, False: 8]
  ------------------
   65|      7|    return;
   66|       |
   67|       |  // Skip function pointers
   68|      8|  if (UnderlyingType->getPointeeType()->isFunctionType())
  ------------------
  |  Branch (68:7): [True: 3, False: 5]
  ------------------
   69|      3|    return;
   70|       |
   71|      5|  diag(TAD->getLocation(),
   72|      5|       "type alias %0 hides pointer type; consider making the pointer "
   73|      5|       "explicit at point of use")
   74|      5|      << TAD;
   75|      5|}
   76|       |
   77|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/AvoidPointerTypedefCheck.h:
    1|       |//===--- AvoidPointerTypedefCheck.h - clang-tidy ----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERTYPEDEFCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERTYPEDEFCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects pointer types hidden in typedefs.
   17|       |///
   18|       |/// MISRA C:2025 Dir 4.8 (Advisory) recommends that pointers should not be
   19|       |/// hidden in typedefs. This helps ensure that the pointer nature of a type
   20|       |/// is visible at the point of use, improving code clarity and reducing the
   21|       |/// risk of pointer-related errors.
   22|       |///
   23|       |/// Example of non-compliant code:
   24|       |/// \code
   25|       |///   typedef int* IntPtr;   // Pointer hidden in typedef
   26|       |///   IntPtr p = NULL;       // Not obvious that p is a pointer
   27|       |/// \endcode
   28|       |///
   29|       |/// Example of compliant code:
   30|       |/// \code
   31|       |///   typedef struct Data Data_t;
   32|       |///   Data_t *p = NULL;      // Pointer nature is explicit
   33|       |/// \endcode
   34|       |///
   35|       |/// Note: This check may have false positives for opaque handles that
   36|       |/// intentionally hide implementation details.
   37|       |class AvoidPointerTypedefCheck : public ClangTidyCheck {
   38|       |public:
   39|       |  /// Constructs the check with the given name and context.
   40|       |  AvoidPointerTypedefCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~AvoidPointerTypedefCheck() override = default;
   45|       |
   46|       |  /// Registers AST matchers for typedef declarations.
   47|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   48|       |
   49|       |  /// Handles matched typedefs and emits diagnostics.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |
   52|       |private:
   53|       |  /// Check a typedef declaration for hidden pointer.
   54|       |  void checkTypedefDecl(const TypedefDecl *TD, const SourceManager &SM);
   55|       |
   56|       |  /// Check a type alias declaration for hidden pointer.
   57|       |  void checkTypeAliasDecl(const TypeAliasDecl *TAD, const SourceManager &SM);
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERTYPEDEFCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/ImplicitIntCheck.cpp:
    1|       |//===--- ImplicitIntCheck.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ImplicitIntCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |#include "clang/Basic/AttrKinds.h"
   12|       |#include "clang/Basic/CharInfo.h"
   13|       |#include "clang/Basic/IdentifierTable.h"
   14|       |#include "clang/Basic/LangOptions.h"
   15|       |#include "clang/Basic/SourceManager.h"
   16|       |#include "clang/Basic/TargetInfo.h"
   17|       |#include "clang/Lex/Lexer.h"
   18|       |#include "llvm/ADT/STLExtras.h"
   19|       |
   20|       |using namespace clang::ast_matchers;
   21|       |
   22|       |namespace clang::tidy::automotive {
   23|       |
   24|    131|void ImplicitIntCheck::registerMatchers(MatchFinder *Finder) {
   25|    131|  Finder->addMatcher(varDecl().bind("var"), this);
   26|    131|  IdentTable = std::make_unique<IdentifierTable>(getLangOpts());
   27|    131|}
   28|       |
   29|  18.4k|void ImplicitIntCheck::check(const MatchFinder::MatchResult &Result) {
   30|  18.4k|  auto *MatchedVar = Result.Nodes.getNodeAs<VarDecl>("var");
   31|  18.4k|  if (!MatchedVar)
  ------------------
  |  Branch (31:7): [True: 0, False: 18.4k]
  ------------------
   32|      0|    return;
   33|       |
   34|  18.4k|  SourceLocation StartLoc = MatchedVar->getBeginLoc();
   35|  18.4k|  SourceLocation EndLoc = MatchedVar->getEndLoc();
   36|       |
   37|  18.4k|  checkImplicitInt(StartLoc, EndLoc, *Result.SourceManager, *Result.Context);
   38|  18.4k|}
   39|       |
   40|       |void ImplicitIntCheck::checkImplicitInt(SourceLocation StartLoc,
   41|       |                                        SourceLocation EndLoc,
   42|       |                                        const SourceManager &SM,
   43|  18.4k|                                        const ASTContext &Context) {
   44|       |  // Suppress unused parameter warnings for incomplete implementation.
   45|  18.4k|  (void)StartLoc;
   46|  18.4k|  (void)EndLoc;
   47|  18.4k|  (void)SM;
   48|  18.4k|  (void)Context;
   49|       |  // TODO: Implement implicit int detection
   50|  18.4k|}
   51|       |
   52|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/AvoidUnionCheck.cpp:
    1|       |//===--- AvoidUnionCheck.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidUnionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidUnionCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      recordDecl(isUnion(), hasDeclContext(translationUnitDecl()))
   20|    131|          .bind("union"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|     16|void AvoidUnionCheck::check(const MatchFinder::MatchResult &Result) {
   25|     16|  const auto *MatchedDecl = Result.Nodes.getNodeAs<RecordDecl>("union");
   26|       |
   27|     16|  if (MatchedDecl) {
  ------------------
  |  Branch (27:7): [True: 16, False: 0]
  ------------------
   28|     16|    diag(MatchedDecl->getBeginLoc(), "avoid union keyword");
   29|     16|  }
   30|     16|}
   31|       |
   32|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/DuplicateTagNameCheck.cpp:
    1|       |//===--- DuplicateTagNameCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "DuplicateTagNameCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "llvm/ADT/STLExtras.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |/// Returns the tag kind as a string ("struct", "union", or "enum").
   20|      6|StringRef getTagKindName(const TagDecl *Tag) {
   21|      6|  if (isa<EnumDecl>(Tag))
  ------------------
  |  Branch (21:7): [True: 0, False: 6]
  ------------------
   22|      0|    return "enum";
   23|      6|  if (const auto *RD = dyn_cast<RecordDecl>(Tag))
  ------------------
  |  Branch (23:19): [True: 6, False: 0]
  ------------------
   24|      6|    return RD->isUnion() ? "union" : "struct";
  ------------------
  |  Branch (24:12): [True: 0, False: 6]
  ------------------
   25|      0|  return "tag";
   26|      6|}
   27|       |} // namespace
   28|       |
   29|    131|void DuplicateTagNameCheck::registerMatchers(MatchFinder *Finder) {
   30|       |  // Match all tag declarations (struct, union, enum) that have a name
   31|       |  // Exclude implicit declarations and system headers
   32|    131|  Finder->addMatcher(
   33|    131|      tagDecl(unless(isImplicit()), unless(isExpansionInSystemHeader()))
   34|    131|          .bind("tag"),
   35|    131|      this);
   36|    131|}
   37|       |
   38|    234|void DuplicateTagNameCheck::check(const MatchFinder::MatchResult &Result) {
   39|    234|  const auto *Tag = Result.Nodes.getNodeAs<TagDecl>("tag");
   40|    234|  SM = Result.SourceManager;
   41|       |
   42|    234|  if (!Tag)
  ------------------
  |  Branch (42:7): [True: 0, False: 234]
  ------------------
   43|      0|    return;
   44|       |
   45|       |  // Skip anonymous tags (no name)
   46|    234|  if (Tag->getName().empty())
  ------------------
  |  Branch (46:7): [True: 28, False: 206]
  ------------------
   47|     28|    return;
   48|       |
   49|       |  // Skip if in system header (double check)
   50|    206|  if (SM->isInSystemHeader(Tag->getLocation()))
  ------------------
  |  Branch (50:7): [True: 0, False: 206]
  ------------------
   51|      0|    return;
   52|       |
   53|       |  // Get the canonical declaration to avoid counting forward declarations
   54|       |  // and definitions of the same tag as duplicates
   55|    206|  const TagDecl *CanonicalTag = Tag->getCanonicalDecl();
   56|       |
   57|       |  // Check if we've already seen this canonical declaration
   58|    206|  StringRef TagName = CanonicalTag->getName();
   59|    206|  auto &Decls = TagNames[TagName];
   60|       |
   61|       |  // Only add if we haven't seen this exact canonical declaration before
   62|    206|  if (llvm::find(Decls, CanonicalTag) == Decls.end())
  ------------------
  |  Branch (62:7): [True: 201, False: 5]
  ------------------
   63|    201|    Decls.push_back(CanonicalTag);
   64|    206|}
   65|       |
   66|    131|void DuplicateTagNameCheck::onEndOfTranslationUnit() {
   67|       |  // Check for duplicate tag names
   68|    198|  for (const auto &Entry : TagNames) {
  ------------------
  |  Branch (68:26): [True: 198, False: 131]
  ------------------
   69|    198|    const auto &Decls = Entry.getValue();
   70|       |
   71|       |    // If more than one canonical declaration uses this name, it's a duplicate
   72|    198|    if (Decls.size() > 1) {
  ------------------
  |  Branch (72:9): [True: 3, False: 195]
  ------------------
   73|       |      // Report the first duplicate and subsequent ones
   74|      6|      for (size_t i = 1; i < Decls.size(); ++i) {
  ------------------
  |  Branch (74:26): [True: 3, False: 3]
  ------------------
   75|      3|        const TagDecl *CurrentTag = Decls[i];
   76|      3|        const TagDecl *FirstTag = Decls[0];
   77|       |
   78|      3|        StringRef TagKind = getTagKindName(CurrentTag);
   79|      3|        StringRef FirstTagKind = getTagKindName(FirstTag);
   80|       |
   81|      3|        diag(CurrentTag->getLocation(),
   82|      3|             "duplicate tag name '%0'; %1 '%0' conflicts with %2 declared here")
   83|      3|            << Entry.getKey() << TagKind << FirstTagKind;
   84|      3|        diag(FirstTag->getLocation(), "previous declaration of %0 '%1' is here",
   85|      3|             DiagnosticIDs::Note)
   86|      3|            << FirstTagKind << Entry.getKey();
   87|      3|      }
   88|      3|    }
   89|    198|  }
   90|       |
   91|       |  // Clear for next TU
   92|    131|  TagNames.clear();
   93|    131|}
   94|       |
   95|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/UnusedTypeCheck.h:
    1|       |//===--- UnusedTypeCheck.h - clang-tidy -------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTYPECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTYPECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects type declarations that are never used.
   17|       |///
   18|       |/// Type definitions that are declared but never used represent dead code
   19|       |/// that clutters the codebase and should be removed. Unused types make the
   20|       |/// code harder to maintain and understand, and may indicate incomplete
   21|       |/// refactoring or obsolete code.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 2.4 - A project should not contain unused
   24|       |/// type declarations.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   typedef struct { int x; } UnusedStruct;  // Warning: type never used
   29|       |/// \endcode
   30|       |class UnusedTypeCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  UnusedTypeCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~UnusedTypeCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for type declarations.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched type declarations and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTYPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/DuplicateTypedefNameCheck.h:
    1|       |//===--- DuplicateTypedefNameCheck.h - clang-tidy --------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETYPEDEFNAMECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETYPEDEFNAMECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "llvm/ADT/DenseMap.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Detects duplicate typedef names within a translation unit.
   18|       |///
   19|       |/// A typedef name shall be a unique identifier. Using the same name for
   20|       |/// multiple typedef declarations makes the code confusing and can lead to
   21|       |/// maintenance issues. Even if the typedefs resolve to the same underlying
   22|       |/// type, having duplicate names reduces code clarity and may indicate
   23|       |/// design issues.
   24|       |///
   25|       |/// Related MISRA C:2023 Rule: 5.6 - A typedef name shall be a unique
   26|       |/// identifier.
   27|       |///
   28|       |/// Example:
   29|       |/// \code
   30|       |///   typedef int MyInt;
   31|       |///   typedef float MyInt;  // Warning: duplicate typedef name 'MyInt'
   32|       |/// \endcode
   33|       |class DuplicateTypedefNameCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  DuplicateTypedefNameCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~DuplicateTypedefNameCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for typedef declarations.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched typedef declarations and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |
   52|       |  /// Called at the end of the translation unit to detect duplicates.
   53|       |  void onEndOfTranslationUnit() override;
   54|       |
   55|       |private:
   56|       |  /// Map to track typedef names and their first declaration location
   57|       |  llvm::DenseMap<llvm::StringRef, const TypedefDecl *> SeenTypedefs;
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETYPEDEFNAMECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/AvoidUnionCheck.h:
    1|       |//===--- AvoidUnionCheck.h - clang-tidy -------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of union types.
   17|       |///
   18|       |/// Unions allow storing different types in the same memory location, which
   19|       |/// can lead to type safety violations and undefined behavior if the wrong
   20|       |/// member is accessed. Unions make it difficult to determine which member
   21|       |/// is currently valid and can cause portability issues due to implementation-
   22|       |/// defined padding and alignment.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 19.2 - The union keyword should not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   union Data {  // Warning: union used
   29|       |///     int i;
   30|       |///     float f;
   31|       |///   };
   32|       |/// \endcode
   33|       |class AvoidUnionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  AvoidUnionCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidUnionCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for union declarations.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched unions and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/ExplicitEnumeratorValuesCheck.h:
    1|       |//===--- ExplicitEnumeratorValuesCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXPLICITENUMERATORVALUESCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXPLICITENUMERATORVALUESCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects enumeration constants without explicit values.
   17|       |///
   18|       |/// MISRA C:2025 Rule 9.2 requires that each enumerator within an enumeration
   19|       |/// shall have an explicit value specified. Implicit values rely on
   20|       |/// compiler-defined behavior and can lead to unexpected results if the enum
   21|       |/// is modified.
   22|       |///
   23|       |/// Example of non-compliant code:
   24|       |/// \code
   25|       |///   enum Color {
   26|       |///     RED,      // Implicit value 0
   27|       |///     GREEN,    // Implicit value 1
   28|       |///     BLUE      // Implicit value 2
   29|       |///   };
   30|       |/// \endcode
   31|       |///
   32|       |/// Example of compliant code:
   33|       |/// \code
   34|       |///   enum Color {
   35|       |///     RED = 0,
   36|       |///     GREEN = 1,
   37|       |///     BLUE = 2
   38|       |///   };
   39|       |/// \endcode
   40|       |class ExplicitEnumeratorValuesCheck : public ClangTidyCheck {
   41|       |public:
   42|       |  /// Constructs the check with the given name and context.
   43|       |  ExplicitEnumeratorValuesCheck(StringRef Name, ClangTidyContext *Context)
   44|    131|      : ClangTidyCheck(Name, Context) {}
   45|       |
   46|       |  /// Destructor.
   47|    131|  ~ExplicitEnumeratorValuesCheck() override = default;
   48|       |
   49|       |  /// Registers AST matchers for enum declarations.
   50|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   51|       |
   52|       |  /// Handles matched enumerations and emits diagnostics.
   53|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   54|       |};
   55|       |
   56|       |} // namespace clang::tidy::automotive
   57|       |
   58|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_EXPLICITENUMERATORVALUESCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/TypeComponent.cpp:
    1|       |//===--- TypeComponent.cpp - clang-tidy -----------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "TypeComponent.h"
   10|       |#include "AvoidPointerTypedefCheck.h"
   11|       |#include "AvoidUnionCheck.h"
   12|       |#include "DuplicateTagNameCheck.h"
   13|       |#include "DuplicateTypedefNameCheck.h"
   14|       |#include "ExplicitEnumeratorValuesCheck.h"
   15|       |#include "ImplicitIntCheck.h"
   16|       |#include "UniqueEnumValuesCheck.h"
   17|       |#include "UnusedTypeCheck.h"
   18|       |
   19|       |namespace clang::tidy::automotive {
   20|       |
   21|    262|void TypeComponent::addCheckFactories(ClangTidyCheckFactories &CheckFactories) {
   22|       |
   23|    262|  CheckFactories.registerCheck<AvoidUnionCheck>("automotive-avoid-union");
   24|    262|  CheckFactories.registerCheck<DuplicateTagNameCheck>("automotive-c23-req-5.7");
   25|    262|  CheckFactories.registerCheck<DuplicateTypedefNameCheck>(
   26|    262|      "automotive-c23-req-5.6");
   27|    262|  CheckFactories.registerCheck<ImplicitIntCheck>("automotive-implicit-int");
   28|    262|  CheckFactories.registerCheck<UniqueEnumValuesCheck>(
   29|    262|      "automotive-unique-enum-value");
   30|    262|  CheckFactories.registerCheck<UnusedTypeCheck>("automotive-unused-type");
   31|       |
   32|       |  // Rule 9.2 - Explicit enumerator values (Required)
   33|    262|  CheckFactories.registerCheck<ExplicitEnumeratorValuesCheck>(
   34|    262|      "automotive-c23-req-9.2");
   35|       |
   36|       |  // Dir 4.8 - Pointer hiding in typedefs (Advisory)
   37|    262|  CheckFactories.registerCheck<AvoidPointerTypedefCheck>(
   38|    262|      "automotive-c23-adv-dir-4.8");
   39|    262|}
   40|       |
   41|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/type/ImplicitIntCheck.h:
    1|       |//===--- ImplicitIntCheck.h - clang-tidy ------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITINTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITINTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects declarations that implicitly use the int type.
   17|       |///
   18|       |/// In older C standards, omitting a type specifier defaults to int. This
   19|       |/// implicit typing is error-prone and makes code less readable. All
   20|       |/// declarations should explicitly specify their type to improve clarity
   21|       |/// and prevent misunderstandings about the intended type.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 8.1 - Types shall be explicitly specified.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   const x = 5;        // Warning: implicit int
   28|       |///   unsigned y = 10;    // Warning: implicit int (unsigned int intended)
   29|       |/// \endcode
   30|       |class ImplicitIntCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  ImplicitIntCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~ImplicitIntCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for variable and function declarations.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched declarations and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |
   49|       |private:
   50|       |  /// Checks source range for implicit int usage.
   51|       |  /// \param StartLoc The starting location to check.
   52|       |  /// \param EndLoc The ending location to check.
   53|       |  /// \param SM The source manager.
   54|       |  /// \param Context The AST context.
   55|       |  void checkImplicitInt(SourceLocation StartLoc, SourceLocation EndLoc,
   56|       |                        const SourceManager &SM, const ASTContext &Context);
   57|       |
   58|       |  std::unique_ptr<IdentifierTable> IdentTable;
   59|       |};
   60|       |
   61|       |} // namespace clang::tidy::automotive
   62|       |
   63|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITINTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/type/DuplicateTagNameCheck.h:
    1|       |//===--- DuplicateTagNameCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETAGNAMECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETAGNAMECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "llvm/ADT/DenseMap.h"
   14|       |#include "llvm/ADT/StringMap.h"
   15|       |#include <vector>
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |/// Detects duplicate tag names (struct, union, enum) in a translation unit.
   20|       |///
   21|       |/// A tag name shall be a unique identifier within the translation unit.
   22|       |/// Using the same tag name for different struct, union, or enum types creates
   23|       |/// confusion and violates the principle that identifiers should have unique
   24|       |/// meanings. This check ensures that each tag name is used only once.
   25|       |///
   26|       |/// Related MISRA C:2023 Rule 5.7 - A tag name shall be a unique identifier.
   27|       |///
   28|       |/// Example:
   29|       |/// \code
   30|       |///   struct Point { int x, y; };
   31|       |///   enum Point { RED, GREEN };  // Warning: duplicate tag name 'Point'
   32|       |/// \endcode
   33|       |class DuplicateTagNameCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  DuplicateTagNameCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~DuplicateTagNameCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for tag declarations.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched tag declarations and tracks them.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |
   52|       |  /// Reports duplicate tag names at the end of translation unit processing.
   53|       |  void onEndOfTranslationUnit() override;
   54|       |
   55|       |private:
   56|       |  /// Maps tag names to the list of declarations using that name
   57|       |  llvm::StringMap<std::vector<const TagDecl *>> TagNames;
   58|       |  /// Source manager pointer for end-of-TU reporting
   59|       |  const SourceManager *SM = nullptr;
   60|       |};
   61|       |
   62|       |} // namespace clang::tidy::automotive
   63|       |
   64|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_DUPLICATETAGNAMECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidInappropriateEssentialTypeCheck.h:
    1|       |//===--- AvoidInappropriateEssentialTypeCheck.h - clang-tidy ----*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATEESSENTIALTYPECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATEESSENTIALTYPECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects inappropriate essential type mixing in operations.
   18|       |///
   19|       |/// Implements MISRA Rule 10.1: Operands shall not be of an inappropriate
   20|       |/// essential type. This check enforces the Essential Type Model which
   21|       |/// categorizes types into Boolean, Character, Signed, Unsigned, Floating,
   22|       |/// and Enum, and detects inappropriate mixing of these categories.
   23|       |///
   24|       |/// @par MISRA C:2023 Rule 10.1
   25|       |/// Operands shall not be of an inappropriate essential type.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Common violations detected:
   29|       |/// - Boolean types used in arithmetic operations
   30|       |/// - Character types used in arithmetic expressions (not as character data)
   31|       |/// - Inappropriate mixing of essential type categories
   32|       |///
   33|       |/// Example:
   34|       |/// @code
   35|       |///   bool b = true;
   36|       |///   int x = b + 1;         // Warning: boolean in arithmetic
   37|       |///   char c = 'A';
   38|       |///   int y = c * 2;         // Warning: character in arithmetic
   39|       |///   unsigned u = 1;
   40|       |///   int z = u + b;         // Warning: boolean in arithmetic
   41|       |/// @endcode
   42|       |class AvoidInappropriateEssentialTypeCheck : public ClangTidyCheck {
   43|       |public:
   44|       |  AvoidInappropriateEssentialTypeCheck(StringRef Name,
   45|       |                                       ClangTidyContext *Context)
   46|    131|      : ClangTidyCheck(Name, Context) {}
   47|       |
   48|       |  /// Destructor.
   49|    131|  ~AvoidInappropriateEssentialTypeCheck() override = default;
   50|       |
   51|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   52|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   53|       |
   54|       |private:
   55|       |  /// Essential type categories based on MISRA Essential Type Model
   56|       |  enum class EssentialType {
   57|       |    Boolean,
   58|       |    Character,
   59|       |    SignedInt,
   60|       |    UnsignedInt,
   61|       |    FloatingPoint,
   62|       |    Enum,
   63|       |    Other
   64|       |  };
   65|       |
   66|       |  /// Determine the essential type category of a QualType
   67|       |  EssentialType getEssentialType(QualType Type) const;
   68|       |
   69|       |  /// Check if a type is appropriate for arithmetic operations
   70|       |  bool isAppropriateForArithmetic(EssentialType ET) const;
   71|       |
   72|       |  /// Check if a type is appropriate for bitwise operations
   73|       |  bool isAppropriateForBitwise(EssentialType ET) const;
   74|       |
   75|       |  /// Get a human-readable name for an essential type
   76|       |  StringRef getEssentialTypeName(EssentialType ET) const;
   77|       |
   78|       |  /// Handle binary operator checking
   79|       |  void handleBinaryOperator(const BinaryOperator *BinOp,
   80|       |                            const SourceManager &SM);
   81|       |
   82|       |  /// Handle unary operator checking
   83|       |  void handleUnaryOperator(const UnaryOperator *UnOp, const SourceManager &SM);
   84|       |
   85|       |  /// Check and report inappropriate arithmetic operand
   86|       |  void checkArithmeticOperand(const Expr *Operand, EssentialType ET);
   87|       |
   88|       |  /// Check and report inappropriate bitwise operand
   89|       |  void checkBitwiseOperand(const Expr *Operand, EssentialType ET);
   90|       |};
   91|       |
   92|       |} // namespace clang::tidy::automotive
   93|       |
   94|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATEESSENTIALTYPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInSizeofCheck.h:
    1|       |//===--- AvoidSideEffectInSizeofCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINSIZEOFCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINSIZEOFCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects sizeof operands with potential side effects.
   18|       |///
   19|       |/// The operand of the sizeof operator shall not contain any expression which
   20|       |/// has potential side effects. Since sizeof typically evaluates at compile
   21|       |/// time, any side effects in its operand would not be executed, which could
   22|       |/// lead to unexpected behavior.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 13.6
   25|       |/// The operand of the sizeof operator shall not contain any expression which
   26|       |/// has potential side effects.
   27|       |/// @par Category: Mandatory
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   int x = 0;
   32|       |///   size_t s1 = sizeof(x++);     // Warning: side effect in sizeof
   33|       |///   size_t s2 = sizeof(func());  // Warning: function call in sizeof
   34|       |///   size_t s3 = sizeof(int);     // Compliant: type operand
   35|       |///   size_t s4 = sizeof(x);       // Compliant: no side effect
   36|       |/// @endcode
   37|       |class AvoidSideEffectInSizeofCheck : public ClangTidyCheck {
   38|       |public:
   39|       |  AvoidSideEffectInSizeofCheck(StringRef Name, ClangTidyContext *Context)
   40|    131|      : ClangTidyCheck(Name, Context) {}
   41|       |
   42|       |  /// Destructor.
   43|    131|  ~AvoidSideEffectInSizeofCheck() override = default;
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINSIZEOFCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidNarrowingCompoundAssignmentCheck.cpp:
    1|       |//===--- AvoidNarrowingCompoundAssignmentCheck.cpp - clang-tidy -----------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidNarrowingCompoundAssignmentCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Convert EssentialType enum to human-readable string for diagnostics.
   18|       |static const char *essentialTypeToString(
   19|     28|    AvoidNarrowingCompoundAssignmentCheck::EssentialType Type) {
   20|     28|  using EType = AvoidNarrowingCompoundAssignmentCheck::EssentialType;
   21|     28|  switch (Type) {
  ------------------
  |  Branch (21:11): [True: 28, False: 0]
  ------------------
   22|     14|  case EType::SignedInt:
  ------------------
  |  Branch (22:3): [True: 14, False: 14]
  ------------------
   23|     14|    return "signed";
   24|     14|  case EType::UnsignedInt:
  ------------------
  |  Branch (24:3): [True: 14, False: 14]
  ------------------
   25|     14|    return "unsigned";
   26|      0|  case EType::FloatingPoint:
  ------------------
  |  Branch (26:3): [True: 0, False: 28]
  ------------------
   27|      0|    return "floating";
   28|      0|  case EType::Boolean:
  ------------------
  |  Branch (28:3): [True: 0, False: 28]
  ------------------
   29|      0|    return "boolean";
   30|      0|  case EType::Character:
  ------------------
  |  Branch (30:3): [True: 0, False: 28]
  ------------------
   31|      0|    return "character";
   32|      0|  case EType::Enum:
  ------------------
  |  Branch (32:3): [True: 0, False: 28]
  ------------------
   33|      0|    return "enum";
   34|      0|  case EType::Other:
  ------------------
  |  Branch (34:3): [True: 0, False: 28]
  ------------------
   35|      0|    return "other";
   36|     28|  }
   37|      0|  return "unknown";
   38|     28|}
   39|       |
   40|       |void AvoidNarrowingCompoundAssignmentCheck::registerMatchers(
   41|    131|    MatchFinder *Finder) {
   42|       |  // Match all assignment expressions
   43|    131|  Finder->addMatcher(binaryOperator(isAssignmentOperator()).bind("assign"),
   44|    131|                     this);
   45|    131|}
   46|       |
   47|       |void AvoidNarrowingCompoundAssignmentCheck::check(
   48|    938|    const MatchFinder::MatchResult &Result) {
   49|    938|  const auto *Assign = Result.Nodes.getNodeAs<BinaryOperator>("assign");
   50|    938|  if (!Assign)
  ------------------
  |  Branch (50:7): [True: 0, False: 938]
  ------------------
   51|      0|    return;
   52|       |
   53|    938|  if (Result.SourceManager->isInSystemHeader(Assign->getOperatorLoc()))
  ------------------
  |  Branch (53:7): [True: 532, False: 406]
  ------------------
   54|    532|    return;
   55|       |
   56|    406|  QualType LHSType = Assign->getLHS()->getType();
   57|    406|  QualType RHSType = Assign->getRHS()->IgnoreParenImpCasts()->getType();
   58|       |
   59|    406|  EssentialType LHSET = getEssentialType(LHSType);
   60|    406|  EssentialType RHSET = getEssentialType(RHSType);
   61|       |
   62|       |  // Check for different essential type categories
   63|    406|  if (isDifferentCategory(RHSET, LHSET)) {
  ------------------
  |  Branch (63:7): [True: 14, False: 392]
  ------------------
   64|     14|    diag(Assign->getOperatorLoc(),
   65|     14|         "expression of essentially '%0' type assigned to object of "
   66|     14|         "essentially '%1' type")
   67|     14|        << essentialTypeToString(RHSET) << essentialTypeToString(LHSET);
   68|     14|    return;
   69|     14|  }
   70|       |
   71|       |  // Check for narrowing within same category
   72|    392|  if (isNarrowing(RHSType, LHSType, *Result.Context)) {
  ------------------
  |  Branch (72:7): [True: 10, False: 382]
  ------------------
   73|     10|    diag(Assign->getOperatorLoc(),
   74|     10|         "assignment results in narrowing conversion from wider to narrower "
   75|     10|         "type");
   76|     10|  }
   77|    392|}
   78|       |
   79|       |AvoidNarrowingCompoundAssignmentCheck::EssentialType
   80|    812|AvoidNarrowingCompoundAssignmentCheck::getEssentialType(QualType Type) const {
   81|    812|  Type = Type.getCanonicalType().getUnqualifiedType();
   82|       |
   83|    812|  if (Type->isBooleanType())
  ------------------
  |  Branch (83:7): [True: 11, False: 801]
  ------------------
   84|     11|    return EssentialType::Boolean;
   85|       |
   86|    801|  if (Type->isAnyCharacterType())
  ------------------
  |  Branch (86:7): [True: 12, False: 789]
  ------------------
   87|     12|    return EssentialType::Character;
   88|       |
   89|    789|  if (Type->isEnumeralType())
  ------------------
  |  Branch (89:7): [True: 1, False: 788]
  ------------------
   90|      1|    return EssentialType::Enum;
   91|       |
   92|    788|  if (Type->isFloatingType())
  ------------------
  |  Branch (92:7): [True: 2, False: 786]
  ------------------
   93|      2|    return EssentialType::FloatingPoint;
   94|       |
   95|    786|  if (Type->isIntegerType()) {
  ------------------
  |  Branch (95:7): [True: 620, False: 166]
  ------------------
   96|    620|    if (Type->isUnsignedIntegerType())
  ------------------
  |  Branch (96:9): [True: 22, False: 598]
  ------------------
   97|     22|      return EssentialType::UnsignedInt;
   98|    598|    if (Type->isSignedIntegerType())
  ------------------
  |  Branch (98:9): [True: 598, False: 0]
  ------------------
   99|    598|      return EssentialType::SignedInt;
  100|    598|  }
  101|       |
  102|    166|  return EssentialType::Other;
  103|    786|}
  104|       |
  105|       |unsigned AvoidNarrowingCompoundAssignmentCheck::getTypeWidth(
  106|    784|    QualType Type, const ASTContext &Ctx) const {
  107|    784|  Type = Type.getCanonicalType();
  108|    784|  if (Type->isIntegerType() || Type->isFloatingType())
  ------------------
  |  Branch (108:7): [True: 616, False: 168]
  |  Branch (108:32): [True: 2, False: 166]
  ------------------
  109|    618|    return Ctx.getTypeSize(Type);
  110|    166|  return 0;
  111|    784|}
  112|       |
  113|       |bool AvoidNarrowingCompoundAssignmentCheck::isNarrowing(
  114|    392|    QualType From, QualType To, const ASTContext &Ctx) const {
  115|    392|  unsigned FromWidth = getTypeWidth(From, Ctx);
  116|    392|  unsigned ToWidth = getTypeWidth(To, Ctx);
  117|       |
  118|    392|  if (FromWidth == 0 || ToWidth == 0)
  ------------------
  |  Branch (118:7): [True: 81, False: 311]
  |  Branch (118:25): [True: 4, False: 307]
  ------------------
  119|     85|    return false;
  120|       |
  121|    307|  return FromWidth > ToWidth;
  122|    392|}
  123|       |
  124|       |bool AvoidNarrowingCompoundAssignmentCheck::isDifferentCategory(
  125|    406|    EssentialType From, EssentialType To) const {
  126|    406|  if (From == To)
  ------------------
  |  Branch (126:7): [True: 374, False: 32]
  ------------------
  127|    374|    return false;
  128|       |
  129|       |  // Allow signed/unsigned mixing to be caught by narrowing instead
  130|     32|  if ((From == EssentialType::SignedInt && To == EssentialType::UnsignedInt) ||
  ------------------
  |  Branch (130:8): [True: 29, False: 3]
  |  Branch (130:44): [True: 14, False: 15]
  ------------------
  131|     32|      (From == EssentialType::UnsignedInt && To == EssentialType::SignedInt))
  ------------------
  |  Branch (131:8): [True: 0, False: 18]
  |  Branch (131:46): [True: 0, False: 0]
  ------------------
  132|     14|    return true;
  133|       |
  134|       |  // Other category mismatches
  135|     18|  if (From == EssentialType::FloatingPoint &&
  ------------------
  |  Branch (135:7): [True: 0, False: 18]
  ------------------
  136|     18|      To != EssentialType::FloatingPoint)
  ------------------
  |  Branch (136:7): [True: 0, False: 0]
  ------------------
  137|      0|    return true;
  138|     18|  if (To == EssentialType::FloatingPoint &&
  ------------------
  |  Branch (138:7): [True: 0, False: 18]
  ------------------
  139|     18|      From != EssentialType::FloatingPoint)
  ------------------
  |  Branch (139:7): [True: 0, False: 0]
  ------------------
  140|      0|    return true;
  141|       |
  142|     18|  return false;
  143|     18|}
  144|       |
  145|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInLogicalOperandCheck.cpp:
    1|       |//===--- AvoidSideEffectInLogicalOperandCheck.cpp - clang-tidy ------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSideEffectInLogicalOperandCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/RecursiveASTVisitor.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |/// Visitor to detect side effects in an expression tree.
   21|       |class SideEffectFinder : public RecursiveASTVisitor<SideEffectFinder> {
   22|       |public:
   23|     28|  bool hasSideEffect() const { return HasSideEffect; }
   24|       |
   25|      2|  bool VisitUnaryOperator(UnaryOperator *UO) {
   26|       |    // Detect ++, -- operators
   27|      2|    if (UO->isIncrementDecrementOp()) {
  ------------------
  |  Branch (27:9): [True: 2, False: 0]
  ------------------
   28|      2|      HasSideEffect = true;
   29|      2|      return false; // Stop traversal
   30|      2|    }
   31|      0|    return true;
   32|      2|  }
   33|       |
   34|     19|  bool VisitBinaryOperator(BinaryOperator *BO) {
   35|       |    // Detect assignment operators (=, +=, -=, etc.)
   36|     19|    if (BO->isAssignmentOp()) {
  ------------------
  |  Branch (36:9): [True: 7, False: 12]
  ------------------
   37|      7|      HasSideEffect = true;
   38|      7|      return false;
   39|      7|    }
   40|     12|    return true;
   41|     19|  }
   42|       |
   43|      0|  bool VisitCompoundAssignOperator(CompoundAssignOperator *) {
   44|      0|    HasSideEffect = true;
   45|      0|    return false;
   46|      0|  }
   47|       |
   48|      1|  bool VisitCallExpr(CallExpr *CE) {
   49|       |    // Function calls are considered to have potential side effects
   50|       |    // unless we can prove they're pure (which is complex to determine)
   51|      1|    HasSideEffect = true;
   52|      1|    return false;
   53|      1|  }
   54|       |
   55|     19|  bool VisitDeclRefExpr(DeclRefExpr *DRE) {
   56|       |    // Check for volatile variable access
   57|     19|    if (DRE->getType().isVolatileQualified()) {
  ------------------
  |  Branch (57:9): [True: 0, False: 19]
  ------------------
   58|      0|      HasSideEffect = true;
   59|      0|      return false;
   60|      0|    }
   61|     19|    return true;
   62|     19|  }
   63|       |
   64|       |private:
   65|       |  bool HasSideEffect = false;
   66|       |};
   67|       |
   68|       |} // anonymous namespace
   69|       |
   70|       |void AvoidSideEffectInLogicalOperandCheck::registerMatchers(
   71|    131|    MatchFinder *Finder) {
   72|       |  // Match logical && and || operators
   73|    131|  Finder->addMatcher(
   74|    131|      binaryOperator(hasAnyOperatorName("&&", "||")).bind("logical"), this);
   75|    131|}
   76|       |
   77|       |void AvoidSideEffectInLogicalOperandCheck::check(
   78|    370|    const MatchFinder::MatchResult &Result) {
   79|    370|  const auto *LogicalOp = Result.Nodes.getNodeAs<BinaryOperator>("logical");
   80|    370|  if (!LogicalOp)
  ------------------
  |  Branch (80:7): [True: 0, False: 370]
  ------------------
   81|      0|    return;
   82|       |
   83|       |  // Skip if in system header
   84|    370|  if (Result.SourceManager->isInSystemHeader(LogicalOp->getOperatorLoc()))
  ------------------
  |  Branch (84:7): [True: 342, False: 28]
  ------------------
   85|    342|    return;
   86|       |
   87|       |  // Check the right-hand operand for side effects
   88|     28|  const Expr *RHS = LogicalOp->getRHS();
   89|     28|  if (!RHS)
  ------------------
  |  Branch (89:7): [True: 0, False: 28]
  ------------------
   90|      0|    return;
   91|       |
   92|     28|  if (hasSideEffect(RHS)) {
  ------------------
  |  Branch (92:7): [True: 10, False: 18]
  ------------------
   93|     10|    diag(RHS->getBeginLoc(),
   94|     10|         "right operand of '%0' operator contains side effects that may not "
   95|     10|         "be evaluated due to short-circuit evaluation")
   96|     10|        << LogicalOp->getOpcodeStr();
   97|     10|  }
   98|     28|}
   99|       |
  100|     28|bool AvoidSideEffectInLogicalOperandCheck::hasSideEffect(const Expr *E) const {
  101|     28|  SideEffectFinder Finder;
  102|       |  // NOSONAR(S859): const_cast required by RecursiveASTVisitor API
  103|     28|  Finder.TraverseStmt(const_cast<Expr *>(E));
  104|     28|  return Finder.hasSideEffect();
  105|     28|}
  106|       |
  107|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidAssignmentInExpressionCheck.cpp:
    1|       |//===--- AvoidAssignmentInExpressionCheck.cpp - clang-tidy ----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidAssignmentInExpressionCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/AST/ASTContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void AvoidAssignmentInExpressionCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(binaryOperator(isAssignmentOperator(),
   20|    131|                                    automotive::isAssignmentResultUsed())
   21|    131|                         .bind("assignment"),
   22|    131|                     this);
   23|    131|}
   24|       |
   25|       |void AvoidAssignmentInExpressionCheck::check(
   26|     28|    const MatchFinder::MatchResult &Result) {
   27|     28|  const auto *Assignment = Result.Nodes.getNodeAs<BinaryOperator>("assignment");
   28|       |
   29|     28|  if (Assignment) {
  ------------------
  |  Branch (29:7): [True: 28, False: 0]
  ------------------
   30|     28|    diag(Assignment->getOperatorLoc(),
   31|     28|         "Avoid using the result of an assignment operator '%0'")
   32|     28|        << Assignment->getOpcodeStr();
   33|     28|  }
   34|     28|}
   35|       |
   36|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidEssentialTypeMismatchCheck.cpp:
    1|       |//===--- AvoidEssentialTypeMismatchCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidEssentialTypeMismatchCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidEssentialTypeMismatchCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match binary operators where usual arithmetic conversions apply
   19|    131|  Finder->addMatcher(
   20|    131|      binaryOperator(
   21|    131|          anyOf(hasAnyOperatorName("+", "-", "*", "/", "%"),
   22|    131|                hasAnyOperatorName("<", ">", "<=", ">=", "==", "!=")))
   23|    131|          .bind("binop"),
   24|    131|      this);
   25|    131|}
   26|       |
   27|       |void AvoidEssentialTypeMismatchCheck::check(
   28|  1.86k|    const MatchFinder::MatchResult &Result) {
   29|  1.86k|  const auto *BinOp = Result.Nodes.getNodeAs<BinaryOperator>("binop");
   30|  1.86k|  if (!BinOp)
  ------------------
  |  Branch (30:7): [True: 0, False: 1.86k]
  ------------------
   31|      0|    return;
   32|       |
   33|  1.86k|  if (Result.SourceManager->isInSystemHeader(BinOp->getOperatorLoc()))
  ------------------
  |  Branch (33:7): [True: 1.32k, False: 538]
  ------------------
   34|  1.32k|    return;
   35|       |
   36|    538|  const Expr *LHS = BinOp->getLHS()->IgnoreParenImpCasts();
   37|    538|  const Expr *RHS = BinOp->getRHS()->IgnoreParenImpCasts();
   38|       |
   39|    538|  EssentialType LHSET = getEssentialType(LHS->getType());
   40|    538|  EssentialType RHSET = getEssentialType(RHS->getType());
   41|       |
   42|       |  // Skip if both are "Other" or same type
   43|    538|  if (LHSET == RHSET)
  ------------------
  |  Branch (43:7): [True: 489, False: 49]
  ------------------
   44|    489|    return;
   45|     49|  if (LHSET == EssentialType::Other || RHSET == EssentialType::Other)
  ------------------
  |  Branch (45:7): [True: 14, False: 35]
  |  Branch (45:40): [True: 1, False: 34]
  ------------------
   46|     15|    return;
   47|       |
   48|       |  // Check for signed/unsigned mismatch
   49|     34|  if ((LHSET == EssentialType::SignedInt &&
  ------------------
  |  Branch (49:8): [True: 8, False: 26]
  ------------------
   50|     34|       RHSET == EssentialType::UnsignedInt) ||
  ------------------
  |  Branch (50:8): [True: 5, False: 3]
  ------------------
   51|     34|      (LHSET == EssentialType::UnsignedInt &&
  ------------------
  |  Branch (51:8): [True: 11, False: 18]
  ------------------
   52|     29|       RHSET == EssentialType::SignedInt)) {
  ------------------
  |  Branch (52:8): [True: 11, False: 0]
  ------------------
   53|     16|    diag(BinOp->getOperatorLoc(),
   54|     16|         "operands have different essential type categories: '%0' and '%1'")
   55|     16|        << getEssentialTypeName(LHSET) << getEssentialTypeName(RHSET);
   56|     16|  }
   57|     34|}
   58|       |
   59|       |AvoidEssentialTypeMismatchCheck::EssentialType
   60|  1.07k|AvoidEssentialTypeMismatchCheck::getEssentialType(QualType Type) const {
   61|  1.07k|  Type = Type.getCanonicalType().getUnqualifiedType();
   62|       |
   63|  1.07k|  if (Type->isBooleanType())
  ------------------
  |  Branch (63:7): [True: 6, False: 1.07k]
  ------------------
   64|      6|    return EssentialType::Boolean;
   65|       |
   66|  1.07k|  if (Type->isAnyCharacterType())
  ------------------
  |  Branch (66:7): [True: 44, False: 1.02k]
  ------------------
   67|     44|    return EssentialType::Character;
   68|       |
   69|  1.02k|  if (Type->isEnumeralType())
  ------------------
  |  Branch (69:7): [True: 2, False: 1.02k]
  ------------------
   70|      2|    return EssentialType::Enum;
   71|       |
   72|  1.02k|  if (Type->isFloatingType())
  ------------------
  |  Branch (72:7): [True: 4, False: 1.02k]
  ------------------
   73|      4|    return EssentialType::FloatingPoint;
   74|       |
   75|  1.02k|  if (Type->isIntegerType()) {
  ------------------
  |  Branch (75:7): [True: 963, False: 57]
  ------------------
   76|    963|    if (Type->isUnsignedIntegerType())
  ------------------
  |  Branch (76:9): [True: 68, False: 895]
  ------------------
   77|     68|      return EssentialType::UnsignedInt;
   78|    895|    if (Type->isSignedIntegerType())
  ------------------
  |  Branch (78:9): [True: 895, False: 0]
  ------------------
   79|    895|      return EssentialType::SignedInt;
   80|    895|  }
   81|       |
   82|     57|  return EssentialType::Other;
   83|  1.02k|}
   84|       |
   85|       |StringRef
   86|     32|AvoidEssentialTypeMismatchCheck::getEssentialTypeName(EssentialType ET) const {
   87|     32|  switch (ET) {
  ------------------
  |  Branch (87:11): [True: 32, False: 0]
  ------------------
   88|      0|  case EssentialType::Boolean:
  ------------------
  |  Branch (88:3): [True: 0, False: 32]
  ------------------
   89|      0|    return "Boolean";
   90|      0|  case EssentialType::Character:
  ------------------
  |  Branch (90:3): [True: 0, False: 32]
  ------------------
   91|      0|    return "Character";
   92|     16|  case EssentialType::SignedInt:
  ------------------
  |  Branch (92:3): [True: 16, False: 16]
  ------------------
   93|     16|    return "Signed";
   94|     16|  case EssentialType::UnsignedInt:
  ------------------
  |  Branch (94:3): [True: 16, False: 16]
  ------------------
   95|     16|    return "Unsigned";
   96|      0|  case EssentialType::FloatingPoint:
  ------------------
  |  Branch (96:3): [True: 0, False: 32]
  ------------------
   97|      0|    return "Floating";
   98|      0|  case EssentialType::Enum:
  ------------------
  |  Branch (98:3): [True: 0, False: 32]
  ------------------
   99|      0|    return "Enum";
  100|      0|  case EssentialType::Other:
  ------------------
  |  Branch (100:3): [True: 0, False: 32]
  ------------------
  101|      0|    return "Other";
  102|     32|  }
  103|      0|  return "Unknown";
  104|     32|}
  105|       |
  106|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidCharacterArithmeticCheck.cpp:
    1|       |//===--- AvoidCharacterArithmeticCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCharacterArithmeticCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidCharacterArithmeticCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match addition and subtraction operators
   19|    131|  Finder->addMatcher(
   20|    131|      binaryOperator(hasAnyOperatorName("+", "-", "+=", "-=")).bind("binop"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|       |void AvoidCharacterArithmeticCheck::check(
   25|    621|    const MatchFinder::MatchResult &Result) {
   26|    621|  const auto *BinOp = Result.Nodes.getNodeAs<BinaryOperator>("binop");
   27|    621|  if (!BinOp)
  ------------------
  |  Branch (27:7): [True: 0, False: 621]
  ------------------
   28|      0|    return;
   29|       |
   30|    621|  if (Result.SourceManager->isInSystemHeader(BinOp->getOperatorLoc()))
  ------------------
  |  Branch (30:7): [True: 380, False: 241]
  ------------------
   31|    380|    return;
   32|       |
   33|    241|  const Expr *LHS = BinOp->getLHS()->IgnoreParenImpCasts();
   34|    241|  const Expr *RHS = BinOp->getRHS()->IgnoreParenImpCasts();
   35|       |
   36|    241|  bool LHSIsChar = isCharacterType(LHS->getType());
   37|    241|  bool RHSIsChar = isCharacterType(RHS->getType());
   38|       |
   39|       |  // Rule 10.2: Both operands being character type is inappropriate
   40|    241|  if (LHSIsChar && RHSIsChar) {
  ------------------
  |  Branch (40:7): [True: 20, False: 221]
  |  Branch (40:20): [True: 16, False: 4]
  ------------------
   41|     16|    diag(BinOp->getOperatorLoc(),
   42|     16|         "addition or subtraction between two expressions of essentially "
   43|     16|         "character type is not allowed");
   44|     16|  }
   45|    241|}
   46|       |
   47|    482|bool AvoidCharacterArithmeticCheck::isCharacterType(QualType Type) const {
   48|    482|  Type = Type.getCanonicalType().getUnqualifiedType();
   49|    482|  return Type->isAnyCharacterType();
   50|    482|}
   51|       |
   52|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/InvariantControlCheck.cpp:
    1|       |//===--- InvariantControlCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "InvariantControlCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void InvariantControlCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(
   18|    131|      ifStmt(hasCondition(expr().bind("controlExpr"))).bind("ifStmt"), this);
   19|       |
   20|    131|  Finder->addMatcher(
   21|    131|      whileStmt(hasCondition(expr().bind("controlExpr"))).bind("whileStmt"),
   22|    131|      this);
   23|       |
   24|    131|  Finder->addMatcher(
   25|    131|      doStmt(hasCondition(expr().bind("controlExpr"))).bind("doStmt"), this);
   26|       |
   27|    131|  Finder->addMatcher(
   28|    131|      forStmt(hasCondition(expr().bind("controlExpr"))).bind("forStmt"), this);
   29|       |
   30|    131|  Finder->addMatcher(
   31|    131|      switchStmt(hasCondition(expr().bind("controlExpr"))).bind("switchStmt"),
   32|    131|      this);
   33|       |
   34|    131|  Finder->addMatcher(
   35|    131|      conditionalOperator(hasCondition(expr().bind("controlExpr")))
   36|    131|          .bind("ternaryOp"),
   37|    131|      this);
   38|    131|}
   39|       |
   40|  1.59k|void InvariantControlCheck::check(const MatchFinder::MatchResult &Result) {
   41|  1.59k|  const auto *ControlExpr = Result.Nodes.getNodeAs<Expr>("controlExpr");
   42|  1.59k|  Expr::EvalResult EvalResult;
   43|       |
   44|  1.59k|  if (!ControlExpr)
  ------------------
  |  Branch (44:7): [True: 0, False: 1.59k]
  ------------------
   45|      0|    return;
   46|       |
   47|       |  // Don't evaluate value-dependent expressions (e.g., in templates)
   48|  1.59k|  if (ControlExpr->isValueDependent())
  ------------------
  |  Branch (48:7): [True: 643, False: 956]
  ------------------
   49|    643|    return;
   50|       |
   51|    956|  if (ControlExpr->EvaluateAsInt(EvalResult, *Result.Context)) {
  ------------------
  |  Branch (51:7): [True: 169, False: 787]
  ------------------
   52|    169|    if (EvalResult.Val.getInt().getBoolValue()) {
  ------------------
  |  Branch (52:9): [True: 49, False: 120]
  ------------------
   53|     49|      diag(ControlExpr->getBeginLoc(),
   54|     49|           "avoid controlling expression to always be evaluated to 'true'");
   55|    120|    } else {
   56|    120|      diag(ControlExpr->getBeginLoc(),
   57|    120|           "avoid controlling expression to always be evaluated to 'false'");
   58|    120|    }
   59|    169|  }
   60|    956|}
   61|       |
   62|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/InvariantControlCheck.h:
    1|       |//===--- InvariantControlCheck.h - clang-tidy -------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_INVARIANTCONTROLCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_INVARIANTCONTROLCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects control expressions with invariant values.
   17|       |///
   18|       |/// Loop control expressions and conditional statements should depend on
   19|       |/// variable values that can change. An invariant (constant) control expression
   20|       |/// results in an infinite loop or dead code, which is usually a programming
   21|       |/// error that indicates a logic mistake or incomplete implementation.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 14.2 - A for loop shall be well-formed.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   while (1) { }       // Warning: invariant control expression
   28|       |///   for (;;) { }        // Warning: invariant control expression
   29|       |/// \endcode
   30|       |class InvariantControlCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  InvariantControlCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~InvariantControlCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for loop and conditional statements.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched control expressions and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_INVARIANTCONTROLCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInInitializerCheck.h:
    1|       |//===--- AvoidSideEffectInInitializerCheck.h - clang-tidy -------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINITIALIZERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINITIALIZERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects side effects in initializer lists.
   18|       |///
   19|       |/// Implements MISRA Rules 13.1, 13.2, 13.3:
   20|       |/// - 13.1: Initializer lists shall not contain persistent side effects
   21|       |/// - 13.2: Value of expression and side effects shall be same under any
   22|       |///   evaluation order
   23|       |/// - 13.3: Full expression with increment/decrement shall have no other
   24|       |///   side effects
   25|       |///
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   int a = 0;
   31|       |///   int arr[] = {a++, a++};  // Warning: side effects in initializer
   32|       |///   int x = a++ + a++;       // Warning: unsequenced side effects
   33|       |/// @endcode
   34|       |class AvoidSideEffectInInitializerCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  AvoidSideEffectInInitializerCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidSideEffectInInitializerCheck() override = default;
   41|       |
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |
   45|       |private:
   46|       |  bool hasSideEffect(const Expr *E) const;
   47|       |  unsigned countSideEffects(const Expr *E) const;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINITIALIZERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidInappropriateEssentialTypeCheck.cpp:
    1|       |//===--- AvoidInappropriateEssentialTypeCheck.cpp - clang-tidy -----------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidInappropriateEssentialTypeCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void AvoidInappropriateEssentialTypeCheck::registerMatchers(
   18|    131|    MatchFinder *Finder) {
   19|       |  // Match binary operators: arithmetic, bitwise, and relational
   20|    131|  Finder->addMatcher(
   21|    131|      binaryOperator(anyOf(hasAnyOperatorName("+", "-", "*", "/", "%"),
   22|    131|                           hasAnyOperatorName("&", "|", "^", "<<", ">>"),
   23|    131|                           hasAnyOperatorName("+=", "-=", "*=", "/=", "%=",
   24|    131|                                              "&=", "|=", "^=", "<<=", ">>=")))
   25|    131|          .bind("binop"),
   26|    131|      this);
   27|       |
   28|       |  // Match unary operators that may have essential type issues
   29|    131|  Finder->addMatcher(
   30|    131|      unaryOperator(anyOf(hasOperatorName("~"), hasOperatorName("+"),
   31|    131|                          hasOperatorName("-")))
   32|    131|          .bind("unop"),
   33|    131|      this);
   34|    131|}
   35|       |
   36|       |void AvoidInappropriateEssentialTypeCheck::checkArithmeticOperand(
   37|    558|    const Expr *Operand, EssentialType ET) {
   38|    558|  if (!isAppropriateForArithmetic(ET)) {
  ------------------
  |  Branch (38:7): [True: 42, False: 516]
  ------------------
   39|     42|    diag(Operand->getBeginLoc(),
   40|     42|         "operand of essential type '%0' is inappropriate for arithmetic "
   41|     42|         "operation")
   42|     42|        << getEssentialTypeName(ET);
   43|     42|  }
   44|    558|}
   45|       |
   46|       |void AvoidInappropriateEssentialTypeCheck::checkBitwiseOperand(
   47|    115|    const Expr *Operand, EssentialType ET) {
   48|    115|  if (!isAppropriateForBitwise(ET)) {
  ------------------
  |  Branch (48:7): [True: 28, False: 87]
  ------------------
   49|     28|    diag(Operand->getBeginLoc(),
   50|     28|         "operand of essential type '%0' is inappropriate for bitwise "
   51|     28|         "operation")
   52|     28|        << getEssentialTypeName(ET);
   53|     28|  }
   54|    115|}
   55|       |
   56|       |void AvoidInappropriateEssentialTypeCheck::handleBinaryOperator(
   57|  1.36k|    const BinaryOperator *BinOp, const SourceManager &SM) {
   58|  1.36k|  if (SM.isInSystemHeader(BinOp->getOperatorLoc()))
  ------------------
  |  Branch (58:7): [True: 992, False: 373]
  ------------------
   59|    992|    return;
   60|       |
   61|    373|  const Expr *LHS = BinOp->getLHS()->IgnoreParenImpCasts();
   62|    373|  const Expr *RHS = BinOp->getRHS()->IgnoreParenImpCasts();
   63|       |
   64|    373|  EssentialType LHSET = getEssentialType(LHS->getType());
   65|    373|  EssentialType RHSET = getEssentialType(RHS->getType());
   66|       |
   67|    373|  bool IsArithmetic = BinOp->isAdditiveOp() || BinOp->isMultiplicativeOp();
  ------------------
  |  Branch (67:23): [True: 220, False: 153]
  |  Branch (67:48): [True: 59, False: 94]
  ------------------
   68|    373|  bool IsBitwise = BinOp->isBitwiseOp() || BinOp->isShiftOp();
  ------------------
  |  Branch (68:20): [True: 24, False: 349]
  |  Branch (68:44): [True: 31, False: 318]
  ------------------
   69|       |
   70|    373|  if (IsArithmetic) {
  ------------------
  |  Branch (70:7): [True: 279, False: 94]
  ------------------
   71|    279|    checkArithmeticOperand(LHS, LHSET);
   72|    279|    checkArithmeticOperand(RHS, RHSET);
   73|    279|  }
   74|       |
   75|    373|  if (IsBitwise) {
  ------------------
  |  Branch (75:7): [True: 55, False: 318]
  ------------------
   76|     55|    checkBitwiseOperand(LHS, LHSET);
   77|     55|    checkBitwiseOperand(RHS, RHSET);
   78|     55|  }
   79|    373|}
   80|       |
   81|       |void AvoidInappropriateEssentialTypeCheck::handleUnaryOperator(
   82|    143|    const UnaryOperator *UnOp, const SourceManager &SM) {
   83|    143|  if (SM.isInSystemHeader(UnOp->getOperatorLoc()))
  ------------------
  |  Branch (83:7): [True: 108, False: 35]
  ------------------
   84|    108|    return;
   85|       |
   86|     35|  const Expr *SubExpr = UnOp->getSubExpr()->IgnoreParenImpCasts();
   87|     35|  EssentialType ET = getEssentialType(SubExpr->getType());
   88|       |
   89|     35|  if (UnOp->getOpcode() == UO_Not) {
  ------------------
  |  Branch (89:7): [True: 5, False: 30]
  ------------------
   90|      5|    checkBitwiseOperand(SubExpr, ET);
   91|      5|    return;
   92|      5|  }
   93|       |
   94|     30|  if (UnOp->getOpcode() == UO_Plus || UnOp->getOpcode() == UO_Minus) {
  ------------------
  |  Branch (94:7): [True: 3, False: 27]
  |  Branch (94:39): [True: 27, False: 0]
  ------------------
   95|     30|    if (!isAppropriateForArithmetic(ET)) {
  ------------------
  |  Branch (95:9): [True: 6, False: 24]
  ------------------
   96|      6|      diag(SubExpr->getBeginLoc(),
   97|      6|           "operand of essential type '%0' is inappropriate for unary '%1' "
   98|      6|           "operation")
   99|      6|          << getEssentialTypeName(ET)
  100|      6|          << (UnOp->getOpcode() == UO_Plus ? "+" : "-");
  ------------------
  |  Branch (100:15): [True: 3, False: 3]
  ------------------
  101|      6|    }
  102|     30|  }
  103|     30|}
  104|       |
  105|       |void AvoidInappropriateEssentialTypeCheck::check(
  106|  1.50k|    const MatchFinder::MatchResult &Result) {
  107|  1.50k|  if (const auto *BinOp = Result.Nodes.getNodeAs<BinaryOperator>("binop")) {
  ------------------
  |  Branch (107:19): [True: 1.36k, False: 143]
  ------------------
  108|  1.36k|    handleBinaryOperator(BinOp, *Result.SourceManager);
  109|  1.36k|    return;
  110|  1.36k|  }
  111|       |
  112|    143|  if (const auto *UnOp = Result.Nodes.getNodeAs<UnaryOperator>("unop")) {
  ------------------
  |  Branch (112:19): [True: 143, False: 0]
  ------------------
  113|    143|    handleUnaryOperator(UnOp, *Result.SourceManager);
  114|    143|  }
  115|    143|}
  116|       |
  117|       |AvoidInappropriateEssentialTypeCheck::EssentialType
  118|    781|AvoidInappropriateEssentialTypeCheck::getEssentialType(QualType Type) const {
  119|    781|  Type = Type.getCanonicalType().getUnqualifiedType();
  120|       |
  121|    781|  if (Type->isBooleanType())
  ------------------
  |  Branch (121:7): [True: 19, False: 762]
  ------------------
  122|     19|    return EssentialType::Boolean;
  123|       |
  124|    762|  if (Type->isAnyCharacterType())
  ------------------
  |  Branch (124:7): [True: 64, False: 698]
  ------------------
  125|     64|    return EssentialType::Character;
  126|       |
  127|    698|  if (Type->isEnumeralType())
  ------------------
  |  Branch (127:7): [True: 2, False: 696]
  ------------------
  128|      2|    return EssentialType::Enum;
  129|       |
  130|    696|  if (Type->isFloatingType())
  ------------------
  |  Branch (130:7): [True: 4, False: 692]
  ------------------
  131|      4|    return EssentialType::FloatingPoint;
  132|       |
  133|    692|  if (Type->isIntegerType()) {
  ------------------
  |  Branch (133:7): [True: 667, False: 25]
  ------------------
  134|    667|    if (Type->isUnsignedIntegerType())
  ------------------
  |  Branch (134:9): [True: 85, False: 582]
  ------------------
  135|     85|      return EssentialType::UnsignedInt;
  136|    582|    if (Type->isSignedIntegerType())
  ------------------
  |  Branch (136:9): [True: 582, False: 0]
  ------------------
  137|    582|      return EssentialType::SignedInt;
  138|    582|  }
  139|       |
  140|     25|  return EssentialType::Other;
  141|    692|}
  142|       |
  143|       |bool AvoidInappropriateEssentialTypeCheck::isAppropriateForArithmetic(
  144|    588|    EssentialType ET) const {
  145|    588|  return ET != EssentialType::Boolean && ET != EssentialType::Character;
  ------------------
  |  Branch (145:10): [True: 580, False: 8]
  |  Branch (145:42): [True: 540, False: 40]
  ------------------
  146|    588|}
  147|       |
  148|       |bool AvoidInappropriateEssentialTypeCheck::isAppropriateForBitwise(
  149|    115|    EssentialType ET) const {
  150|    115|  return ET != EssentialType::Boolean && ET != EssentialType::Character &&
  ------------------
  |  Branch (150:10): [True: 107, False: 8]
  |  Branch (150:42): [True: 87, False: 20]
  ------------------
  151|    115|         ET != EssentialType::FloatingPoint;
  ------------------
  |  Branch (151:10): [True: 87, False: 0]
  ------------------
  152|    115|}
  153|       |
  154|       |StringRef AvoidInappropriateEssentialTypeCheck::getEssentialTypeName(
  155|     76|    EssentialType ET) const {
  156|     76|  switch (ET) {
  ------------------
  |  Branch (156:11): [True: 76, False: 0]
  ------------------
  157|     16|  case EssentialType::Boolean:
  ------------------
  |  Branch (157:3): [True: 16, False: 60]
  ------------------
  158|     16|    return "Boolean";
  159|     60|  case EssentialType::Character:
  ------------------
  |  Branch (159:3): [True: 60, False: 16]
  ------------------
  160|     60|    return "Character";
  161|      0|  case EssentialType::SignedInt:
  ------------------
  |  Branch (161:3): [True: 0, False: 76]
  ------------------
  162|      0|    return "Signed";
  163|      0|  case EssentialType::UnsignedInt:
  ------------------
  |  Branch (163:3): [True: 0, False: 76]
  ------------------
  164|      0|    return "Unsigned";
  165|      0|  case EssentialType::FloatingPoint:
  ------------------
  |  Branch (165:3): [True: 0, False: 76]
  ------------------
  166|      0|    return "Floating";
  167|      0|  case EssentialType::Enum:
  ------------------
  |  Branch (167:3): [True: 0, False: 76]
  ------------------
  168|      0|    return "Enum";
  169|      0|  case EssentialType::Other:
  ------------------
  |  Branch (169:3): [True: 0, False: 76]
  ------------------
  170|      0|    return "Other";
  171|     76|  }
  172|      0|  return "Unknown";
  173|     76|}
  174|       |
  175|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidEssentialTypeMismatchCheck.h:
    1|       |//===--- AvoidEssentialTypeMismatchCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDESSENTIALTYPEMISMATCHCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDESSENTIALTYPEMISMATCHCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects essential type mismatches in binary operations.
   18|       |///
   19|       |/// Implements MISRA Rule 10.4: Both operands of an operator in which the
   20|       |/// usual arithmetic conversions are performed shall have the same essential
   21|       |/// type category.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 10.4
   24|       |/// Mixing signed and unsigned operands in arithmetic is error-prone.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   int32_t s = 10;
   30|       |///   uint32_t u = 20;
   31|       |///   int result = s + u;  // Warning: signed/unsigned mismatch
   32|       |/// @endcode
   33|       |class AvoidEssentialTypeMismatchCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidEssentialTypeMismatchCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidEssentialTypeMismatchCheck() override = default;
   40|       |
   41|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   42|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   43|       |
   44|       |private:
   45|       |  enum class EssentialType {
   46|       |    Boolean,
   47|       |    Character,
   48|       |    SignedInt,
   49|       |    UnsignedInt,
   50|       |    FloatingPoint,
   51|       |    Enum,
   52|       |    Other
   53|       |  };
   54|       |
   55|       |  EssentialType getEssentialType(QualType Type) const;
   56|       |  StringRef getEssentialTypeName(EssentialType ET) const;
   57|       |};
   58|       |
   59|       |} // namespace clang::tidy::automotive
   60|       |
   61|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDESSENTIALTYPEMISMATCHCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidNonBooleanInConditionCheck.cpp:
    1|       |//===--- AvoidNonBooleanInConditionCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidNonBooleanInConditionCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/AST/ASTContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void AvoidNonBooleanInConditionCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(
   20|    131|      ifStmt(hasCondition(expr(unless(automotive::isEssentiallyBoolean()))
   21|    131|                              .bind("condition")))
   22|    131|          .bind("ifStmt"),
   23|    131|      this);
   24|    131|  Finder->addMatcher(
   25|    131|      whileStmt(hasCondition(expr(unless(automotive::isEssentiallyBoolean()))
   26|    131|                                 .bind("condition")))
   27|    131|          .bind("whileStmt"),
   28|    131|      this);
   29|    131|  Finder->addMatcher(
   30|    131|      forStmt(hasCondition(expr(unless(automotive::isEssentiallyBoolean()))
   31|    131|                               .bind("condition")))
   32|    131|          .bind("forStmt"),
   33|    131|      this);
   34|    131|}
   35|       |
   36|       |void AvoidNonBooleanInConditionCheck::check(
   37|    400|    const MatchFinder::MatchResult &Result) {
   38|    400|  const auto *MatchedCond = Result.Nodes.getNodeAs<Expr>("condition");
   39|       |
   40|    400|  if (MatchedCond) {
  ------------------
  |  Branch (40:7): [True: 400, False: 0]
  ------------------
   41|    400|    diag(MatchedCond->getBeginLoc(),
   42|    400|         "avoid using non-boolean expression in control flow condition");
   43|    400|  }
   44|    400|}
   45|       |
   46|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidAssignmentInExpressionCheck.h:
    1|       |//===--- AvoidAssignmentInExpressionCheck.h - clang-tidy --------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDASSIGNMENTINEXPRESSIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDASSIGNMENTINEXPRESSIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects assignment operations embedded within larger expressions.
   17|       |///
   18|       |/// Assignment within expressions can be easily confused with equality
   19|       |/// comparison (== vs =), leading to subtle bugs. Separating assignment from
   20|       |/// other operations makes code more readable and reduces the risk of
   21|       |/// accidental assignment in conditional expressions.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 13.4 - The result of an assignment operator
   24|       |/// should not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   if (x = getValue()) { }  // Warning: assignment in condition
   29|       |///   int y = (z = 10) + 5;    // Warning: assignment in expression
   30|       |/// \endcode
   31|       |class AvoidAssignmentInExpressionCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidAssignmentInExpressionCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidAssignmentInExpressionCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for assignment expressions.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched assignments and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDASSIGNMENTINEXPRESSIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInLogicalOperandCheck.h:
    1|       |//===--- AvoidSideEffectInLogicalOperandCheck.h - clang-tidy ----*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINLOGICALOPERANDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINLOGICALOPERANDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects persistent side effects in the right operand of && and ||.
   18|       |///
   19|       |/// The right-hand operand of a logical && or || operator shall not contain
   20|       |/// persistent side effects. Due to short-circuit evaluation, the right operand
   21|       |/// may not be evaluated, making side effects in it unreliable and potentially
   22|       |/// leading to unexpected behavior.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 13.5
   25|       |/// The right hand operand of a logical && or || operator shall not contain
   26|       |/// persistent side effects.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   int x = 0;
   32|       |///   if (a && (x = foo()))  // Warning: assignment in right operand
   33|       |///   if (b || bar(++x))     // Warning: increment in function arg
   34|       |///   if (c && pure_func())  // Compliant: no side effects
   35|       |/// @endcode
   36|       |class AvoidSideEffectInLogicalOperandCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidSideEffectInLogicalOperandCheck(StringRef Name,
   39|       |                                       ClangTidyContext *Context)
   40|    131|      : ClangTidyCheck(Name, Context) {}
   41|       |
   42|       |  /// Destructor.
   43|    131|  ~AvoidSideEffectInLogicalOperandCheck() override = default;
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |
   47|       |private:
   48|       |  bool hasSideEffect(const Expr *E) const;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIDEEFFECTINLOGICALOPERANDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidNarrowingCompoundAssignmentCheck.h:
    1|       |//===--- AvoidNarrowingCompoundAssignmentCheck.h - clang-tidy ---*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNARROWINGCOMPOUNDASSIGNMENTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNARROWINGCOMPOUNDASSIGNMENTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects narrowing in compound assignment expressions.
   18|       |///
   19|       |/// Implements MISRA Rule 10.3: The value of an expression shall not be
   20|       |/// assigned to an object with a narrower essential type or of a different
   21|       |/// essential type category.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 10.3
   24|       |/// Narrowing conversions in assignments lose information and should be avoided.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   int32_t i32 = 100;
   30|       |///   int16_t i16;
   31|       |///   i16 = i32;           // Warning: narrowing from int32 to int16
   32|       |///   uint32_t u32 = 100;
   33|       |///   int32_t s32 = u32;   // Warning: unsigned to signed
   34|       |/// @endcode
   35|       |class AvoidNarrowingCompoundAssignmentCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  /// Essential type categories for MISRA type analysis.
   38|       |  enum class EssentialType {
   39|       |    Boolean,
   40|       |    Character,
   41|       |    SignedInt,
   42|       |    UnsignedInt,
   43|       |    FloatingPoint,
   44|       |    Enum,
   45|       |    Other
   46|       |  };
   47|       |
   48|       |  AvoidNarrowingCompoundAssignmentCheck(StringRef Name,
   49|       |                                        ClangTidyContext *Context)
   50|    131|      : ClangTidyCheck(Name, Context) {}
   51|       |
   52|       |  /// Destructor.
   53|    131|  ~AvoidNarrowingCompoundAssignmentCheck() override = default;
   54|       |
   55|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   56|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   57|       |
   58|       |private:
   59|       |  EssentialType getEssentialType(QualType Type) const;
   60|       |  unsigned getTypeWidth(QualType Type, const ASTContext &Ctx) const;
   61|       |  bool isNarrowing(QualType From, QualType To, const ASTContext &Ctx) const;
   62|       |  bool isDifferentCategory(EssentialType From, EssentialType To) const;
   63|       |};
   64|       |
   65|       |} // namespace clang::tidy::automotive
   66|       |
   67|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNARROWINGCOMPOUNDASSIGNMENTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidInappropriateCastCheck.cpp:
    1|       |//===--- AvoidInappropriateCastCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidInappropriateCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |const char *
   18|     12|AvoidInappropriateCastCheck::essentialTypeToString(EssentialType ET) {
   19|     12|  switch (ET) {
  ------------------
  |  Branch (19:11): [True: 12, False: 0]
  ------------------
   20|      2|  case EssentialType::SignedInt:
  ------------------
  |  Branch (20:3): [True: 2, False: 10]
  ------------------
   21|      2|    return "signed";
   22|      0|  case EssentialType::UnsignedInt:
  ------------------
  |  Branch (22:3): [True: 0, False: 12]
  ------------------
   23|      0|    return "unsigned";
   24|      3|  case EssentialType::Boolean:
  ------------------
  |  Branch (24:3): [True: 3, False: 9]
  ------------------
   25|      3|    return "boolean";
   26|      3|  case EssentialType::Character:
  ------------------
  |  Branch (26:3): [True: 3, False: 9]
  ------------------
   27|      3|    return "character";
   28|      0|  case EssentialType::FloatingPoint:
  ------------------
  |  Branch (28:3): [True: 0, False: 12]
  ------------------
   29|      0|    return "floating";
   30|      0|  case EssentialType::Enum:
  ------------------
  |  Branch (30:3): [True: 0, False: 12]
  ------------------
   31|      0|    return "enum";
   32|      4|  case EssentialType::Other:
  ------------------
  |  Branch (32:3): [True: 4, False: 8]
  ------------------
   33|      4|    return "other";
   34|     12|  }
   35|      0|  return "other";
   36|     12|}
   37|       |
   38|    131|void AvoidInappropriateCastCheck::registerMatchers(MatchFinder *Finder) {
   39|       |  // Match C-style casts
   40|    131|  Finder->addMatcher(cStyleCastExpr().bind("cast"), this);
   41|    131|}
   42|       |
   43|       |void AvoidInappropriateCastCheck::check(
   44|    603|    const MatchFinder::MatchResult &Result) {
   45|    603|  const auto *Cast = Result.Nodes.getNodeAs<CStyleCastExpr>("cast");
   46|    603|  if (!Cast)
  ------------------
  |  Branch (46:7): [True: 0, False: 603]
  ------------------
   47|      0|    return;
   48|       |
   49|    603|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (49:7): [True: 192, False: 411]
  ------------------
   50|    192|    return;
   51|       |
   52|    411|  QualType FromType = Cast->getSubExpr()->getType();
   53|    411|  QualType ToType = Cast->getType();
   54|       |
   55|    411|  EssentialType FromET = getEssentialType(FromType);
   56|    411|  EssentialType ToET = getEssentialType(ToType);
   57|       |
   58|    411|  if (isInappropriateCast(FromET, ToET)) {
  ------------------
  |  Branch (58:7): [True: 6, False: 405]
  ------------------
   59|      6|    diag(Cast->getBeginLoc(), "cast from essentially '%0' type to essentially "
   60|      6|                              "'%1' type may indicate design issues")
   61|      6|        << essentialTypeToString(FromET) << essentialTypeToString(ToET);
   62|      6|  }
   63|    411|}
   64|       |
   65|       |AvoidInappropriateCastCheck::EssentialType
   66|    822|AvoidInappropriateCastCheck::getEssentialType(QualType Type) const {
   67|    822|  Type = Type.getCanonicalType().getUnqualifiedType();
   68|       |
   69|    822|  if (Type->isBooleanType())
  ------------------
  |  Branch (69:7): [True: 3, False: 819]
  ------------------
   70|      3|    return EssentialType::Boolean;
   71|       |
   72|    819|  if (Type->isAnyCharacterType())
  ------------------
  |  Branch (72:7): [True: 31, False: 788]
  ------------------
   73|     31|    return EssentialType::Character;
   74|       |
   75|    788|  if (Type->isEnumeralType())
  ------------------
  |  Branch (75:7): [True: 0, False: 788]
  ------------------
   76|      0|    return EssentialType::Enum;
   77|       |
   78|    788|  if (Type->isFloatingType())
  ------------------
  |  Branch (78:7): [True: 16, False: 772]
  ------------------
   79|     16|    return EssentialType::FloatingPoint;
   80|       |
   81|    772|  if (Type->isIntegerType()) {
  ------------------
  |  Branch (81:7): [True: 246, False: 526]
  ------------------
   82|    246|    if (Type->isUnsignedIntegerType())
  ------------------
  |  Branch (82:9): [True: 39, False: 207]
  ------------------
   83|     39|      return EssentialType::UnsignedInt;
   84|    207|    if (Type->isSignedIntegerType())
  ------------------
  |  Branch (84:9): [True: 207, False: 0]
  ------------------
   85|    207|      return EssentialType::SignedInt;
   86|    207|  }
   87|       |
   88|    526|  return EssentialType::Other;
   89|    772|}
   90|       |
   91|       |bool AvoidInappropriateCastCheck::isInappropriateCast(EssentialType From,
   92|    411|                                                      EssentialType To) const {
   93|       |  // Cast to boolean is inappropriate unless from boolean
   94|    411|  if (To == EssentialType::Boolean && From != EssentialType::Boolean)
  ------------------
  |  Branch (94:7): [True: 0, False: 411]
  |  Branch (94:39): [True: 0, False: 0]
  ------------------
   95|      0|    return true;
   96|       |
   97|       |  // Cast from boolean to non-boolean is inappropriate
   98|    411|  if (From == EssentialType::Boolean && To != EssentialType::Boolean)
  ------------------
  |  Branch (98:7): [True: 3, False: 408]
  |  Branch (98:41): [True: 3, False: 0]
  ------------------
   99|      3|    return true;
  100|       |
  101|       |  // Cast to character from non-character (except unsigned)
  102|    408|  if (To == EssentialType::Character && From != EssentialType::Character &&
  ------------------
  |  Branch (102:7): [True: 3, False: 405]
  |  Branch (102:41): [True: 3, False: 0]
  ------------------
  103|    408|      From != EssentialType::UnsignedInt)
  ------------------
  |  Branch (103:7): [True: 3, False: 0]
  ------------------
  104|      3|    return true;
  105|       |
  106|       |  // Cast to enum is inappropriate
  107|    405|  if (To == EssentialType::Enum && From != EssentialType::Enum)
  ------------------
  |  Branch (107:7): [True: 0, False: 405]
  |  Branch (107:36): [True: 0, False: 0]
  ------------------
  108|      0|    return true;
  109|       |
  110|    405|  return false;
  111|    405|}
  112|       |
  113|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidCharacterArithmeticCheck.h:
    1|       |//===--- AvoidCharacterArithmeticCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCHARACTERARITHMETICCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCHARACTERARITHMETICCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects inappropriate character type arithmetic operations.
   18|       |///
   19|       |/// Implements MISRA Rule 10.2: Expressions of essentially character type
   20|       |/// shall not be used inappropriately in addition and subtraction operations.
   21|       |///
   22|       |/// @par MISRA C:2025 Rule 10.2
   23|       |/// Essentially character types should only be added to/subtracted from
   24|       |/// essentially signed or unsigned types, not other character types.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   char a = 'A', b = 'B';
   30|       |///   char c = a + b;      // Warning: character + character
   31|       |///   char d = a + 1;      // OK: character + integer
   32|       |///   int diff = a - b;    // Warning: character - character
   33|       |/// @endcode
   34|       |class AvoidCharacterArithmeticCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  AvoidCharacterArithmeticCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidCharacterArithmeticCheck() override = default;
   41|       |
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |
   45|       |private:
   46|       |  bool isCharacterType(QualType Type) const;
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCHARACTERARITHMETICCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidConstantWrapAroundCheck.h:
    1|       |//===--- AvoidConstantWrapAroundCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCONSTANTWRAPAROUNDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCONSTANTWRAPAROUNDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects unsigned integer wrap-around in constant expressions.
   18|       |///
   19|       |/// Evaluating constant expressions should not lead to unsigned integer
   20|       |/// wrap-around. While wrap-around behavior is well-defined for unsigned types
   21|       |/// in C, it is often a sign of a programming error when it occurs in constant
   22|       |/// expressions at compile time.
   23|       |///
   24|       |/// @par MISRA C:2023 Rule 12.4
   25|       |/// Evaluation of constant expressions should not lead to unsigned integer
   26|       |/// wrap-around.
   27|       |/// @par Category: Advisory
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   const unsigned int x = 0u - 1u;        // Warning: wrap-around
   32|       |///   const unsigned int y = UINT_MAX + 1u;  // Warning: wrap-around
   33|       |///   #define MAX_PLUS_ONE (UINT_MAX + 1)    // Warning: wrap-around
   34|       |///   const unsigned int z = 5u + 10u;       // Compliant: no wrap-around
   35|       |/// @endcode
   36|       |class AvoidConstantWrapAroundCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidConstantWrapAroundCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidConstantWrapAroundCheck() override = default;
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCONSTANTWRAPAROUNDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInSizeofCheck.cpp:
    1|       |//===--- AvoidSideEffectInSizeofCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSideEffectInSizeofCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/RecursiveASTVisitor.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |/// Visitor to detect expressions with potential side effects
   21|       |class SideEffectFinder : public RecursiveASTVisitor<SideEffectFinder> {
   22|       |public:
   23|     66|  bool hasSideEffect() const { return FoundSideEffect; }
   24|      0|  SourceLocation getSideEffectLoc() const { return SideEffectLoc; } // LCOV_EXCL_LINE - unused getter
   25|     20|  StringRef getSideEffectKind() const { return SideEffectKind; }
   26|       |
   27|     13|  bool VisitUnaryOperator(UnaryOperator *UO) {
   28|       |    // ++, --, & (address-of on volatile)
   29|     13|    if (UO->isIncrementDecrementOp()) {
  ------------------
  |  Branch (29:9): [True: 8, False: 5]
  ------------------
   30|      8|      FoundSideEffect = true;
   31|      8|      SideEffectLoc = UO->getOperatorLoc();
   32|      8|      SideEffectKind = UO->isIncrementOp() ? "increment" : "decrement";
  ------------------
  |  Branch (32:24): [True: 6, False: 2]
  ------------------
   33|      8|      return false;
   34|      8|    }
   35|      5|    return true;
   36|     13|  }
   37|       |
   38|     31|  bool VisitBinaryOperator(BinaryOperator *BO) {
   39|       |    // Assignment operators: =, +=, -=, etc.
   40|     31|    if (BO->isAssignmentOp()) {
  ------------------
  |  Branch (40:9): [True: 10, False: 21]
  ------------------
   41|     10|      FoundSideEffect = true;
   42|     10|      SideEffectLoc = BO->getOperatorLoc();
   43|     10|      SideEffectKind = "assignment";
   44|     10|      return false;
   45|     10|    }
   46|     21|    return true;
   47|     31|  }
   48|       |
   49|       |  // LCOV_EXCL_START - same pattern as VisitBinaryOperator for assignment
   50|      0|  bool VisitCompoundAssignOperator(CompoundAssignOperator *CAO) {
   51|      0|    FoundSideEffect = true;
   52|      0|    SideEffectLoc = CAO->getOperatorLoc();
   53|      0|    SideEffectKind = "compound assignment";
   54|      0|    return false;
   55|      0|  }
   56|       |  // LCOV_EXCL_STOP
   57|       |
   58|      2|  bool VisitCallExpr(CallExpr *CE) {
   59|       |    // Function calls may have side effects
   60|      2|    FoundSideEffect = true;
   61|      2|    SideEffectLoc = CE->getBeginLoc();
   62|      2|    SideEffectKind = "function call";
   63|      2|    return false;
   64|      2|  }
   65|       |
   66|       |  // LCOV_EXCL_START - C++ specific, same pattern as other side effect checks
   67|      0|  bool VisitCXXNewExpr(CXXNewExpr *NE) {
   68|      0|    FoundSideEffect = true;
   69|      0|    SideEffectLoc = NE->getBeginLoc();
   70|      0|    SideEffectKind = "new expression";
   71|      0|    return false;
   72|      0|  }
   73|       |
   74|      0|  bool VisitCXXDeleteExpr(CXXDeleteExpr *DE) {
   75|      0|    FoundSideEffect = true;
   76|      0|    SideEffectLoc = DE->getBeginLoc();
   77|      0|    SideEffectKind = "delete expression";
   78|      0|    return false;
   79|      0|  }
   80|       |  // LCOV_EXCL_STOP
   81|       |
   82|       |private:
   83|       |  bool FoundSideEffect = false;
   84|       |  SourceLocation SideEffectLoc;
   85|       |  StringRef SideEffectKind;
   86|       |};
   87|       |
   88|       |} // anonymous namespace
   89|       |
   90|    131|void AvoidSideEffectInSizeofCheck::registerMatchers(MatchFinder *Finder) {
   91|       |  // Match sizeof expressions with an argument expression (not just a type)
   92|    131|  Finder->addMatcher(unaryExprOrTypeTraitExpr(ofKind(UETT_SizeOf),
   93|    131|                                              hasArgumentOfType(anything()))
   94|    131|                         .bind("sizeof"),
   95|    131|                     this);
   96|    131|}
   97|       |
   98|       |void AvoidSideEffectInSizeofCheck::check(
   99|    302|    const MatchFinder::MatchResult &Result) {
  100|    302|  const auto *SizeofExpr =
  101|    302|      Result.Nodes.getNodeAs<UnaryExprOrTypeTraitExpr>("sizeof");
  102|    302|  if (!SizeofExpr)
  ------------------
  |  Branch (102:7): [True: 0, False: 302]
  ------------------
  103|      0|    return;
  104|       |
  105|       |  // Skip if in system header
  106|    302|  if (Result.SourceManager->isInSystemHeader(SizeofExpr->getBeginLoc()))
  ------------------
  |  Branch (106:7): [True: 213, False: 89]
  ------------------
  107|    213|    return;
  108|       |
  109|       |  // Check if this sizeof has an argument expression (not just a type)
  110|     89|  if (SizeofExpr->isArgumentType())
  ------------------
  |  Branch (110:7): [True: 23, False: 66]
  ------------------
  111|     23|    return; // sizeof(type) - no side effects possible
  112|       |
  113|     66|  const Expr *ArgExpr = SizeofExpr->getArgumentExpr();
  114|     66|  if (!ArgExpr)
  ------------------
  |  Branch (114:7): [True: 0, False: 66]
  ------------------
  115|      0|    return;
  116|       |
  117|       |  // Visit the argument expression to find side effects
  118|     66|  SideEffectFinder Finder;
  119|     66|  Finder.TraverseStmt(
  120|     66|      const_cast<Expr *>(ArgExpr)); // NOSONAR(S859): const_cast required by
  121|       |                                    // RecursiveASTVisitor API
  122|       |
  123|     66|  if (Finder.hasSideEffect()) {
  ------------------
  |  Branch (123:7): [True: 20, False: 46]
  ------------------
  124|     20|    diag(SizeofExpr->getBeginLoc(),
  125|     20|         "sizeof operand contains %0 which has potential side effects; "
  126|     20|         "these side effects will not be evaluated")
  127|     20|        << Finder.getSideEffectKind();
  128|     20|  }
  129|     66|}
  130|       |
  131|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidNonBooleanInConditionCheck.h:
    1|       |//===--- AvoidNonBooleanInConditionCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNONBOOLEANINCONDITIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNONBOOLEANINCONDITIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects non-boolean expressions used in conditional contexts.
   17|       |///
   18|       |/// Conditional expressions in if, while, for, and do-while statements should
   19|       |/// have boolean type. Using integer or pointer types in conditions relies on
   20|       |/// implicit conversion to boolean, which can obscure intent and make code
   21|       |/// less clear. Explicit comparisons improve readability.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 14.4 - The controlling expression of an if
   24|       |/// statement and the controlling expression of an iteration-statement shall
   25|       |/// have essentially Boolean type.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   int x;
   30|       |///   if (x) { }        // Warning: non-boolean in condition
   31|       |///   while (ptr) { }   // Warning: non-boolean in condition
   32|       |/// \endcode
   33|       |class AvoidNonBooleanInConditionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  AvoidNonBooleanInConditionCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidNonBooleanInConditionCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for conditional expressions.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched conditions and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDNONBOOLEANINCONDITIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidCompositeExpressionMismatchCheck.h:
    1|       |//===--- AvoidCompositeExpressionMismatchCheck.h - clang-tidy ---*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMPOSITEEXPRESSIONMISMATCHCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMPOSITEEXPRESSIONMISMATCHCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects composite expression type mismatches in assignments.
   18|       |///
   19|       |/// Implements MISRA Rules 10.6, 10.7, and 10.8:
   20|       |/// - 10.6: Composite expression shall not be assigned to wider type
   21|       |/// - 10.7: Composite expression shall not use operand of wider type
   22|       |/// - 10.8: Composite expression shall not be cast to different category
   23|       |///
   24|       |/// @par MISRA C:2025 Rules 10.6, 10.7, 10.8
   25|       |/// Composite expressions have an essential type that should be preserved.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   uint16_t a = 1000, b = 2000;
   31|       |///   uint32_t result = a + b;  // Warning: composite assigned to wider
   32|       |///   uint32_t c = (uint32_t)(a + b); // Warning: cast of composite
   33|       |/// @endcode
   34|       |class AvoidCompositeExpressionMismatchCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  AvoidCompositeExpressionMismatchCheck(StringRef Name,
   37|       |                                        ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidCompositeExpressionMismatchCheck() override = default;
   42|       |
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |
   46|       |private:
   47|       |  unsigned getTypeWidth(QualType Type, const ASTContext &Ctx) const;
   48|       |  bool isCompositeExpression(const Expr *E) const;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMPOSITEEXPRESSIONMISMATCHCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidConstantWrapAroundCheck.cpp:
    1|       |//===--- AvoidConstantWrapAroundCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidConstantWrapAroundCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/Expr.h"
   12|       |#include "clang/AST/RecursiveASTVisitor.h"
   13|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   14|       |#include "llvm/ADT/APInt.h"
   15|       |
   16|       |using namespace clang::ast_matchers;
   17|       |
   18|       |namespace clang::tidy::automotive {
   19|       |
   20|       |namespace {
   21|       |
   22|       |/// Helper to evaluate both operands of a binary expression.
   23|       |/// Returns true if both operands evaluate to integer constants.
   24|       |bool evaluateBinaryOperands(BinaryOperator *BO, ASTContext &Context,
   25|     12|                            llvm::APSInt &LHSVal, llvm::APSInt &RHSVal) {
   26|     12|  Expr::EvalResult LHS;
   27|     12|  Expr::EvalResult RHS;
   28|     12|  if (!BO->getLHS()->EvaluateAsRValue(LHS, Context) ||
  ------------------
  |  Branch (28:7): [True: 0, False: 12]
  ------------------
   29|     12|      !BO->getRHS()->EvaluateAsRValue(RHS, Context))
  ------------------
  |  Branch (29:7): [True: 0, False: 12]
  ------------------
   30|      0|    return false;
   31|       |
   32|     12|  if (!LHS.Val.isInt() || !RHS.Val.isInt())
  ------------------
  |  Branch (32:7): [True: 0, False: 12]
  |  Branch (32:27): [True: 0, False: 12]
  ------------------
   33|      0|    return false;
   34|       |
   35|     12|  LHSVal = LHS.Val.getInt();
   36|     12|  RHSVal = RHS.Val.getInt();
   37|     12|  return true;
   38|     12|}
   39|       |
   40|       |/// Check if subtraction wraps around (LHS < RHS for unsigned).
   41|      4|bool checkSubtractionWrapAround(BinaryOperator *BO, ASTContext &Context) {
   42|      4|  llvm::APSInt LHSVal;
   43|      4|  llvm::APSInt RHSVal;
   44|      4|  if (!evaluateBinaryOperands(BO, Context, LHSVal, RHSVal))
  ------------------
  |  Branch (44:7): [True: 0, False: 4]
  ------------------
   45|      0|    return false;
   46|       |
   47|      4|  return LHSVal.ult(RHSVal);
   48|      4|}
   49|       |
   50|       |/// Check if addition wraps around (result < either operand for unsigned).
   51|      5|bool checkAdditionWrapAround(BinaryOperator *BO, ASTContext &Context) {
   52|      5|  Expr::EvalResult Result;
   53|      5|  if (!BO->EvaluateAsRValue(Result, Context) || !Result.Val.isInt())
  ------------------
  |  Branch (53:7): [True: 0, False: 5]
  |  Branch (53:49): [True: 0, False: 5]
  ------------------
   54|      0|    return false;
   55|       |
   56|      5|  llvm::APSInt LHSVal;
   57|      5|  llvm::APSInt RHSVal;
   58|      5|  if (!evaluateBinaryOperands(BO, Context, LHSVal, RHSVal))
  ------------------
  |  Branch (58:7): [True: 0, False: 5]
  ------------------
   59|      0|    return false;
   60|       |
   61|      5|  const llvm::APSInt &ResultVal = Result.Val.getInt();
   62|      5|  return ResultVal.ult(LHSVal) || ResultVal.ult(RHSVal);
  ------------------
  |  Branch (62:10): [True: 2, False: 3]
  |  Branch (62:35): [True: 0, False: 3]
  ------------------
   63|      5|}
   64|       |
   65|       |/// Check if multiplication wraps around (result/lhs != rhs).
   66|      3|bool checkMultiplicationWrapAround(BinaryOperator *BO, ASTContext &Context) {
   67|      3|  Expr::EvalResult Result;
   68|      3|  if (!BO->EvaluateAsRValue(Result, Context) || !Result.Val.isInt())
  ------------------
  |  Branch (68:7): [True: 0, False: 3]
  |  Branch (68:49): [True: 0, False: 3]
  ------------------
   69|      0|    return false;
   70|       |
   71|      3|  llvm::APSInt LHSVal;
   72|      3|  llvm::APSInt RHSVal;
   73|      3|  if (!evaluateBinaryOperands(BO, Context, LHSVal, RHSVal))
  ------------------
  |  Branch (73:7): [True: 0, False: 3]
  ------------------
   74|      0|    return false;
   75|       |
   76|      3|  if (LHSVal.isZero() || RHSVal.isZero())
  ------------------
  |  Branch (76:7): [True: 0, False: 3]
  |  Branch (76:26): [True: 0, False: 3]
  ------------------
   77|      0|    return false;
   78|       |
   79|      3|  const llvm::APSInt &ResultVal = Result.Val.getInt();
   80|      3|  llvm::APInt QuotientInt = ResultVal.udiv(LHSVal);
   81|      3|  llvm::APSInt Quotient(QuotientInt, /*isUnsigned=*/true);
   82|      3|  return Quotient != RHSVal;
   83|      3|}
   84|       |
   85|       |/// Visitor to check for wrap-around in binary and unary operations
   86|       |class WrapAroundChecker : public RecursiveASTVisitor<WrapAroundChecker> {
   87|       |public:
   88|     15|  explicit WrapAroundChecker(ASTContext &Context) : Context(Context) {}
   89|       |
   90|     15|  bool foundWrapAround() const { return FoundWrapAround; }
   91|      6|  SourceLocation getWrapAroundLoc() const { return WrapAroundLoc; }
   92|       |
   93|     12|  bool VisitBinaryOperator(BinaryOperator *BO) {
   94|     12|    if (!BO->getType()->isUnsignedIntegerType())
  ------------------
  |  Branch (94:9): [True: 0, False: 12]
  ------------------
   95|      0|      return true;
   96|       |
   97|     12|    bool HasWrapAround = false;
   98|     12|    switch (BO->getOpcode()) {
   99|      4|    case BO_Sub:
  ------------------
  |  Branch (99:5): [True: 4, False: 8]
  ------------------
  100|      4|      HasWrapAround = checkSubtractionWrapAround(BO, Context);
  101|      4|      break;
  102|      5|    case BO_Add:
  ------------------
  |  Branch (102:5): [True: 5, False: 7]
  ------------------
  103|      5|      HasWrapAround = checkAdditionWrapAround(BO, Context);
  104|      5|      break;
  105|      3|    case BO_Mul:
  ------------------
  |  Branch (105:5): [True: 3, False: 9]
  ------------------
  106|      3|      HasWrapAround = checkMultiplicationWrapAround(BO, Context);
  107|      3|      break;
  108|      0|    default:
  ------------------
  |  Branch (108:5): [True: 0, False: 12]
  ------------------
  109|      0|      return true;
  110|     12|    }
  111|       |
  112|     12|    if (HasWrapAround) {
  ------------------
  |  Branch (112:9): [True: 4, False: 8]
  ------------------
  113|      4|      FoundWrapAround = true;
  114|      4|      WrapAroundLoc = BO->getOperatorLoc();
  115|      4|      return false;
  116|      4|    }
  117|      8|    return true;
  118|     12|  }
  119|       |
  120|      3|  bool VisitUnaryOperator(UnaryOperator *UO) {
  121|      3|    if (UO->getOpcode() != UO_Minus)
  ------------------
  |  Branch (121:9): [True: 0, False: 3]
  ------------------
  122|      0|      return true;
  123|      3|    if (!UO->getType()->isUnsignedIntegerType())
  ------------------
  |  Branch (123:9): [True: 0, False: 3]
  ------------------
  124|      0|      return true;
  125|       |
  126|      3|    Expr::EvalResult Operand;
  127|      3|    if (!UO->getSubExpr()->EvaluateAsRValue(Operand, Context))
  ------------------
  |  Branch (127:9): [True: 0, False: 3]
  ------------------
  128|      0|      return true;
  129|       |
  130|      3|    if (Operand.Val.isInt() && !Operand.Val.getInt().isZero()) {
  ------------------
  |  Branch (130:9): [True: 3, False: 0]
  |  Branch (130:32): [True: 2, False: 1]
  ------------------
  131|      2|      FoundWrapAround = true;
  132|      2|      WrapAroundLoc = UO->getOperatorLoc();
  133|      2|      return false;
  134|      2|    }
  135|      1|    return true;
  136|      3|  }
  137|       |
  138|       |private:
  139|       |  ASTContext &Context;
  140|       |  bool FoundWrapAround = false;
  141|       |  SourceLocation WrapAroundLoc;
  142|       |};
  143|       |
  144|       |} // anonymous namespace
  145|       |
  146|    131|void AvoidConstantWrapAroundCheck::registerMatchers(MatchFinder *Finder) {
  147|       |  // Match variable declarations with initializers that are constant expressions
  148|    131|  Finder->addMatcher(
  149|    131|      varDecl(hasInitializer(expr().bind("init")), isDefinition()).bind("var"),
  150|    131|      this);
  151|    131|}
  152|       |
  153|       |void AvoidConstantWrapAroundCheck::check(
  154|  2.39k|    const MatchFinder::MatchResult &Result) {
  155|  2.39k|  const auto *VD = Result.Nodes.getNodeAs<VarDecl>("var");
  156|  2.39k|  const auto *InitExpr = Result.Nodes.getNodeAs<Expr>("init");
  157|       |
  158|  2.39k|  if (!VD || !InitExpr)
  ------------------
  |  Branch (158:7): [True: 0, False: 2.39k]
  |  Branch (158:14): [True: 0, False: 2.39k]
  ------------------
  159|      0|    return;
  160|       |
  161|       |  // Skip if in system header
  162|  2.39k|  if (Result.SourceManager->isInSystemHeader(VD->getLocation()))
  ------------------
  |  Branch (162:7): [True: 1.45k, False: 934]
  ------------------
  163|  1.45k|    return;
  164|       |
  165|       |  // Only check const variables or those in file scope (likely constants)
  166|    934|  if (!VD->getType().isConstQualified() && !VD->hasGlobalStorage())
  ------------------
  |  Branch (166:7): [True: 908, False: 26]
  |  Branch (166:7): [True: 866, False: 68]
  |  Branch (166:44): [True: 866, False: 42]
  ------------------
  167|    866|    return;
  168|       |
  169|       |  // Only check unsigned integer types
  170|     68|  QualType Type = VD->getType();
  171|     68|  if (!Type->isUnsignedIntegerType())
  ------------------
  |  Branch (171:7): [True: 53, False: 15]
  ------------------
  172|     53|    return;
  173|       |
  174|       |  // Check if the initializer can be evaluated as a constant
  175|     15|  Expr::EvalResult EvalResult;
  176|     15|  if (!InitExpr->EvaluateAsRValue(EvalResult, *Result.Context))
  ------------------
  |  Branch (176:7): [True: 0, False: 15]
  ------------------
  177|      0|    return;
  178|       |
  179|       |  // Walk the initializer to find wrap-around operations
  180|     15|  WrapAroundChecker Checker(*Result.Context);
  181|     15|  Checker.TraverseStmt(
  182|     15|      const_cast<Expr *>(InitExpr)); // NOSONAR(S859): const_cast required by
  183|       |                                     // RecursiveASTVisitor API
  184|       |
  185|     15|  if (Checker.foundWrapAround()) {
  ------------------
  |  Branch (185:7): [True: 6, False: 9]
  ------------------
  186|      6|    diag(
  187|      6|        Checker.getWrapAroundLoc(),
  188|      6|        "constant expression evaluation leads to unsigned integer wrap-around");
  189|      6|  }
  190|     15|}
  191|       |
  192|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidSideEffectInInitializerCheck.cpp:
    1|       |//===--- AvoidSideEffectInInitializerCheck.cpp - clang-tidy ---------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSideEffectInInitializerCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/RecursiveASTVisitor.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |class SideEffectCounter : public RecursiveASTVisitor<SideEffectCounter> {
   21|       |public:
   22|  1.25k|  unsigned getCount() const { return Count; }
   23|    429|  bool hasSideEffect() const { return Count > 0; }
   24|       |
   25|     20|  bool VisitUnaryOperator(UnaryOperator *UO) {
   26|     20|    if (UO->isIncrementDecrementOp())
  ------------------
  |  Branch (26:9): [True: 8, False: 12]
  ------------------
   27|      8|      Count++;
   28|     20|    return true;
   29|     20|  }
   30|       |
   31|     58|  bool VisitBinaryOperator(BinaryOperator *BO) {
   32|     58|    if (BO->isAssignmentOp())
  ------------------
  |  Branch (32:9): [True: 16, False: 42]
  ------------------
   33|     16|      Count++;
   34|     58|    return true;
   35|     58|  }
   36|       |
   37|     14|  bool VisitCallExpr(CallExpr *) {
   38|     14|    Count++;
   39|     14|    return true;
   40|     14|  }
   41|       |
   42|       |private:
   43|       |  unsigned Count = 0;
   44|       |};
   45|       |
   46|       |} // namespace
   47|       |
   48|    131|void AvoidSideEffectInInitializerCheck::registerMatchers(MatchFinder *Finder) {
   49|       |  // Match initializer lists
   50|    131|  Finder->addMatcher(initListExpr().bind("initlist"), this);
   51|       |
   52|       |  // Match expressions with multiple side effects (unsequenced)
   53|    131|  Finder->addMatcher(
   54|    131|      binaryOperator(unless(isAssignmentOperator())).bind("binexpr"), this);
   55|    131|}
   56|       |
   57|       |void AvoidSideEffectInInitializerCheck::check(
   58|  3.09k|    const MatchFinder::MatchResult &Result) {
   59|       |  // Rule 13.1: Side effects in initializer lists
   60|  3.09k|  if (const auto *InitList = Result.Nodes.getNodeAs<InitListExpr>("initlist")) {
  ------------------
  |  Branch (60:19): [True: 441, False: 2.64k]
  ------------------
   61|    441|    if (Result.SourceManager->isInSystemHeader(InitList->getBeginLoc()))
  ------------------
  |  Branch (61:9): [True: 278, False: 163]
  ------------------
   62|    278|      return;
   63|       |
   64|    429|    for (const Expr *Init : InitList->inits()) {
  ------------------
  |  Branch (64:27): [True: 429, False: 161]
  ------------------
   65|    429|      if (hasSideEffect(Init)) {
  ------------------
  |  Branch (65:11): [True: 2, False: 427]
  ------------------
   66|      2|        diag(Init->getBeginLoc(),
   67|      2|             "initializer list element contains side effects which may not "
   68|      2|             "be evaluated in the expected order");
   69|      2|        return;
   70|      2|      }
   71|    429|    }
   72|    161|    return;
   73|    163|  }
   74|       |
   75|       |  // Rules 13.2, 13.3: Multiple unsequenced side effects
   76|  2.64k|  if (const auto *BinExpr = Result.Nodes.getNodeAs<BinaryOperator>("binexpr")) {
  ------------------
  |  Branch (76:19): [True: 2.64k, False: 0]
  ------------------
   77|  2.64k|    if (Result.SourceManager->isInSystemHeader(BinExpr->getOperatorLoc()))
  ------------------
  |  Branch (77:9): [True: 2.02k, False: 625]
  ------------------
   78|  2.02k|      return;
   79|       |
   80|    625|    unsigned LHSCount = countSideEffects(BinExpr->getLHS());
   81|    625|    unsigned RHSCount = countSideEffects(BinExpr->getRHS());
   82|       |
   83|    625|    if (LHSCount > 0 && RHSCount > 0) {
  ------------------
  |  Branch (83:9): [True: 18, False: 607]
  |  Branch (83:25): [True: 2, False: 16]
  ------------------
   84|      2|      diag(BinExpr->getOperatorLoc(),
   85|      2|           "expression contains multiple side effects with unspecified "
   86|      2|           "evaluation order");
   87|    623|    } else if (LHSCount > 1 || RHSCount > 1) {
  ------------------
  |  Branch (87:16): [True: 2, False: 621]
  |  Branch (87:32): [True: 4, False: 617]
  ------------------
   88|      6|      diag(BinExpr->getOperatorLoc(),
   89|      6|           "sub-expression contains multiple side effects");
   90|      6|    }
   91|    625|  }
   92|  2.64k|}
   93|       |
   94|    429|bool AvoidSideEffectInInitializerCheck::hasSideEffect(const Expr *E) const {
   95|    429|  SideEffectCounter Counter;
   96|       |  // NOSONAR(S859): const_cast required by RecursiveASTVisitor API
   97|    429|  Counter.TraverseStmt(const_cast<Expr *>(E));
   98|    429|  return Counter.hasSideEffect();
   99|    429|}
  100|       |
  101|       |unsigned
  102|  1.25k|AvoidSideEffectInInitializerCheck::countSideEffects(const Expr *E) const {
  103|  1.25k|  SideEffectCounter Counter;
  104|       |  // NOSONAR(S859): const_cast required by RecursiveASTVisitor API
  105|  1.25k|  Counter.TraverseStmt(const_cast<Expr *>(E));
  106|  1.25k|  return Counter.getCount();
  107|  1.25k|}
  108|       |
  109|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidInappropriateCastCheck.h:
    1|       |//===--- AvoidInappropriateCastCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATECASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATECASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-expression
   17|       |/// @brief Detects inappropriate casts between essential type categories.
   18|       |///
   19|       |/// Implements MISRA Rule 10.5: The value of an expression should not be cast
   20|       |/// to an inappropriate essential type.
   21|       |///
   22|       |/// @par MISRA C:2025 Rule 10.5
   23|       |/// Casts to inappropriate types indicate design issues.
   24|       |/// @par Category: Advisory
   25|       |///
   26|       |/// Example:
   27|       |/// @code
   28|       |///   int x = 65;
   29|       |///   char c = (char)x;     // Warning: signed to character cast
   30|       |///   bool b = (bool)x;     // Warning: integer to boolean cast
   31|       |/// @endcode
   32|       |class AvoidInappropriateCastCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  AvoidInappropriateCastCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|       |  /// Destructor.
   38|    131|  ~AvoidInappropriateCastCheck() override = default;
   39|       |
   40|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   41|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   42|       |
   43|       |private:
   44|       |  enum class EssentialType {
   45|       |    Boolean,
   46|       |    Character,
   47|       |    SignedInt,
   48|       |    UnsignedInt,
   49|       |    FloatingPoint,
   50|       |    Enum,
   51|       |    Other
   52|       |  };
   53|       |
   54|       |  EssentialType getEssentialType(QualType Type) const;
   55|       |  bool isInappropriateCast(EssentialType From, EssentialType To) const;
   56|       |  static const char *essentialTypeToString(EssentialType ET);
   57|       |};
   58|       |
   59|       |} // namespace clang::tidy::automotive
   60|       |
   61|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINAPPROPRIATECASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/expression/ExpressionComponent.cpp:
    1|       |//===--- ExpressionComponent.cpp - clang-tidy -----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ExpressionComponent.h"
   10|       |#include "AvoidAssignmentInExpressionCheck.h"
   11|       |#include "AvoidCharacterArithmeticCheck.h"
   12|       |#include "AvoidCompositeExpressionMismatchCheck.h"
   13|       |#include "AvoidConstantWrapAroundCheck.h"
   14|       |#include "AvoidEssentialTypeMismatchCheck.h"
   15|       |#include "AvoidInappropriateCastCheck.h"
   16|       |#include "AvoidInappropriateEssentialTypeCheck.h"
   17|       |#include "AvoidNarrowingCompoundAssignmentCheck.h"
   18|       |#include "AvoidNonBooleanInConditionCheck.h"
   19|       |#include "AvoidSideEffectInInitializerCheck.h"
   20|       |#include "AvoidSideEffectInLogicalOperandCheck.h"
   21|       |#include "AvoidSideEffectInSizeofCheck.h"
   22|       |#include "InvariantControlCheck.h"
   23|       |
   24|       |namespace clang::tidy::automotive {
   25|       |
   26|       |void ExpressionComponent::addCheckFactories(
   27|    262|    ClangTidyCheckFactories &CheckFactories) {
   28|       |
   29|       |  // Rule 10.1 - Inappropriate essential type (Required)
   30|    262|  CheckFactories.registerCheck<AvoidInappropriateEssentialTypeCheck>(
   31|    262|      "automotive-c23-req-10.1");
   32|       |
   33|       |  // Rule 10.2 - Character arithmetic (Required)
   34|    262|  CheckFactories.registerCheck<AvoidCharacterArithmeticCheck>(
   35|    262|      "automotive-c23-req-10.2");
   36|       |
   37|       |  // Rule 10.3 - Narrowing assignment (Required)
   38|    262|  CheckFactories.registerCheck<AvoidNarrowingCompoundAssignmentCheck>(
   39|    262|      "automotive-c23-req-10.3");
   40|       |
   41|       |  // Rule 10.4 - Essential type mismatch (Required)
   42|    262|  CheckFactories.registerCheck<AvoidEssentialTypeMismatchCheck>(
   43|    262|      "automotive-c23-req-10.4");
   44|       |
   45|       |  // Rule 10.5 - Inappropriate cast (Advisory)
   46|    262|  CheckFactories.registerCheck<AvoidInappropriateCastCheck>(
   47|    262|      "automotive-c23-adv-10.5");
   48|       |
   49|       |  // Rules 10.6, 10.7, 10.8 - Composite expression mismatch (Required)
   50|    262|  CheckFactories.registerCheck<AvoidCompositeExpressionMismatchCheck>(
   51|    262|      "automotive-c23-req-10.6");
   52|       |
   53|       |  // Rule 12.4 - Constant expression wrap-around (Advisory)
   54|    262|  CheckFactories.registerCheck<AvoidConstantWrapAroundCheck>(
   55|    262|      "automotive-c23-adv-12.4");
   56|       |
   57|       |  // Rules 13.1, 13.2, 13.3 - Side effects in initializers (Required)
   58|    262|  CheckFactories.registerCheck<AvoidSideEffectInInitializerCheck>(
   59|    262|      "automotive-c23-req-13.1");
   60|       |
   61|       |  // Rule 13.4 - Assignment used as expression (Advisory)
   62|    262|  CheckFactories.registerCheck<AvoidAssignmentInExpressionCheck>(
   63|    262|      "automotive-c23-adv-13.4");
   64|       |
   65|       |  // Rule 13.5 - Side effects in logical operator operands (Required)
   66|    262|  CheckFactories.registerCheck<AvoidSideEffectInLogicalOperandCheck>(
   67|    262|      "automotive-c23-req-13.5");
   68|       |
   69|       |  // Rule 13.6 - Side effects in sizeof operand (Mandatory)
   70|    262|  CheckFactories.registerCheck<AvoidSideEffectInSizeofCheck>(
   71|    262|      "automotive-c23-mand-13.6");
   72|       |
   73|       |  // Rule 14.3 - Invariant controlling expression (Required)
   74|    262|  CheckFactories.registerCheck<InvariantControlCheck>(
   75|    262|      "automotive-c23-req-14.3");
   76|       |
   77|       |  // Rule 14.4 - Non-boolean in condition (Required)
   78|    262|  CheckFactories.registerCheck<AvoidNonBooleanInConditionCheck>(
   79|    262|      "automotive-c23-req-14.4");
   80|    262|}
   81|       |
   82|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/expression/AvoidCompositeExpressionMismatchCheck.cpp:
    1|       |//===--- AvoidCompositeExpressionMismatchCheck.cpp - clang-tidy -----------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCompositeExpressionMismatchCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void AvoidCompositeExpressionMismatchCheck::registerMatchers(
   18|    131|    MatchFinder *Finder) {
   19|       |  // Match assignments where RHS is an arithmetic expression
   20|       |  // Use ignoringParenImpCasts to skip the implicit cast that wraps the result
   21|    131|  Finder->addMatcher(
   22|    131|      binaryOperator(
   23|    131|          isAssignmentOperator(),
   24|    131|          hasRHS(ignoringParenImpCasts(
   25|    131|              binaryOperator(
   26|    131|                  anyOf(hasAnyOperatorName("+", "-", "*", "/", "%"),
   27|    131|                        hasAnyOperatorName("&", "|", "^", "<<", ">>")))
   28|    131|                  .bind("composite"))))
   29|    131|          .bind("assign"),
   30|    131|      this);
   31|       |
   32|       |  // Match casts of composite expressions
   33|       |  // Use ignoringParenImpCasts for the cast source expression too
   34|    131|  Finder->addMatcher(
   35|    131|      cStyleCastExpr(
   36|    131|          hasSourceExpression(ignoringParenImpCasts(
   37|    131|              binaryOperator(
   38|    131|                  anyOf(hasAnyOperatorName("+", "-", "*", "/", "%"),
   39|    131|                        hasAnyOperatorName("&", "|", "^", "<<", ">>")))
   40|    131|                  .bind("castcomposite"))))
   41|    131|          .bind("cast"),
   42|    131|      this);
   43|    131|}
   44|       |
   45|       |void AvoidCompositeExpressionMismatchCheck::check(
   46|    209|    const MatchFinder::MatchResult &Result) {
   47|       |  // Rule 10.6: Composite expression assigned to wider type
   48|    209|  if (const auto *Assign = Result.Nodes.getNodeAs<BinaryOperator>("assign")) {
  ------------------
  |  Branch (48:19): [True: 191, False: 18]
  ------------------
   49|    191|    if (Result.SourceManager->isInSystemHeader(Assign->getOperatorLoc()))
  ------------------
  |  Branch (49:9): [True: 50, False: 141]
  ------------------
   50|     50|      return;
   51|       |
   52|    141|    const auto *Composite = Result.Nodes.getNodeAs<BinaryOperator>("composite");
   53|    141|    if (!Composite)
  ------------------
  |  Branch (53:9): [True: 0, False: 141]
  ------------------
   54|      0|      return;
   55|       |
   56|    141|    unsigned LHSWidth =
   57|    141|        getTypeWidth(Assign->getLHS()->getType(), *Result.Context);
   58|    141|    unsigned RHSWidth = getTypeWidth(Composite->getType(), *Result.Context);
   59|       |
   60|    141|    if (LHSWidth > RHSWidth) {
  ------------------
  |  Branch (60:9): [True: 7, False: 134]
  ------------------
   61|      7|      diag(Assign->getOperatorLoc(),
   62|      7|           "composite expression with narrower type assigned to object with "
   63|      7|           "wider type; computation may lose precision before widening");
   64|      7|    }
   65|    141|    return;
   66|    141|  }
   67|       |
   68|       |  // Rule 10.8: Cast of composite expression
   69|     18|  if (const auto *Cast = Result.Nodes.getNodeAs<CStyleCastExpr>("cast")) {
  ------------------
  |  Branch (69:19): [True: 18, False: 0]
  ------------------
   70|     18|    if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (70:9): [True: 10, False: 8]
  ------------------
   71|     10|      return;
   72|       |
   73|      8|    const auto *Composite =
   74|      8|        Result.Nodes.getNodeAs<BinaryOperator>("castcomposite");
   75|      8|    if (!Composite)
  ------------------
  |  Branch (75:9): [True: 0, False: 8]
  ------------------
   76|      0|      return;
   77|       |
   78|      8|    QualType FromType = Composite->getType();
   79|      8|    QualType ToType = Cast->getType();
   80|       |
   81|      8|    unsigned FromWidth = getTypeWidth(FromType, *Result.Context);
   82|      8|    unsigned ToWidth = getTypeWidth(ToType, *Result.Context);
   83|       |
   84|      8|    if (ToWidth > FromWidth) {
  ------------------
  |  Branch (84:9): [True: 3, False: 5]
  ------------------
   85|      3|      diag(Cast->getBeginLoc(),
   86|      3|           "cast of composite expression to wider type; computation may lose "
   87|      3|           "precision before cast");
   88|      3|    }
   89|      8|  }
   90|     18|}
   91|       |
   92|       |unsigned AvoidCompositeExpressionMismatchCheck::getTypeWidth(
   93|    298|    QualType Type, const ASTContext &Ctx) const {
   94|    298|  Type = Type.getCanonicalType();
   95|    298|  if (Type->isIntegerType() || Type->isFloatingType())
  ------------------
  |  Branch (95:7): [True: 287, False: 11]
  |  Branch (95:32): [True: 0, False: 11]
  ------------------
   96|    287|    return Ctx.getTypeSize(Type);
   97|     11|  return 0;
   98|    298|}
   99|       |
  100|       |bool AvoidCompositeExpressionMismatchCheck::isCompositeExpression(
  101|      0|    const Expr *E) const {
  102|      0|  if (const auto *BinOp = dyn_cast<BinaryOperator>(E))
  ------------------
  |  Branch (102:19): [True: 0, False: 0]
  ------------------
  103|      0|    return BinOp->isAdditiveOp() || BinOp->isMultiplicativeOp() ||
  ------------------
  |  Branch (103:12): [True: 0, False: 0]
  |  Branch (103:37): [True: 0, False: 0]
  ------------------
  104|      0|           BinOp->isBitwiseOp() || BinOp->isShiftOp();
  ------------------
  |  Branch (104:12): [True: 0, False: 0]
  |  Branch (104:36): [True: 0, False: 0]
  ------------------
  105|      0|  return false;
  106|      0|}
  107|       |
  108|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/utils/ASTMatchers.h:
    1|       |//===--- ASTMatchers.h - clang-tidy -----------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ASTMATCHERS_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ASTMATCHERS_H
   11|       |
   12|       |#include "clang/ASTMatchers/ASTMatchers.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |namespace ast_matchers {
   17|       |
   18|       |// NOSONAR: using-directive required to make base AST matchers available for
   19|       |// custom matcher definitions
   20|       |using namespace clang::ast_matchers;
   21|       |
   22|       |static bool isEssentiallyBooleanHelper(const Expr &Node);
   23|       |
   24|  96.1k|AST_MATCHER(QualType, isRestrictType) {
   25|  96.1k|  return Node.getLocalQualifiers().hasRestrict();
   26|  96.1k|}
   27|       |
   28|     73|AST_MATCHER(SwitchStmt, hasDefaultStmt) {
   29|    116|  for (const SwitchCase *SC = Node.getSwitchCaseList(); SC;
  ------------------
  |  Branch (29:57): [True: 95, False: 21]
  ------------------
   30|     95|       SC = SC->getNextSwitchCase()) {
   31|     95|    if (llvm::isa<DefaultStmt>(SC)) {
  ------------------
  |  Branch (31:9): [True: 52, False: 43]
  ------------------
   32|     52|      return true;
   33|     52|    }
   34|     95|  }
   35|     21|  return false;
   36|     73|}
   37|       |
   38|  1.46k|static bool isEssentiallyBooleanHelper(const Expr &Node) {
   39|  1.46k|  QualType Type = Node.getType();
   40|       |
   41|       |  // Direct Boolean type check (_Bool in C99+).
   42|  1.46k|  if (Type->isBooleanType()) {
  ------------------
  |  Branch (42:7): [True: 571, False: 896]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
  |  Branch (42:7): [True: 0, False: 0]
  ------------------
   43|    571|    return true;
   44|    571|  }
   45|       |
   46|       |  // Handle binary operators that inherently return boolean values.
   47|       |  // This includes comparison operators (==, !=, <, >, <=, >=)
   48|       |  // and logical operators (&&, ||), which are commonly used in conditions.
   49|    896|  if (const auto *BinaryOp = dyn_cast<BinaryOperator>(&Node)) {
  ------------------
  |  Branch (49:19): [True: 308, False: 588]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
  |  Branch (49:19): [True: 0, False: 0]
  ------------------
   50|    308|    return BinaryOp->isComparisonOp() || BinaryOp->isLogicalOp();
  ------------------
  |  Branch (50:12): [True: 219, False: 89]
  |  Branch (50:42): [True: 86, False: 3]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
  |  Branch (50:12): [True: 0, False: 0]
  |  Branch (50:42): [True: 0, False: 0]
  ------------------
   51|    308|  }
   52|       |
   53|       |  // Handle logical negation (!x), which is commonly used in conditional
   54|       |  // expressions.
   55|    588|  if (const auto *UnaryOp = dyn_cast<UnaryOperator>(&Node)) {
  ------------------
  |  Branch (55:19): [True: 50, False: 538]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
  |  Branch (55:19): [True: 0, False: 0]
  ------------------
   56|     50|    return UnaryOp->getOpcode() == UO_LNot;
   57|     50|  }
   58|       |
   59|       |  // Handle parenthesized expressions, such as switch ((x == 0)).
   60|       |  // Recursively check the inner expression.
   61|    538|  if (const auto *Paren = dyn_cast<ParenExpr>(&Node)) {
  ------------------
  |  Branch (61:19): [True: 1, False: 537]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
  |  Branch (61:19): [True: 0, False: 0]
  ------------------
   62|      1|    return isEssentiallyBooleanHelper(*Paren->getSubExpr());
   63|      1|  }
   64|       |
   65|       |  // Handle implicit casts to boolean, such as (bool)x.
   66|    537|  if (const auto *Cast = dyn_cast<ImplicitCastExpr>(&Node)) {
  ------------------
  |  Branch (66:19): [True: 79, False: 458]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
  |  Branch (66:19): [True: 0, False: 0]
  ------------------
   67|     79|    return isEssentiallyBooleanHelper(*Cast->getSubExpr());
   68|     79|  }
   69|       |
   70|       |  // If none of the above conditions match, the expression is not essentially
   71|       |  // Boolean.
   72|    458|  return false;
   73|    537|}
  ------------------
  | AvoidPartialArrayInitCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE:
  |   38|  1.46k|static bool isEssentiallyBooleanHelper(const Expr &Node) {
  |   39|  1.46k|  QualType Type = Node.getType();
  |   40|       |
  |   41|       |  // Direct Boolean type check (_Bool in C99+).
  |   42|  1.46k|  if (Type->isBooleanType()) {
  |  ------------------
  |  |  Branch (42:7): [True: 571, False: 896]
  |  ------------------
  |   43|    571|    return true;
  |   44|    571|  }
  |   45|       |
  |   46|       |  // Handle binary operators that inherently return boolean values.
  |   47|       |  // This includes comparison operators (==, !=, <, >, <=, >=)
  |   48|       |  // and logical operators (&&, ||), which are commonly used in conditions.
  |   49|    896|  if (const auto *BinaryOp = dyn_cast<BinaryOperator>(&Node)) {
  |  ------------------
  |  |  Branch (49:19): [True: 308, False: 588]
  |  ------------------
  |   50|    308|    return BinaryOp->isComparisonOp() || BinaryOp->isLogicalOp();
  |  ------------------
  |  |  Branch (50:12): [True: 219, False: 89]
  |  |  Branch (50:42): [True: 86, False: 3]
  |  ------------------
  |   51|    308|  }
  |   52|       |
  |   53|       |  // Handle logical negation (!x), which is commonly used in conditional
  |   54|       |  // expressions.
  |   55|    588|  if (const auto *UnaryOp = dyn_cast<UnaryOperator>(&Node)) {
  |  ------------------
  |  |  Branch (55:19): [True: 50, False: 538]
  |  ------------------
  |   56|     50|    return UnaryOp->getOpcode() == UO_LNot;
  |   57|     50|  }
  |   58|       |
  |   59|       |  // Handle parenthesized expressions, such as switch ((x == 0)).
  |   60|       |  // Recursively check the inner expression.
  |   61|    538|  if (const auto *Paren = dyn_cast<ParenExpr>(&Node)) {
  |  ------------------
  |  |  Branch (61:19): [True: 1, False: 537]
  |  ------------------
  |   62|      1|    return isEssentiallyBooleanHelper(*Paren->getSubExpr());
  |   63|      1|  }
  |   64|       |
  |   65|       |  // Handle implicit casts to boolean, such as (bool)x.
  |   66|    537|  if (const auto *Cast = dyn_cast<ImplicitCastExpr>(&Node)) {
  |  ------------------
  |  |  Branch (66:19): [True: 79, False: 458]
  |  ------------------
  |   67|     79|    return isEssentiallyBooleanHelper(*Cast->getSubExpr());
  |   68|     79|  }
  |   69|       |
  |   70|       |  // If none of the above conditions match, the expression is not essentially
  |   71|       |  // Boolean.
  |   72|    458|  return false;
  |   73|    537|}
  ------------------
  | Unexecuted instantiation: AvoidAssignmentInExpressionCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
  | Unexecuted instantiation: AvoidNonBooleanInConditionCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
  | Unexecuted instantiation: MissingDefaultInSwitchStmtCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
  | Unexecuted instantiation: AvoidBooleanInSwitchCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
  | Unexecuted instantiation: MissingCompoundStmtCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
  | Unexecuted instantiation: AvoidRestrictTypeCheck.cpp:_ZN5clang4tidy10automotive12ast_matchersL26isEssentiallyBooleanHelperERKNS_4ExprE
  ------------------
   74|       |
   75|  1.38k|AST_MATCHER(Expr, isEssentiallyBoolean) {
   76|  1.38k|  return isEssentiallyBooleanHelper(Node);
   77|  1.38k|}
   78|       |
   79|    938|AST_MATCHER(BinaryOperator, isAssignmentResultUsed) {
   80|    938|  const auto *Parent = Finder->getASTContext().getParents(Node)[0].get<Stmt>();
   81|    938|  if (!Parent) {
  ------------------
  |  Branch (81:7): [True: 0, False: 938]
  ------------------
   82|      0|    return false;
   83|      0|  }
   84|    938|  return isa<Expr>(Parent);
   85|    938|}
   86|       |
   87|       |AST_MATCHER_P(SwitchStmt, hasBody, clang::ast_matchers::internal::Matcher<Stmt>,
   88|     73|              InnerMatcher) {
   89|     73|  const Stmt *const Body = Node.getBody();
   90|     73|  return (Body != nullptr && InnerMatcher.matches(*Body, Finder, Builder));
  ------------------
  |  Branch (90:11): [True: 73, False: 0]
  |  Branch (90:30): [True: 0, False: 73]
  ------------------
   91|     73|}
   92|       |
   93|     71|AST_MATCHER(InitListExpr, isZeroInitializer) {
   94|     71|  return Node.getNumInits() == 1 &&
  ------------------
  |  Branch (94:10): [True: 15, False: 56]
  ------------------
   95|     71|         llvm::isa<IntegerLiteral>(Node.getInit(0)) &&
  ------------------
  |  Branch (95:10): [True: 6, False: 9]
  ------------------
   96|     71|         llvm::cast<IntegerLiteral>(Node.getInit(0))->getValue() == 0;
  ------------------
  |  Branch (96:10): [True: 2, False: 4]
  ------------------
   97|     71|}
   98|       |
   99|     69|AST_MATCHER(InitListExpr, isStringLiteralInit) {
  100|     69|  return Node.isStringLiteralInit();
  101|     69|}
  102|       |
  103|       |} // namespace ast_matchers
  104|       |
  105|       |namespace automotive = ast_matchers;
  106|       |
  107|       |} // namespace clang::tidy::automotive
  108|       |
  109|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_ASTMATCHERS_H

/home/e/Development/clang-tidy-automotive/src/automotive/utils/Utils.h:
    1|       |//===--- Utils.h - clang-tidy ----------------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UTILS_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UTILS_H
   11|       |
   12|       |#include "clang/ASTMatchers/ASTMatchers.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |namespace utils {
   17|       |
   18|    131|static bool isLanguageC90(const LangOptions &LangOpts) {
   19|    131|  return !LangOpts.C99 && !LangOpts.C11 && !LangOpts.C17 && !LangOpts.C23 &&
  ------------------
  |  Branch (19:10): [True: 18, False: 113]
  |  Branch (19:27): [True: 18, False: 0]
  |  Branch (19:44): [True: 18, False: 0]
  |  Branch (19:61): [True: 18, False: 0]
  ------------------
   20|    131|         !LangOpts.CPlusPlus;
  ------------------
  |  Branch (20:10): [True: 1, False: 17]
  ------------------
   21|    131|}
  ------------------
  | Unexecuted instantiation: FunctionComponent.cpp:_ZN5clang4tidy10automotive5utilsL13isLanguageC90ERKNS_11LangOptionsE
  ------------------
  | ImplicitFunctionDeclCheck.cpp:_ZN5clang4tidy10automotive5utilsL13isLanguageC90ERKNS_11LangOptionsE:
  |   18|    131|static bool isLanguageC90(const LangOptions &LangOpts) {
  |   19|    131|  return !LangOpts.C99 && !LangOpts.C11 && !LangOpts.C17 && !LangOpts.C23 &&
  |  ------------------
  |  |  Branch (19:10): [True: 18, False: 113]
  |  |  Branch (19:27): [True: 18, False: 0]
  |  |  Branch (19:44): [True: 18, False: 0]
  |  |  Branch (19:61): [True: 18, False: 0]
  |  ------------------
  |   20|    131|         !LangOpts.CPlusPlus;
  |  ------------------
  |  |  Branch (20:10): [True: 1, False: 17]
  |  ------------------
  |   21|    131|}
  ------------------
   22|       |
   23|       |} // namespace utils
   24|       |
   25|       |} // namespace clang::tidy::automotive
   26|       |
   27|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UTILS_H

/home/e/Development/clang-tidy-automotive/src/automotive/utils/IgnoreLineSpliceRef.h:
    1|       |//===--- IgnoreLineSpliceRef.h - clang-tidy ---------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IGNORELINESPLICEREF_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IGNORELINESPLICEREF_H
   11|       |
   12|       |#include "llvm/ADT/StringRef.h"
   13|       |#include "llvm/Support/raw_ostream.h"
   14|       |
   15|       |class IgnoreLineSpliceRefIterator {
   16|       |public:
   17|       |  using iterator_category = std::forward_iterator_tag;
   18|       |  using value_type = char;
   19|       |  using difference_type = std::ptrdiff_t;
   20|       |  using pointer = char *;
   21|       |  using reference = char &;
   22|       |
   23|       |  IgnoreLineSpliceRefIterator(llvm::StringRef Text, size_t Index)
   24|  2.54M|      : Text(Text), PrevIndex(Index), Index(Index) {
   25|  2.54M|    skipLineSplice();
   26|  2.54M|  }
   27|       |
   28|  2.54M|  char operator*() const { return Text[Index]; }
   29|       |
   30|  2.50M|  IgnoreLineSpliceRefIterator &operator++() {
   31|  2.50M|    PrevIndex = Index;
   32|  2.50M|    ++Index;
   33|  2.50M|    skipLineSplice();
   34|  2.50M|    return *this;
   35|  2.50M|  }
   36|       |
   37|      0|  IgnoreLineSpliceRefIterator operator++(int) {
   38|      0|    IgnoreLineSpliceRefIterator temp = *this;
   39|      0|    ++(*this);
   40|      0|    return temp;
   41|      0|  }
   42|       |
   43|  2.48M|  bool operator!=(const IgnoreLineSpliceRefIterator &Other) const {
   44|  2.48M|    return Index != Other.Index;
   45|  2.48M|  }
   46|       |
   47|  52.5k|  size_t position() const { return Index; }
   48|       |
   49|  1.52k|  size_t prevPosition() const { return PrevIndex; }
   50|       |
   51|       |private:
   52|  5.05M|  void skipLineSplice() {
   53|  5.05M|    while (Index + 1 < Text.size() && Text[Index] == '\\' &&
  ------------------
  |  Branch (53:12): [True: 2.52M, False: 2.52M]
  |  Branch (53:39): [True: 180, False: 2.52M]
  ------------------
   54|  5.05M|           Text[Index + 1] == '\n') {
  ------------------
  |  Branch (54:12): [True: 56, False: 124]
  ------------------
   55|     56|      Index += 2;
   56|     56|    }
   57|  5.05M|  }
   58|       |
   59|       |  llvm::StringRef Text;
   60|       |  size_t PrevIndex;
   61|       |  size_t Index;
   62|       |};
   63|       |
   64|       |class IgnoreLineSpliceRefReverseIterator {
   65|       |public:
   66|       |  using iterator_category = std::forward_iterator_tag;
   67|       |  using value_type = char;
   68|       |  using difference_type = std::ptrdiff_t;
   69|       |  using pointer = char *;
   70|       |  using reference = char &;
   71|       |
   72|       |  IgnoreLineSpliceRefReverseIterator(llvm::StringRef Text, size_t Index)
   73|  23.3k|      : Text(Text), Index(Index) {
   74|  23.3k|    skipLineSplice();
   75|  23.3k|  }
   76|       |
   77|  46.6k|  char operator*() const { return Text[Index]; }
   78|       |
   79|  23.3k|  IgnoreLineSpliceRefReverseIterator &operator--() {
   80|  23.3k|    --Index;
   81|  23.3k|    skipLineSplice();
   82|  23.3k|    return *this;
   83|  23.3k|  }
   84|       |
   85|      0|  IgnoreLineSpliceRefReverseIterator operator--(int) {
   86|      0|    IgnoreLineSpliceRefReverseIterator temp = *this;
   87|      0|    --(*this);
   88|      0|    return temp;
   89|      0|  }
   90|       |
   91|      0|  bool operator!=(const IgnoreLineSpliceRefReverseIterator &Other) const {
   92|      0|    return Index != Other.Index;
   93|      0|  }
   94|       |
   95|  23.3k|  size_t position() const { return Index; }
   96|       |
   97|       |private:
   98|  46.6k|  void skipLineSplice() {
   99|  46.6k|    while (Index > 0 && Text[Index] == '\\' && Text[Index - 1] == '\n') {
  ------------------
  |  Branch (99:12): [True: 46.6k, False: 0]
  |  Branch (99:25): [True: 0, False: 46.6k]
  |  Branch (99:48): [True: 0, False: 0]
  ------------------
  100|      0|      Index -= 2;
  101|      0|    }
  102|  46.6k|  }
  103|       |
  104|       |  llvm::StringRef Text;
  105|       |  size_t Index;
  106|       |};
  107|       |
  108|       |class IgnoreLineSpliceRef {
  109|       |public:
  110|  67.1k|  explicit IgnoreLineSpliceRef(llvm::StringRef Text) : Text(Text) {}
  111|       |
  112|  67.1k|  IgnoreLineSpliceRefIterator begin() {
  113|  67.1k|    return IgnoreLineSpliceRefIterator(Text, 0);
  114|  67.1k|  }
  115|       |
  116|  2.48M|  IgnoreLineSpliceRefIterator end() {
  117|  2.48M|    return IgnoreLineSpliceRefIterator(Text, Text.size());
  118|  2.48M|  }
  119|       |
  120|  23.3k|  IgnoreLineSpliceRefReverseIterator rbegin() {
  121|  23.3k|    return IgnoreLineSpliceRefReverseIterator(Text, Text.size() - 1);
  122|  23.3k|  }
  123|       |
  124|      0|  IgnoreLineSpliceRefReverseIterator rend() {
  125|      0|    return IgnoreLineSpliceRefReverseIterator(Text, size_t(-1));
  126|      0|  }
  127|       |
  128|       |private:
  129|       |  llvm::StringRef Text;
  130|       |};
  131|       |
  132|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IGNORELINESPLICEREF_H

/home/e/Development/clang-tidy-automotive/src/automotive/utils/CKeywordSet.cpp:
    1|       |//===--- CKeywordSet.cpp - clang-tidy -------------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "CKeywordSet.h"
   10|       |#include "clang/Basic/LangOptions.h"
   11|       |#include "clang/Basic/LangStandard.h"
   12|       |
   13|       |namespace clang::tidy::automotive {
   14|       |
   15|       |using namespace clang;
   16|       |
   17|       |static constexpr size_t
   18|       |sizeofKeywordSet(std::initializer_list<llvm::ArrayRef<llvm::StringRef>> Lists);
   19|       |
   20|       |static llvm::DenseSet<llvm::StringRef>
   21|       |makeKeywordSet(std::initializer_list<llvm::ArrayRef<llvm::StringRef>> Lists,
   22|       |               llvm::ArrayRef<llvm::StringRef> RemoveList = {});
   23|       |
   24|       |static constexpr llvm::StringRef C89Keywords[] = {
   25|       |    "auto",     "break",  "case",    "char",   "const",    "continue",
   26|       |    "default",  "do",     "double",  "else",   "enum",     "extern",
   27|       |    "float",    "for",    "goto",    "if",     "int",      "long",
   28|       |    "register", "return", "short",   "signed", "sizeof",   "static",
   29|       |    "struct",   "switch", "typedef", "union",  "unsigned", "void",
   30|       |    "volatile", "while"};
   31|       |
   32|       |static constexpr llvm::StringRef C99Keywords[] = {
   33|       |    "_Bool", "_Complex", "_Imaginary", "inline", "restrict"};
   34|       |
   35|       |static constexpr llvm::StringRef C11Keywords[] = {
   36|       |    "_Alignas",  "_Alignof",       "_Atomic",      "_Generic",
   37|       |    "_Noreturn", "_Static_assert", "_Thread_local"};
   38|       |
   39|       |static constexpr llvm::StringRef C23Keywords[] = {
   40|       |    "alignas",     "alignof",    "bool",          "constexpr",
   41|       |    "false",       "nullptr",    "static_assert", "thread_local",
   42|       |    "true",        "typeof",     "typeof_unqual", "_BitInt",
   43|       |    "_Decimal128", "_Decimal32", "_Decimal64"};
   44|       |
   45|       |static constexpr llvm::StringRef C23DeprecatedKeywords[] = {
   46|       |    "_Alignas",  "_Alignof",       "_Bool",
   47|       |    "_Noreturn", "_Static_assert", "_Thread_local"};
   48|       |
   49|       |static const llvm::DenseSet<llvm::StringRef> EmptyKeywordSet = {};
   50|       |
   51|       |static const llvm::DenseSet<llvm::StringRef> C89KeywordSet =
   52|       |    makeKeywordSet({C89Keywords});
   53|       |
   54|       |static const llvm::DenseSet<llvm::StringRef> C99KeywordSet =
   55|       |    makeKeywordSet({C89Keywords, C99Keywords});
   56|       |
   57|       |static const llvm::DenseSet<llvm::StringRef> C11KeywordSet =
   58|       |    makeKeywordSet({C89Keywords, C99Keywords, C11Keywords});
   59|       |
   60|       |static const llvm::DenseSet<llvm::StringRef> C23KeywordSet =
   61|       |    makeKeywordSet({C89Keywords, C99Keywords, C11Keywords, C23Keywords},
   62|       |                   C23DeprecatedKeywords);
   63|       |
   64|       |static const llvm::DenseSet<llvm::StringRef> C23DeprecatedKeywordSet =
   65|       |    makeKeywordSet({C23DeprecatedKeywords});
   66|       |
   67|    131|CKeywordSet::CKeywordSet(const clang::LangOptions &LangOpts) {
   68|    131|  if (LangOpts.C23) {
  ------------------
  |  Branch (68:7): [True: 0, False: 131]
  ------------------
   69|      0|    ActiveKeywords = &C23KeywordSet;
   70|      0|    DeprecatedKeywords = &C23DeprecatedKeywordSet;
   71|       |
   72|    131|  } else if (LangOpts.C11) {
  ------------------
  |  Branch (72:14): [True: 79, False: 52]
  ------------------
   73|     79|    ActiveKeywords = &C11KeywordSet;
   74|     79|    DeprecatedKeywords = &EmptyKeywordSet;
   75|       |
   76|     79|  } else if (LangOpts.C99) {
  ------------------
  |  Branch (76:14): [True: 34, False: 18]
  ------------------
   77|     34|    ActiveKeywords = &C99KeywordSet;
   78|     34|    DeprecatedKeywords = &EmptyKeywordSet;
   79|       |
   80|     34|  } else {
   81|     18|    ActiveKeywords = &C23KeywordSet;
   82|     18|    DeprecatedKeywords = &EmptyKeywordSet;
   83|     18|  }
   84|    131|}
   85|       |
   86|  64.1k|bool CKeywordSet::isKeyword(StringRef Str) const {
   87|  64.1k|  return ActiveKeywords->contains(Str);
   88|  64.1k|}
   89|       |
   90|      0|bool CKeywordSet::isDeprecated(StringRef Str) const {
   91|      0|  return DeprecatedKeywords->contains(Str);
   92|      0|}
   93|       |
   94|       |static constexpr size_t
   95|    655|sizeofKeywordSet(std::initializer_list<llvm::ArrayRef<llvm::StringRef>> Lists) {
   96|    655|  size_t Size = 0;
   97|  1.44k|  for (const auto &List : Lists) {
  ------------------
  |  Branch (97:25): [True: 1.44k, False: 655]
  ------------------
   98|  1.44k|    Size += List.size();
   99|  1.44k|  }
  100|    655|  return Size;
  101|    655|}
  102|       |
  103|       |static llvm::DenseSet<llvm::StringRef>
  104|       |makeKeywordSet(std::initializer_list<llvm::ArrayRef<llvm::StringRef>> Lists,
  105|    655|               ArrayRef<llvm::StringRef> RemoveList) {
  106|       |
  107|    655|  llvm::DenseSet<llvm::StringRef> Result(sizeofKeywordSet(Lists));
  108|       |
  109|  1.44k|  for (const auto &List : Lists) {
  ------------------
  |  Branch (109:25): [True: 1.44k, False: 655]
  ------------------
  110|  1.44k|    Result.insert(List.begin(), List.end());
  111|  1.44k|  }
  112|       |
  113|    786|  for (const auto &Remove : RemoveList) {
  ------------------
  |  Branch (113:27): [True: 786, False: 655]
  ------------------
  114|    786|    Result.erase(Remove);
  115|    786|  }
  116|       |
  117|    655|  return Result;
  118|    655|}
  119|       |
  120|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/AutomotiveTidyModule.cpp:
    1|       |//===--- AutomotiveTidyModule.cpp - clang-tidy ----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "../ClangTidy.h"
   10|       |#include "../ClangTidyModule.h"
   11|       |#include "../ClangTidyModuleRegistry.h"
   12|       |#include "../cert/FloatLoopCounter.h"
   13|       |#include "../misc/NoRecursionCheck.h"
   14|       |#include "../misc/UnusedParametersCheck.h"
   15|       |#include "array/ArrayComponent.h"
   16|       |#include "bitfield/BitfieldComponent.h"
   17|       |#include "comment/CommentComponent.h"
   18|       |#include "cpp23/Cpp23Component.h"
   19|       |#include "expression/ExpressionComponent.h"
   20|       |#include "function/FunctionComponent.h"
   21|       |#include "literal/LiteralComponent.h"
   22|       |#include "operator/OperatorComponent.h"
   23|       |#include "pointer/PointerComponent.h"
   24|       |#include "preprocessor/PreprocessorComponent.h"
   25|       |#include "return/ReturnComponent.h"
   26|       |#include "statement/StatementComponent.h"
   27|       |#include "stdlib/StdlibComponent.h"
   28|       |#include "storage/StorageComponent.h"
   29|       |#include "type/TypeComponent.h"
   30|       |
   31|       |#include "unused-code/UnusedCodeModule.h"
   32|       |
   33|       |namespace clang::tidy {
   34|       |namespace automotive {
   35|       |
   36|       |class AutomotiveModule : public ClangTidyModule {
   37|       |public:
   38|    262|  void addCheckFactories(ClangTidyCheckFactories &CheckFactories) override {
   39|       |
   40|    262|    ArrayComponent::addCheckFactories(CheckFactories);
   41|    262|    BitfieldComponent::addCheckFactories(CheckFactories);
   42|    262|    CommentComponent::addCheckFactories(CheckFactories);
   43|    262|    Cpp23Component::addCheckFactories(CheckFactories);
   44|    262|    ExpressionComponent::addCheckFactories(CheckFactories);
   45|    262|    FunctionComponent::addCheckFactories(CheckFactories);
   46|    262|    LiteralComponent::addCheckFactories(CheckFactories);
   47|    262|    OperatorComponent::addCheckFactories(CheckFactories);
   48|    262|    PointerComponent::addCheckFactories(CheckFactories);
   49|    262|    PreprocessorComponent::addCheckFactories(CheckFactories);
   50|    262|    ReturnComponent::addCheckFactories(CheckFactories);
   51|    262|    StatementComponent::addCheckFactories(CheckFactories);
   52|    262|    StdlibComponent::addCheckFactories(CheckFactories);
   53|    262|    StorageComponent::addCheckFactories(CheckFactories);
   54|    262|    TypeComponent::addCheckFactories(CheckFactories);
   55|       |
   56|       |    /* C 2023
   57|       |    ---------------------------------------------------------------- */
   58|    262|    CheckFactories.registerCheck<cert::FloatLoopCounter>(
   59|    262|        "automotive-c23-req-14.1");
   60|    262|    CheckFactories.registerCheck<misc::NoRecursionCheck>(
   61|    262|        "automotive-c23-req-17.2");
   62|       |
   63|       |    /* C 2012
   64|       |    ---------------------------------------------------------------- */
   65|    262|    CheckFactories.registerCheck<cert::FloatLoopCounter>(
   66|    262|        "automotive-c12-req-14.1");
   67|       |
   68|       |    /* 2. Unused code
   69|       |    ---------------------------------------------------------------- */
   70|    262|    UnusedCodeModule::addCheckFactories(CheckFactories);
   71|    262|  }
   72|       |};
   73|       |
   74|       |} // namespace automotive
   75|       |
   76|       |// Register the Automotive Module using this statically initialized variable.
   77|       |static ClangTidyModuleRegistry::Add<automotive::AutomotiveModule>
   78|       |    X("automotive-module", "Adds automotive lint checks.");
   79|       |
   80|       |// This anchor is used to force the linker to link in the generated object file
   81|       |// and thus register the AutomotiveModule. The volatile keyword prevents
   82|       |// compiler optimization that would remove this symbol.
   83|       |// NOSONAR(S5421,S859): volatile linker anchor cannot be const
   84|       |volatile int AutomotiveModuleAnchorSource = 0;
   85|       |
   86|       |} // namespace clang::tidy

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingDefaultInSwitchStmtCheck.cpp:
    1|       |//===--- MissingDefaultInSwitchStmtCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingDefaultInSwitchStmtCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/AST/ASTContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void MissingDefaultInSwitchStmtCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(
   20|    131|      switchStmt(unless(automotive::hasDefaultStmt())).bind("switchStmt"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|       |void MissingDefaultInSwitchStmtCheck::check(
   25|     21|    const MatchFinder::MatchResult &Result) {
   26|     21|  const auto *MatchedDecl = Result.Nodes.getNodeAs<SwitchStmt>("switchStmt");
   27|     21|  if (MatchedDecl) {
  ------------------
  |  Branch (27:7): [True: 21, False: 0]
  ------------------
   28|     21|    diag(MatchedDecl->getSwitchLoc(),
   29|     21|         "missing default statement in switch statement");
   30|     21|  }
   31|     21|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingBreakInCaseStmtCheck.cpp:
    1|       |//===--- MissingBreakInCaseStmtCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingBreakInCaseStmtCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void MissingBreakInCaseStmtCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(switchStmt().bind("switchStmt"), this);
   19|    131|}
   20|       |
   21|       |void MissingBreakInCaseStmtCheck::check(
   22|     73|    const MatchFinder::MatchResult &Result) {
   23|     73|  const auto *Switch = Result.Nodes.getNodeAs<SwitchStmt>("switchStmt");
   24|     73|  if (!Switch)
  ------------------
  |  Branch (24:7): [True: 0, False: 73]
  ------------------
   25|      0|    return;
   26|       |
   27|     73|  const auto *Body = dyn_cast<CompoundStmt>(Switch->getBody());
   28|     73|  if (!Body)
  ------------------
  |  Branch (28:7): [True: 0, False: 73]
  ------------------
   29|      0|    return;
   30|       |
   31|    316|  for (auto It = Body->body_begin(); It != Body->body_end(); ++It) {
  ------------------
  |  Branch (31:38): [True: 243, False: 73]
  ------------------
   32|    243|    const Stmt *S = *It;
   33|       |
   34|    243|    if (const auto *Case = dyn_cast<CaseStmt>(S)) {
  ------------------
  |  Branch (34:21): [True: 141, False: 102]
  ------------------
   35|    141|      checkCase(Case, It, Body, Result.Context);
   36|    141|    } else if (const auto *Default = dyn_cast<DefaultStmt>(S)) {
  ------------------
  |  Branch (36:28): [True: 47, False: 55]
  ------------------
   37|     47|      checkCase(Default, It, Body, Result.Context);
   38|     47|    }
   39|    243|  }
   40|     73|}
   41|       |
   42|       |void MissingBreakInCaseStmtCheck::checkCase(
   43|       |    const Stmt *Case, CompoundStmt::const_body_iterator It,
   44|    188|    const CompoundStmt *Body, ASTContext *Context) {
   45|    188|  if (isa<CaseStmt>(Case) && Case->children().empty()) {
  ------------------
  |  Branch (45:7): [True: 141, False: 47]
  |  Branch (45:7): [True: 0, False: 188]
  |  Branch (45:30): [True: 0, False: 141]
  ------------------
   46|      0|    return;
   47|      0|  }
   48|       |
   49|    188|  bool FoundBreak = false;
   50|    197|  for (++It; It != Body->body_end(); ++It) {
  ------------------
  |  Branch (50:14): [True: 138, False: 59]
  ------------------
   51|    138|    const Stmt *S = *It;
   52|       |
   53|    138|    if (isa<BreakStmt>(S)) {
  ------------------
  |  Branch (53:9): [True: 46, False: 92]
  ------------------
   54|     46|      FoundBreak = true;
   55|     46|      break;
   56|     46|    }
   57|       |
   58|     92|    if (isa<CaseStmt>(S) || isa<DefaultStmt>(S)) {
  ------------------
  |  Branch (58:9): [True: 57, False: 35]
  |  Branch (58:29): [True: 26, False: 9]
  ------------------
   59|     83|      break;
   60|     83|    }
   61|     92|  }
   62|       |
   63|    188|  if (!FoundBreak) {
  ------------------
  |  Branch (63:7): [True: 142, False: 46]
  ------------------
   64|    142|    diag(Case->getBeginLoc(),
   65|    142|         "every non-empty switch case must end with a break statement");
   66|    142|  }
   67|    188|}
   68|       |
   69|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/UnstructuredSwitchStmtCheck.h:
    1|       |//===--- UnstructuredSwitchStmtCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNSTRUCTUREDSWITCHSTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNSTRUCTUREDSWITCHSTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects improperly structured switch statements.
   18|       |///
   19|       |/// Switch statements should be well-formed with cases appearing only at the
   20|       |/// top level of the switch body. Nested cases, cases inside loops, or other
   21|       |/// unstructured patterns make code harder to understand and maintain.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 16.2
   24|       |/// A switch label shall only be used when the most closely-enclosing
   25|       |/// compound statement is the body of a switch statement.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   switch (x) {
   31|       |///     case 1:
   32|       |///       if (y) {
   33|       |///         case 2:  // Warning: case inside if
   34|       |///           break;
   35|       |///       }
   36|       |///       break;
   37|       |///   }
   38|       |/// @endcode
   39|       |class UnstructuredSwitchStmtCheck : public ClangTidyCheck {
   40|       |public:
   41|       |  UnstructuredSwitchStmtCheck(StringRef Name, ClangTidyContext *Context)
   42|    131|      : ClangTidyCheck(Name, Context) {}
   43|       |
   44|       |  /// Destructor.
   45|    131|  ~UnstructuredSwitchStmtCheck() override = default;
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNSTRUCTUREDSWITCHSTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/UnusedLabelCheck.h:
    1|       |//===--- UnusedLabelCheck.h - clang-tidy ------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDLABELCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDLABELCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects labels that are declared but never referenced by a goto.
   18|       |///
   19|       |/// Unused labels indicate dead code that should be removed. They may be
   20|       |/// remnants of removed goto statements or incomplete implementations.
   21|       |///
   22|       |/// @par MISRA C:2025 Rule 2.6
   23|       |/// A function should not contain unused label declarations.
   24|       |/// @par Category: Advisory
   25|       |///
   26|       |/// Example:
   27|       |/// @code
   28|       |///   void func(void) {
   29|       |///     unused_label:  // Warning: label never used
   30|       |///       do_something();
   31|       |///   }
   32|       |/// @endcode
   33|       |class UnusedLabelCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  UnusedLabelCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~UnusedLabelCheck() override = default;
   40|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   41|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   42|       |};
   43|       |
   44|       |} // namespace clang::tidy::automotive
   45|       |
   46|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_STANDARDCLANGUAGECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/WrongOrderInSwitchStmtCheck.cpp:
    1|       |//===--- WrongOrderInSwitchStmtCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "WrongOrderInSwitchStmtCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void WrongOrderInSwitchStmtCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      switchStmt(forEachSwitchCase(switchCase().bind("case"))).bind("switch"),
   20|    131|      this);
   21|    131|}
   22|       |
   23|       |void WrongOrderInSwitchStmtCheck::check(
   24|    206|    const MatchFinder::MatchResult &Result) {
   25|    206|  const auto *MatchSwitch = Result.Nodes.getNodeAs<SwitchStmt>("switch");
   26|    206|  const auto *MatchCase = Result.Nodes.getNodeAs<SwitchCase>("case");
   27|       |
   28|    206|  if ((MatchSwitch) && (MatchSwitch != PrevSwitch)) {
  ------------------
  |  Branch (28:7): [True: 206, False: 0]
  |  Branch (28:24): [True: 71, False: 135]
  ------------------
   29|     71|    PrevDefault = nullptr;
   30|    135|  } else if ((MatchCase) && (PrevDefault)) {
  ------------------
  |  Branch (30:14): [True: 135, False: 0]
  |  Branch (30:29): [True: 1, False: 134]
  ------------------
   31|      1|    diag(PrevDefault->getBeginLoc(), "default statement neither first or last");
   32|      1|    PrevDefault = nullptr;
   33|    134|  } else {
   34|    134|    const auto *MatchDefault = llvm::dyn_cast<DefaultStmt>(MatchCase);
   35|    134|    PrevDefault = MatchDefault;
   36|    134|  }
   37|    206|  PrevSwitch = MatchSwitch;
   38|    206|}
   39|       |
   40|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/ForwardGotoLabelCheck.cpp:
    1|       |//===--- ForwardGotoLabelCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ForwardGotoLabelCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |static const LabelStmt *getLabelStmt(const GotoStmt *Goto);
   18|       |
   19|    131|void ForwardGotoLabelCheck::registerMatchers(MatchFinder *Finder) {
   20|    131|  Finder->addMatcher(gotoStmt().bind("goto"), this);
   21|    131|}
   22|       |
   23|     29|void ForwardGotoLabelCheck::check(const MatchFinder::MatchResult &Result) {
   24|     29|  const auto *MatchedGoto = Result.Nodes.getNodeAs<GotoStmt>("goto");
   25|     29|  const auto *MatchedLabel = getLabelStmt(MatchedGoto);
   26|       |
   27|     29|  if (!MatchedGoto || !MatchedLabel)
  ------------------
  |  Branch (27:7): [True: 0, False: 29]
  |  Branch (27:23): [True: 0, False: 29]
  ------------------
   28|      0|    return;
   29|       |
   30|     29|  SourceManager &SM = Result.Context->getSourceManager();
   31|     29|  const auto GotoLoc = MatchedGoto->getBeginLoc();
   32|     29|  const auto LabelLoc = MatchedLabel->getBeginLoc();
   33|       |
   34|     29|  if (SM.isBeforeInTranslationUnit(LabelLoc, GotoLoc)) {
  ------------------
  |  Branch (34:7): [True: 10, False: 19]
  ------------------
   35|     10|    diag(GotoLoc, "goto statement jumps backward to label '%0'")
   36|     10|        << MatchedLabel->getName();
   37|     10|    diag(LabelLoc, "location of label '%0'", DiagnosticIDs::Note)
   38|     10|        << MatchedLabel->getName();
   39|     10|  }
   40|     29|}
   41|       |
   42|     29|static const LabelStmt *getLabelStmt(const GotoStmt *Goto) {
   43|     29|  if (!Goto)
  ------------------
  |  Branch (43:7): [True: 0, False: 29]
  ------------------
   44|      0|    return nullptr;
   45|       |
   46|     29|  const auto *Label = Goto->getLabel();
   47|     29|  return Label ? Label->getStmt() : nullptr;
  ------------------
  |  Branch (47:10): [True: 29, False: 0]
  ------------------
   48|     29|}
   49|       |
   50|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/WrongOrderInSwitchStmtCheck.h:
    1|       |//===--- WrongOrderInSwitchStmtCheck.h - clang-tidy -*- C++ -*-===============//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGORDERINSWITCHSTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGORDERINSWITCHSTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects default case not at the end of switch statement.
   18|       |///
   19|       |/// The default case should appear as the first or last clause in a switch
   20|       |/// statement for consistency and readability. Having default in the middle
   21|       |/// can make the code harder to understand.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 16.5
   24|       |/// A default label shall appear as either the first or the last switch label
   25|       |/// of a switch statement.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   switch (x) {
   31|       |///     case 1: break;
   32|       |///     default: break;  // Warning: default in middle
   33|       |///     case 2: break;
   34|       |///   }
   35|       |/// @endcode
   36|       |class WrongOrderInSwitchStmtCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  WrongOrderInSwitchStmtCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~WrongOrderInSwitchStmtCheck() override = default;
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |
   46|       |private:
   47|       |  const SwitchStmt *PrevSwitch = nullptr;
   48|       |  const DefaultStmt *PrevDefault = nullptr;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGORDERINSWITCHSTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingElseCheck.h:
    1|       |//===--- MissingElseCheck.h - clang-tidy ------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGELSECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGELSECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects if-else-if chains without a final else clause.
   18|       |///
   19|       |/// An if-else-if chain without a terminating else clause may indicate
   20|       |/// incomplete logic. The final else should handle unexpected conditions
   21|       |/// or document that all cases are intentionally covered.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 15.7
   24|       |/// All if ... else if constructs shall be terminated with an else statement.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   if (x == 1) {
   30|       |///     // handle 1
   31|       |///   } else if (x == 2) {
   32|       |///     // handle 2
   33|       |///   }  // Warning: missing final else
   34|       |///
   35|       |///   if (x == 1) {
   36|       |///     // handle 1
   37|       |///   } else if (x == 2) {
   38|       |///     // handle 2
   39|       |///   } else {
   40|       |///     // handle other  // OK
   41|       |///   }
   42|       |/// @endcode
   43|       |class MissingElseCheck : public ClangTidyCheck {
   44|       |public:
   45|       |  MissingElseCheck(StringRef Name, ClangTidyContext *Context)
   46|    131|      : ClangTidyCheck(Name, Context) {}
   47|       |
   48|       |  /// Destructor.
   49|    131|  ~MissingElseCheck() override = default;
   50|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   51|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   52|       |};
   53|       |
   54|       |} // namespace clang::tidy::automotive
   55|       |
   56|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGELSECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingDefaultInSwitchStmtCheck.h:
    1|       |//===--- MissingDefaultInSwitchStmtCheck.h - clang-tidy ----*- C++ -*------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGDEFAULTINSWITCHSTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGDEFAULTINSWITCHSTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects switch statements without a default case.
   17|       |///
   18|       |/// Every switch statement should have a default case to handle unexpected
   19|       |/// values and ensure defensive programming. This helps catch logic errors
   20|       |/// and makes the code more robust against future enum additions.
   21|       |///
   22|       |/// Related MISRA C:2025 Rule: 16.4 - Every switch statement shall have a
   23|       |/// default label.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   void func(int x) {
   28|       |///     switch (x) {  // Warning: switch missing default case
   29|       |///       case 1: break;
   30|       |///       case 2: break;
   31|       |///     }
   32|       |///   }
   33|       |/// \endcode
   34|       |class MissingDefaultInSwitchStmtCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  /// Constructs the check with the given name and context.
   37|       |  /// \param Name The name of the check as registered.
   38|       |  /// \param Context The clang-tidy context for configuration.
   39|       |  MissingDefaultInSwitchStmtCheck(StringRef Name, ClangTidyContext *Context)
   40|    131|      : ClangTidyCheck(Name, Context) {}
   41|       |
   42|       |  /// Destructor.
   43|    131|  ~MissingDefaultInSwitchStmtCheck() override = default;
   44|       |
   45|       |  /// Registers AST matchers for switch statements.
   46|       |  /// \param Finder The match finder to register matchers with.
   47|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   48|       |
   49|       |  /// Handles matched switch statements and emits diagnostics.
   50|       |  /// \param Result The match result containing the matched AST node.
   51|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   52|       |};
   53|       |
   54|       |} // namespace clang::tidy::automotive
   55|       |
   56|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGDEFAULTINSWITCHSTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingBreakInCaseStmtCheck.h:
    1|       |//===--- MissingBreakInCaseStmtCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGBREAKINCASESTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGBREAKINCASESTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects fall-through in switch case statements.
   18|       |///
   19|       |/// Unintentional fall-through between switch cases is a common source of bugs.
   20|       |/// Each case should explicitly end with a break, return, or throw statement.
   21|       |/// If fall-through is intentional, it should be clearly documented.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 16.3
   24|       |/// An unconditional break statement shall terminate every switch-clause.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   switch (x) {
   30|       |///     case 1:
   31|       |///       do_something();
   32|       |///       // Warning: missing break - falls through to case 2
   33|       |///     case 2:
   34|       |///       do_other();
   35|       |///       break;
   36|       |///   }
   37|       |/// @endcode
   38|       |class MissingBreakInCaseStmtCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  MissingBreakInCaseStmtCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~MissingBreakInCaseStmtCheck() override = default;
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   47|       |
   48|       |private:
   49|       |  void checkCase(const Stmt *Case, CompoundStmt::const_body_iterator It,
   50|       |                 const CompoundStmt *Body, ASTContext *Context);
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGBREAKINCASESTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/AvoidBooleanInSwitchCheck.cpp:
    1|       |//===--- AvoidBooleanInSwitchCheck.cpp - clang-tidy -----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidBooleanInSwitchCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidBooleanInSwitchCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      switchStmt(hasCondition(expr(automotive::isEssentiallyBoolean())))
   20|    131|          .bind("switchExpr"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|      6|void AvoidBooleanInSwitchCheck::check(const MatchFinder::MatchResult &Result) {
   25|      6|  const auto *MatchedSwitch = Result.Nodes.getNodeAs<SwitchStmt>("switchExpr");
   26|       |
   27|      6|  if (MatchedSwitch) {
  ------------------
  |  Branch (27:7): [True: 6, False: 0]
  ------------------
   28|      6|    diag(MatchedSwitch->getBeginLoc(),
   29|      6|         "avoid boolean expression in switch statement");
   30|      6|  }
   31|      6|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingCompoundStmtCheck.cpp:
    1|       |//===--- MissingCompoundStmtCheck.cpp - clang-tidy ------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingCompoundStmtCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/AST/ASTContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |#include "clang/ASTMatchers/ASTMatchers.h"
   14|       |
   15|       |using namespace clang::ast_matchers;
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|    131|void MissingCompoundStmtCheck::registerMatchers(MatchFinder *Finder) {
   20|    131|  Finder->addMatcher(
   21|    131|      ifStmt(hasThen(stmt(unless(compoundStmt())).bind("body"))).bind("parent"),
   22|    131|      this);
   23|       |
   24|    131|  Finder->addMatcher(
   25|    131|      ifStmt(
   26|    131|          hasElse(stmt(unless(anyOf(compoundStmt(), ifStmt()))).bind("body")))
   27|    131|          .bind("parent"),
   28|    131|      this);
   29|       |
   30|    131|  Finder->addMatcher(forStmt(hasBody(stmt(unless(compoundStmt())).bind("body")))
   31|    131|                         .bind("parent"),
   32|    131|                     this);
   33|       |
   34|    131|  Finder->addMatcher(
   35|    131|      whileStmt(hasBody(stmt(unless(compoundStmt())).bind("body")))
   36|    131|          .bind("parent"),
   37|    131|      this);
   38|       |
   39|    131|  Finder->addMatcher(
   40|    131|      doStmt(hasBody(stmt(unless(compoundStmt())).bind("body"))).bind("parent"),
   41|    131|      this);
   42|       |
   43|    131|  Finder->addMatcher(
   44|    131|      switchStmt(automotive::hasBody(stmt(unless(compoundStmt())).bind("body")))
   45|    131|          .bind("parent"),
   46|    131|      this);
   47|    131|}
   48|       |
   49|    992|void MissingCompoundStmtCheck::check(const MatchFinder::MatchResult &Result) {
   50|    992|  const auto *MatchedParent = Result.Nodes.getNodeAs<Stmt>("parent");
   51|    992|  const auto *MatchedBody = Result.Nodes.getNodeAs<Stmt>("body");
   52|       |
   53|    992|  if (MatchedParent && MatchedBody) {
  ------------------
  |  Branch (53:7): [True: 992, False: 0]
  |  Branch (53:24): [True: 992, False: 0]
  ------------------
   54|    992|    diag(MatchedBody->getBeginLoc(), "missing compound statement",
   55|    992|         DiagnosticIDs::Warning);
   56|    992|  }
   57|    992|}
   58|       |
   59|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingCompoundStmtCheck.h:
    1|       |//===--- MissingCompoundStmtCheck.h - clang-tidy ----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGCOMPOUNDSTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGCOMPOUNDSTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects control structures without compound statements (braces).
   18|       |///
   19|       |/// Control flow statements (if, else, for, while, do, switch) without braces
   20|       |/// around their bodies are error-prone. Adding or removing statements can
   21|       |/// inadvertently change the control flow. Always using braces improves
   22|       |/// readability and reduces bugs during maintenance.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 15.6
   25|       |/// The body of an iteration-statement or a selection-statement shall be a
   26|       |/// compound-statement.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   if (condition)
   32|       |///     x++;  // Warning: missing braces
   33|       |///
   34|       |///   if (condition) {
   35|       |///     x++;  // OK: has braces
   36|       |///   }
   37|       |/// @endcode
   38|       |class MissingCompoundStmtCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  MissingCompoundStmtCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~MissingCompoundStmtCheck() override = default;
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGCOMPOUNDSTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MissingElseCheck.cpp:
    1|       |//===--- MissingElseCheck.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingElseCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void MissingElseCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      ifStmt(hasElse(ifStmt(unless(hasElse(anything()))).bind("ifStmt"))),
   20|    131|      this);
   21|    131|}
   22|       |
   23|     38|void MissingElseCheck::check(const MatchFinder::MatchResult &Result) {
   24|     38|  const auto *MatchedDecl = Result.Nodes.getNodeAs<IfStmt>("ifStmt");
   25|       |
   26|     38|  if (MatchedDecl) {
  ------------------
  |  Branch (26:7): [True: 38, False: 0]
  ------------------
   27|     38|    diag(MatchedDecl->getThen()->getEndLoc(), "missing else statment");
   28|     38|  }
   29|     38|}
   30|       |
   31|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/AvoidGotoCheck.h:
    1|       |//===--- AvoidGotoCheck.h - clang-tidy --------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGOTOCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGOTOCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects usage of goto statements in code.
   18|       |///
   19|       |/// The goto statement can lead to unstructured control flow, making code
   20|       |/// harder to understand, maintain, and verify. This check flags all goto
   21|       |/// statement usage to encourage structured programming practices.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 15.1
   24|       |/// The goto statement should not be used.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   void func(void) {
   30|       |///     goto label;  // Warning: goto statement detected
   31|       |///   label:
   32|       |///     return;
   33|       |///   }
   34|       |/// \endcode
   35|       |class AvoidGotoCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  /// Constructs the check with the given name and context.
   38|       |  /// \param Name The name of the check as registered.
   39|       |  /// \param Context The clang-tidy context for configuration.
   40|       |  AvoidGotoCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~AvoidGotoCheck() override = default;
   45|       |
   46|       |  /// Registers AST matchers for goto statements.
   47|       |  /// \param Finder The match finder to register matchers with.
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |
   50|       |  /// Handles matched goto statements and emits diagnostics.
   51|       |  /// \param Result The match result containing the matched AST node.
   52|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   53|       |};
   54|       |
   55|       |} // namespace clang::tidy::automotive
   56|       |
   57|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDGOTOCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/StatementComponent.cpp:
    1|       |//===--- StatementComponent.cpp - clang-tidy ------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "StatementComponent.h"
   10|       |#include "AvoidBooleanInSwitchCheck.h"
   11|       |#include "AvoidGotoCheck.h"
   12|       |#include "ForwardGotoLabelCheck.h"
   13|       |#include "GotoLabelSameBlockCheck.h"
   14|       |#include "MissingBreakInCaseStmtCheck.h"
   15|       |#include "MissingCompoundStmtCheck.h"
   16|       |#include "MissingDefaultInSwitchStmtCheck.h"
   17|       |#include "MissingElseCheck.h"
   18|       |#include "MultipleLoopTerminatorsCheck.h"
   19|       |#include "UnstructuredSwitchStmtCheck.h"
   20|       |#include "UnusedLabelCheck.h"
   21|       |#include "WrongOrderInSwitchStmtCheck.h"
   22|       |
   23|       |namespace clang::tidy::automotive {
   24|       |
   25|       |void StatementComponent::addCheckFactories(
   26|    262|    ClangTidyCheckFactories &CheckFactories) {
   27|       |
   28|    262|  CheckFactories.registerCheck<UnusedLabelCheck>("automotive-unused-label");
   29|    262|  CheckFactories.registerCheck<AvoidGotoCheck>("automotive-avoid-goto");
   30|    262|  CheckFactories.registerCheck<ForwardGotoLabelCheck>(
   31|    262|      "automotive-forward-goto-label");
   32|    262|  CheckFactories.registerCheck<GotoLabelSameBlockCheck>(
   33|    262|      "automotive-c23-req-15.2");
   34|       |
   35|    262|  CheckFactories.registerCheck<MissingBreakInCaseStmtCheck>(
   36|    262|      "automotive-missing-break-in-case");
   37|    262|  CheckFactories.registerCheck<MissingDefaultInSwitchStmtCheck>(
   38|    262|      "automotive-missing-default-in-switch");
   39|    262|  CheckFactories.registerCheck<WrongOrderInSwitchStmtCheck>(
   40|    262|      "automotive-c23-req-16.5");
   41|    262|  CheckFactories.registerCheck<AvoidBooleanInSwitchCheck>(
   42|    262|      "automotive-avoid-boolean-in-switch");
   43|    262|  CheckFactories.registerCheck<UnstructuredSwitchStmtCheck>(
   44|    262|      "automotive-x-req-16.2");
   45|       |  /* 16.2 Inspiration: m
   46|       |   * caseStmt(unless(hasParent(compoundStmt(hasParent(switchStmt()))))) */
   47|       |
   48|       |  /* 15.
   49|       |  ---------------------------------------------------------------- */
   50|    262|  CheckFactories.registerCheck<MissingCompoundStmtCheck>(
   51|    262|      "automotive-missing-compound");
   52|    262|  CheckFactories.registerCheck<MissingElseCheck>("automotive-missing-else");
   53|       |
   54|       |  // Rule 15.4 - Multiple loop terminators (Advisory)
   55|    262|  CheckFactories.registerCheck<MultipleLoopTerminatorsCheck>(
   56|    262|      "automotive-c23-adv-15.4");
   57|    262|}
   58|       |
   59|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/AvoidGotoCheck.cpp:
    1|       |//===--- AvoidGotoCheck.cpp - clang-tidy ----------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidGotoCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include <cstdio>
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void AvoidGotoCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(gotoStmt().bind("goto"), this);
   20|    131|}
   21|       |
   22|     29|void AvoidGotoCheck::check(const MatchFinder::MatchResult &Result) {
   23|     29|  const auto *MatchedDecl = Result.Nodes.getNodeAs<GotoStmt>("goto");
   24|     29|  diag(MatchedDecl->getGotoLoc(), "avoid goto statement");
   25|     29|}
   26|       |
   27|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/AvoidBooleanInSwitchCheck.h:
    1|       |//===--- AvoidBooleanInSwitchCheck.h - clang-tidy ---------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBOOLEANINSWITCHCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBOOLEANINSWITCHCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects switch statements with boolean controlling expressions.
   18|       |///
   19|       |/// A switch statement on a boolean expression is redundant since a boolean
   20|       |/// can only have two values (true/false). An if-else statement is clearer
   21|       |/// and more appropriate for boolean decisions.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 16.7
   24|       |/// A switch expression shall not have essentially Boolean type.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   bool flag = true;
   30|       |///   switch (flag) {  // Warning: boolean in switch
   31|       |///     case true: break;
   32|       |///     case false: break;
   33|       |///   }
   34|       |/// @endcode
   35|       |class AvoidBooleanInSwitchCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidBooleanInSwitchCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidBooleanInSwitchCheck() override = default;
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBOOLEANINSWITCHCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MultipleLoopTerminatorsCheck.h:
    1|       |//===--- MultipleLoopTerminatorsCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLELOOPTERMINATORSCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLELOOPTERMINATORSCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statement
   17|       |/// @brief Detects loops with multiple break or goto terminators.
   18|       |///
   19|       |/// There should be no more than one break or goto statement used to terminate
   20|       |/// any iteration statement. Multiple exit points from loops make control flow
   21|       |/// harder to understand and verify.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 15.4
   24|       |/// There should be no more than one break or goto statement used to terminate
   25|       |/// any iteration statement.
   26|       |/// @par Category: Advisory
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   for (int i = 0; i < 10; i++) {
   31|       |///       if (x) break;      // First terminator
   32|       |///       if (y) break;      // Warning: second terminator
   33|       |///   }
   34|       |///   while (1) {
   35|       |///       if (a) break;      // OK: single terminator
   36|       |///   }
   37|       |/// @endcode
   38|       |class MultipleLoopTerminatorsCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  MultipleLoopTerminatorsCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~MultipleLoopTerminatorsCheck() override = default;
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLELOOPTERMINATORSCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/UnusedLabelCheck.cpp:
    1|       |//===--- UnusedLabelCheck.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedLabelCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UnusedLabelCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(labelStmt().bind("label"), this);
   18|    131|}
   19|       |
   20|     28|void UnusedLabelCheck::check(const MatchFinder::MatchResult &Result) {
   21|     28|  const auto *MatchedLabel = Result.Nodes.getNodeAs<LabelStmt>("label");
   22|       |
   23|     28|  if (!MatchedLabel) {
  ------------------
  |  Branch (23:7): [True: 0, False: 28]
  ------------------
   24|      0|    return;
   25|      0|  }
   26|       |
   27|     28|  if (MatchedLabel->getDecl()->isUsed()) {
  ------------------
  |  Branch (27:7): [True: 27, False: 1]
  ------------------
   28|     27|    return;
   29|     27|  }
   30|       |
   31|      1|  diag(MatchedLabel->getBeginLoc(), "unused label '%0'")
   32|      1|      << MatchedLabel->getName();
   33|      1|}
   34|       |
   35|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/GotoLabelSameBlockCheck.h:
    1|       |//===--- GotoLabelSameBlockCheck.h - clang-tidy ----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_GOTOLABELSAMEBLOCKCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_GOTOLABELSAMEBLOCKCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-statements
   17|       |/// @brief Detects goto statements where the target label is in a different
   18|       |/// block scope.
   19|       |///
   20|       |/// A goto statement and its corresponding label must be in the same block to
   21|       |/// ensure that the control flow remains clear and predictable. This check
   22|       |/// verifies that both the goto statement and its target label share the same
   23|       |/// immediate compound statement (block) as their parent.
   24|       |///
   25|       |/// @par MISRA C:2023 Rule 15.2
   26|       |/// A goto statement and its corresponding label shall be in the same block.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   void f(int x) {
   32|       |///     if (x > 0) {
   33|       |///       goto label;  // Warning: label is in different block
   34|       |///     }
   35|       |///   label:  // label is at function scope, not in if block
   36|       |///     return;
   37|       |///   }
   38|       |/// @endcode
   39|       |///
   40|       |/// Compliant example:
   41|       |/// @code
   42|       |///   void f(int x) {
   43|       |///     if (x > 0) {
   44|       |///       goto label;
   45|       |///     label:  // Both goto and label in same if block
   46|       |///       return;
   47|       |///     }
   48|       |///   }
   49|       |/// @endcode
   50|       |class GotoLabelSameBlockCheck : public ClangTidyCheck {
   51|       |public:
   52|       |  /// Constructs the check with the given name and context.
   53|       |  /// \param Name The name of the check as registered.
   54|       |  /// \param Context The clang-tidy context for configuration.
   55|       |  GotoLabelSameBlockCheck(StringRef Name, ClangTidyContext *Context)
   56|    131|      : ClangTidyCheck(Name, Context) {}
   57|       |
   58|       |  /// Destructor.
   59|    131|  ~GotoLabelSameBlockCheck() override = default;
   60|       |
   61|       |  /// Registers AST matchers for goto statements.
   62|       |  /// \param Finder The match finder to register matchers with.
   63|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   64|       |
   65|       |  /// Handles matched goto statements and emits diagnostics if the target
   66|       |  /// label is in a different block.
   67|       |  /// \param Result The match result containing the matched AST node.
   68|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   69|       |};
   70|       |
   71|       |} // namespace clang::tidy::automotive
   72|       |
   73|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_GOTOLABELSAMEBLOCKCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/ForwardGotoLabelCheck.h:
    1|       |//===--- ForwardGotoLabelCheck.h - clang-tidy -------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FORWARDGOTOLABELCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FORWARDGOTOLABELCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "clang/Basic/SourceLocation.h"
   14|       |#include "llvm/ADT/DenseMap.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |struct GotoInfo {
   19|       |  const GotoStmt *MatchedLabel = nullptr;
   20|       |};
   21|       |
   22|       |/// @ingroup misra-c25-statements
   23|       |/// @brief Detects goto statements that jump backward in code.
   24|       |///
   25|       |/// Backward jumps with goto create loops that are harder to understand and
   26|       |/// analyze than structured loop constructs (for, while, do-while). This check
   27|       |/// ensures goto statements only jump forward if they must be used at all.
   28|       |///
   29|       |/// @par MISRA C:2025 Rule 15.3
   30|       |/// Any label referenced by a goto statement shall be declared in the same
   31|       |/// block, or in any block enclosing the goto statement.
   32|       |/// @par Category: Required
   33|       |///
   34|       |/// Example:
   35|       |/// @code
   36|       |///   label:
   37|       |///     x++;
   38|       |///     if (x < 10)
   39|       |///       goto label;  // Warning: backward jump
   40|       |/// @endcode
   41|       |class ForwardGotoLabelCheck : public ClangTidyCheck {
   42|       |public:
   43|       |  ForwardGotoLabelCheck(StringRef Name, ClangTidyContext *Context)
   44|    131|      : ClangTidyCheck(Name, Context) {}
   45|       |
   46|       |  /// Destructor.
   47|    131|  ~ForwardGotoLabelCheck() override = default;
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FORWARDGOTOLABELCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/statement/MultipleLoopTerminatorsCheck.cpp:
    1|       |//===--- MultipleLoopTerminatorsCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MultipleLoopTerminatorsCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/RecursiveASTVisitor.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |/// Visitor to count break and goto statements that terminate a loop
   21|       |class LoopTerminatorCounter
   22|       |    : public RecursiveASTVisitor<LoopTerminatorCounter> {
   23|       |public:
   24|       |  explicit LoopTerminatorCounter(const Stmt *TargetLoop)
   25|     45|      : TargetLoop(TargetLoop) {}
   26|       |
   27|     20|  bool VisitBreakStmt(BreakStmt *BS) {
   28|       |    // Only count breaks that terminate our target loop (not nested loops)
   29|     20|    if (CurrentLoopDepth == 1) {
  ------------------
  |  Branch (29:9): [True: 13, False: 7]
  ------------------
   30|     13|      TerminatorCount++;
   31|     13|      if (TerminatorCount == 2) {
  ------------------
  |  Branch (31:11): [True: 3, False: 10]
  ------------------
   32|      3|        SecondTerminatorLoc = BS->getBreakLoc();
   33|      3|      }
   34|     13|    }
   35|     20|    return true;
   36|     20|  }
   37|       |
   38|      6|  bool VisitGotoStmt(GotoStmt *GS) {
   39|       |    // Gotos could terminate the loop if jumping outside
   40|       |    // For simplicity, count all gotos within the loop body
   41|      6|    if (CurrentLoopDepth == 1) {
  ------------------
  |  Branch (41:9): [True: 6, False: 0]
  ------------------
   42|      6|      TerminatorCount++;
   43|      6|      if (TerminatorCount == 2) {
  ------------------
  |  Branch (43:11): [True: 2, False: 4]
  ------------------
   44|      2|        SecondTerminatorLoc = GS->getGotoLoc();
   45|      2|      }
   46|      6|    }
   47|      6|    return true;
   48|      6|  }
   49|       |
   50|       |  // Track nested loops - breaks in nested loops don't terminate outer loop
   51|     18|  bool TraverseWhileStmt(WhileStmt *WS) {
   52|     18|    if (WS == TargetLoop) {
  ------------------
  |  Branch (52:9): [True: 18, False: 0]
  ------------------
   53|     18|      CurrentLoopDepth++;
   54|     18|      bool Result = RecursiveASTVisitor::TraverseWhileStmt(WS);
   55|     18|      CurrentLoopDepth--;
   56|     18|      return Result;
   57|     18|    }
   58|       |    // Nested loop - increment depth to ignore its breaks
   59|      0|    CurrentLoopDepth++;
   60|      0|    bool Result = RecursiveASTVisitor::TraverseWhileStmt(WS);
   61|      0|    CurrentLoopDepth--;
   62|      0|    return Result;
   63|     18|  }
   64|       |
   65|      3|  bool TraverseDoStmt(DoStmt *DS) {
   66|      3|    if (DS == TargetLoop) {
  ------------------
  |  Branch (66:9): [True: 3, False: 0]
  ------------------
   67|      3|      CurrentLoopDepth++;
   68|      3|      bool Result = RecursiveASTVisitor::TraverseDoStmt(DS);
   69|      3|      CurrentLoopDepth--;
   70|      3|      return Result;
   71|      3|    }
   72|      0|    CurrentLoopDepth++;
   73|      0|    bool Result = RecursiveASTVisitor::TraverseDoStmt(DS);
   74|      0|    CurrentLoopDepth--;
   75|      0|    return Result;
   76|      3|  }
   77|       |
   78|     25|  bool TraverseForStmt(ForStmt *FS) {
   79|     25|    if (FS == TargetLoop) {
  ------------------
  |  Branch (79:9): [True: 24, False: 1]
  ------------------
   80|     24|      CurrentLoopDepth++;
   81|     24|      bool Result = RecursiveASTVisitor::TraverseForStmt(FS);
   82|     24|      CurrentLoopDepth--;
   83|     24|      return Result;
   84|     24|    }
   85|      1|    CurrentLoopDepth++;
   86|      1|    bool Result = RecursiveASTVisitor::TraverseForStmt(FS);
   87|      1|    CurrentLoopDepth--;
   88|      1|    return Result;
   89|     25|  }
   90|       |
   91|       |  // Don't count breaks inside switch statements as loop terminators
   92|      2|  bool TraverseSwitchStmt(SwitchStmt *SS) {
   93|      2|    CurrentLoopDepth++;
   94|      2|    bool Result = RecursiveASTVisitor::TraverseSwitchStmt(SS);
   95|      2|    CurrentLoopDepth--;
   96|      2|    return Result;
   97|      2|  }
   98|       |
   99|     45|  unsigned getTerminatorCount() const { return TerminatorCount; }
  100|      5|  SourceLocation getSecondTerminatorLoc() const { return SecondTerminatorLoc; }
  101|       |
  102|       |private:
  103|       |  const Stmt *TargetLoop;
  104|       |  unsigned TerminatorCount = 0;
  105|       |  unsigned CurrentLoopDepth = 0;
  106|       |  SourceLocation SecondTerminatorLoc;
  107|       |};
  108|       |
  109|       |} // anonymous namespace
  110|       |
  111|    131|void MultipleLoopTerminatorsCheck::registerMatchers(MatchFinder *Finder) {
  112|       |  // Match while, do-while, and for loops
  113|    131|  Finder->addMatcher(whileStmt().bind("loop"), this);
  114|    131|  Finder->addMatcher(doStmt().bind("loop"), this);
  115|    131|  Finder->addMatcher(forStmt().bind("loop"), this);
  116|    131|}
  117|       |
  118|       |void MultipleLoopTerminatorsCheck::check(
  119|    251|    const MatchFinder::MatchResult &Result) {
  120|    251|  const Stmt *Loop = Result.Nodes.getNodeAs<Stmt>("loop");
  121|    251|  if (!Loop)
  ------------------
  |  Branch (121:7): [True: 0, False: 251]
  ------------------
  122|      0|    return;
  123|       |
  124|       |  // Skip if in system header
  125|    251|  if (Result.SourceManager->isInSystemHeader(Loop->getBeginLoc()))
  ------------------
  |  Branch (125:7): [True: 206, False: 45]
  ------------------
  126|    206|    return;
  127|       |
  128|       |  // Count terminators in this loop
  129|     45|  LoopTerminatorCounter Counter(Loop);
  130|       |  // NOSONAR(S859): const_cast required by RecursiveASTVisitor API
  131|     45|  Counter.TraverseStmt(const_cast<Stmt *>(Loop));
  132|       |
  133|     45|  if (Counter.getTerminatorCount() > 1) {
  ------------------
  |  Branch (133:7): [True: 5, False: 40]
  ------------------
  134|      5|    diag(Counter.getSecondTerminatorLoc(),
  135|      5|         "loop has more than one break or goto terminator; "
  136|      5|         "only one terminator should be used per loop");
  137|      5|  }
  138|     45|}
  139|       |
  140|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/UnstructuredSwitchStmtCheck.cpp:
    1|       |//===--- UnstructuredSwitchStmtCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnstructuredSwitchStmtCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    262|StatementMatcher matchUnstructuredSwitch() {
   18|    262|  return allOf(unless(hasParent(compoundStmt(hasParent(switchStmt())))),
   19|    262|               hasParent(stmt(hasParent(stmt().bind("expectedSwitch")))
   20|    262|                             .bind("expectedCompound")));
   21|    262|}
   22|       |
   23|    131|void UnstructuredSwitchStmtCheck::registerMatchers(MatchFinder *Finder) {
   24|    131|  Finder->addMatcher(caseStmt(matchUnstructuredSwitch()).bind("case"), this);
   25|    131|  Finder->addMatcher(defaultStmt(matchUnstructuredSwitch()).bind("default"),
   26|    131|                     this);
   27|    131|}
   28|       |
   29|       |void UnstructuredSwitchStmtCheck::check(
   30|     18|    const MatchFinder::MatchResult &Result) {
   31|     18|  const auto *MatchedCase = Result.Nodes.getNodeAs<CaseStmt>("case");
   32|     18|  const auto *MatchedDefault = Result.Nodes.getNodeAs<DefaultStmt>("default");
   33|     18|  const auto *ExpectedCompound =
   34|     18|      Result.Nodes.getNodeAs<Stmt>("expectedCompound");
   35|     18|  const auto *ExpectedSwitch = Result.Nodes.getNodeAs<Stmt>("expectedSwitch");
   36|       |
   37|     18|  if (MatchedCase)
  ------------------
  |  Branch (37:7): [True: 13, False: 5]
  ------------------
   38|     13|    diag(MatchedCase->getCaseLoc(), "case statement at the wrong place");
   39|      5|  else if (MatchedDefault)
  ------------------
  |  Branch (39:12): [True: 5, False: 0]
  ------------------
   40|      5|    diag(MatchedDefault->getDefaultLoc(),
   41|      5|         "default statement at the wrong place");
   42|       |
   43|     18|  if (ExpectedSwitch) {
  ------------------
  |  Branch (43:7): [True: 18, False: 0]
  ------------------
   44|     18|    diag(ExpectedSwitch->getBeginLoc(), "expected switch statement",
   45|     18|         DiagnosticIDs::Note);
   46|     18|  }
   47|     18|  if (ExpectedCompound) {
  ------------------
  |  Branch (47:7): [True: 18, False: 0]
  ------------------
   48|     18|    diag(ExpectedCompound->getBeginLoc(), "expected compound statement",
   49|     18|         DiagnosticIDs::Note);
   50|     18|  }
   51|     18|}
   52|       |
   53|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/statement/GotoLabelSameBlockCheck.cpp:
    1|       |//===--- GotoLabelSameBlockCheck.cpp - clang-tidy ------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "GotoLabelSameBlockCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/ParentMapContext.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |/// Helper function to get the LabelStmt from a GotoStmt
   19|     29|static const LabelStmt *getLabelStmt(const GotoStmt *Goto) {
   20|     29|  if (!Goto)
  ------------------
  |  Branch (20:7): [True: 0, False: 29]
  ------------------
   21|      0|    return nullptr;
   22|       |
   23|     29|  const auto *Label = Goto->getLabel();
   24|     29|  return Label ? Label->getStmt() : nullptr;
  ------------------
  |  Branch (24:10): [True: 29, False: 0]
  ------------------
   25|     29|}
   26|       |
   27|       |/// Helper function to find the immediate parent CompoundStmt for a given Stmt
   28|       |/// Returns nullptr if no CompoundStmt parent is found
   29|       |static const CompoundStmt *findImmediateCompoundStmt(const Stmt *S,
   30|     58|                                                     ASTContext &Context) {
   31|     58|  if (!S)
  ------------------
  |  Branch (31:7): [True: 0, False: 58]
  ------------------
   32|      0|    return nullptr;
   33|       |
   34|     58|  DynTypedNodeList Parents = Context.getParents(*S);
   35|     70|  while (!Parents.empty()) {
  ------------------
  |  Branch (35:10): [True: 70, False: 0]
  ------------------
   36|       |    // Get the first parent
   37|     70|    const DynTypedNode &Parent = Parents[0];
   38|       |
   39|       |    // Check if this parent is a CompoundStmt
   40|     70|    if (const auto *CS = Parent.get<CompoundStmt>()) {
  ------------------
  |  Branch (40:21): [True: 58, False: 12]
  ------------------
   41|     58|      return CS;
   42|     58|    }
   43|       |
   44|       |    // Move up to the next parent
   45|     12|    Parents = Context.getParents(Parent);
   46|     12|  }
   47|       |
   48|      0|  return nullptr;
   49|     58|}
   50|       |
   51|    131|void GotoLabelSameBlockCheck::registerMatchers(MatchFinder *Finder) {
   52|    131|  Finder->addMatcher(gotoStmt().bind("goto"), this);
   53|    131|}
   54|       |
   55|     29|void GotoLabelSameBlockCheck::check(const MatchFinder::MatchResult &Result) {
   56|     29|  const auto *MatchedGoto = Result.Nodes.getNodeAs<GotoStmt>("goto");
   57|     29|  if (!MatchedGoto)
  ------------------
  |  Branch (57:7): [True: 0, False: 29]
  ------------------
   58|      0|    return;
   59|       |
   60|     29|  const auto *MatchedLabel = getLabelStmt(MatchedGoto);
   61|     29|  if (!MatchedLabel)
  ------------------
  |  Branch (61:7): [True: 0, False: 29]
  ------------------
   62|      0|    return;
   63|       |
   64|     29|  ASTContext &Context = *Result.Context;
   65|       |
   66|       |  // Find the immediate parent CompoundStmt for both goto and label
   67|     29|  const auto *GotoBlock = findImmediateCompoundStmt(MatchedGoto, Context);
   68|     29|  const auto *LabelBlock = findImmediateCompoundStmt(MatchedLabel, Context);
   69|       |
   70|       |  // If either doesn't have a CompoundStmt parent, or they're different blocks
   71|     29|  if (!GotoBlock || !LabelBlock || GotoBlock != LabelBlock) {
  ------------------
  |  Branch (71:7): [True: 0, False: 29]
  |  Branch (71:21): [True: 0, False: 29]
  |  Branch (71:36): [True: 17, False: 12]
  ------------------
   72|     17|    diag(MatchedGoto->getGotoLoc(),
   73|     17|         "goto statement and its label '%0' are not in the same block")
   74|     17|        << MatchedLabel->getName();
   75|     17|    diag(MatchedLabel->getBeginLoc(), "location of label '%0'",
   76|     17|         DiagnosticIDs::Note)
   77|     17|        << MatchedLabel->getName();
   78|     17|  }
   79|     29|}
   80|       |
   81|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/return/ReturnComponent.cpp:
    1|       |//===--- ReturnComponent.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ReturnComponent.h"
   10|       |#include "MissingReturnValueHandlingCheck.h"
   11|       |#include "MultipleReturnStmtCheck.h"
   12|       |#include "NoReturnVoidCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |void ReturnComponent::addCheckFactories(
   17|    262|    ClangTidyCheckFactories &CheckFactories) {
   18|       |
   19|    262|  CheckFactories.registerCheck<MultipleReturnStmtCheck>(
   20|    262|      "automotive-avoid-multiple-return-stmt");
   21|    262|  CheckFactories.registerCheck<MissingReturnValueHandlingCheck>(
   22|    262|      "automotive-missing-return-value-handling");
   23|    262|  CheckFactories.registerCheck<NoReturnVoidCheck>(
   24|    262|      "automotive-missing-return-void");
   25|    262|}
   26|       |
   27|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/return/MultipleReturnStmtCheck.cpp:
    1|       |//===--- MultipleReturnStmtCheck.cpp - clang-tidy -------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MultipleReturnStmtCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void MultipleReturnStmtCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      functionDecl(forEachDescendant(returnStmt().bind("returnStmt")))
   20|    131|          .bind("func"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|  2.93k|void MultipleReturnStmtCheck::check(const MatchFinder::MatchResult &Result) {
   25|  2.93k|  const auto *MatchedFunc = Result.Nodes.getNodeAs<FunctionDecl>("func");
   26|  2.93k|  const auto *MatchedReturn = Result.Nodes.getNodeAs<ReturnStmt>("returnStmt");
   27|       |
   28|  2.93k|  if (!MatchedFunc || !MatchedReturn)
  ------------------
  |  Branch (28:7): [True: 0, False: 2.93k]
  |  Branch (28:23): [True: 0, False: 2.93k]
  ------------------
   29|      0|    return;
   30|       |
   31|  2.93k|  if (MatchedFunc != CurrentFunc) {
  ------------------
  |  Branch (31:7): [True: 2.53k, False: 400]
  ------------------
   32|  2.53k|    CurrentFunc = MatchedFunc;
   33|  2.53k|    PreviousReturn = MatchedReturn;
   34|  2.53k|    return;
   35|  2.53k|  }
   36|       |
   37|    400|  if (PreviousReturn) {
  ------------------
  |  Branch (37:7): [True: 248, False: 152]
  ------------------
   38|    248|    diag(PreviousReturn->getBeginLoc(), "avoid multiple return statement");
   39|    248|    diag(MatchedFunc->getBeginLoc(),
   40|    248|         "multiple return statement within function", DiagnosticIDs::Note);
   41|    248|    PreviousReturn = nullptr;
   42|    248|  }
   43|    400|  diag(MatchedReturn->getBeginLoc(), "avoid multiple return statement");
   44|    400|}
   45|       |
   46|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/return/MultipleReturnStmtCheck.h:
    1|       |//===--- MultipleReturnStmtCheck.h - clang-tidy -----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLERETURNSTMTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLERETURNSTMTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects functions with multiple return statements.
   17|       |///
   18|       |/// Functions should have a single return point to simplify control flow
   19|       |/// and make the code easier to understand, debug, and verify. Multiple
   20|       |/// return statements can make it harder to track all exit paths and ensure
   21|       |/// proper resource cleanup before function exit.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 15.5 - A function should have a single point
   24|       |/// of exit at the end.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int func(int x) {
   29|       |///     if (x < 0) return -1;  // Warning: multiple returns
   30|       |///     return x * 2;
   31|       |///   }
   32|       |/// \endcode
   33|       |class MultipleReturnStmtCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  MultipleReturnStmtCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~MultipleReturnStmtCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for return statements.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched return statements and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |
   52|       |private:
   53|       |  const FunctionDecl *CurrentFunc = nullptr;
   54|       |  const ReturnStmt *PreviousReturn = nullptr;
   55|       |};
   56|       |
   57|       |} // namespace clang::tidy::automotive
   58|       |
   59|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MULTIPLERETURNSTMTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/return/MissingReturnValueHandlingCheck.h:
    1|       |//===--- MissingReturnValueHandlingCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGRETURNVALUEHANDLINGCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGRETURNVALUEHANDLINGCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects function calls where the return value is ignored.
   17|       |///
   18|       |/// When a function returns a value, that value should be used or explicitly
   19|       |/// discarded. Ignoring return values, especially error codes or status
   20|       |/// indicators, can lead to unchecked error conditions and program failures.
   21|       |/// This is particularly important for functions that return error status.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 17.7 - The value returned by a function having
   24|       |/// non-void return type shall be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int getStatus(void);
   29|       |///   getStatus();  // Warning: return value ignored
   30|       |/// \endcode
   31|       |class MissingReturnValueHandlingCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  MissingReturnValueHandlingCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~MissingReturnValueHandlingCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for function calls.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched function calls and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGRETURNVALUEHANDLINGCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/return/NoReturnVoidCheck.h:
    1|       |//===--- NoReturnVoidCheck.h - clang-tidy -----------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_NORETURNVOIDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_NORETURNVOIDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects void functions with return statements that have expressions.
   17|       |///
   18|       |/// A function with void return type should not return a value. Using return
   19|       |/// with an expression in a void function is either a mistake or indicates
   20|       |/// confusion about the function's contract. All void function returns should
   21|       |/// be simple "return;" statements without values.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 15.6 - The body of an iteration-statement or a
   24|       |/// selection-statement shall be a compound-statement.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   void func(void) {
   29|       |///     return 0;  // Warning: returning value from void function
   30|       |///   }
   31|       |/// \endcode
   32|       |class NoReturnVoidCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  NoReturnVoidCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~NoReturnVoidCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for return statements in void functions.
   44|       |  /// \param Finder The match finder to register matchers with.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched return statements and emits diagnostics.
   48|       |  /// \param Result The match result containing the matched AST node.
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_NORETURNVOIDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/return/MissingReturnValueHandlingCheck.cpp:
    1|       |//===--- MissingReturnValueHandlingCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingReturnValueHandlingCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void MissingReturnValueHandlingCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(callExpr(hasParent(compoundStmt()),
   19|    131|                              callee(functionDecl(unless(returns(voidType())))))
   20|    131|                         .bind("missingReturn"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|       |void MissingReturnValueHandlingCheck::check(
   25|     63|    const MatchFinder::MatchResult &Result) {
   26|     63|  const auto *MatchedDecl = Result.Nodes.getNodeAs<CallExpr>("missingReturn");
   27|       |
   28|     63|  if (MatchedDecl) {
  ------------------
  |  Branch (28:7): [True: 63, False: 0]
  ------------------
   29|     63|    diag(MatchedDecl->getBeginLoc(),
   30|     63|         "returned value from function is not used");
   31|     63|  }
   32|     63|}
   33|       |
   34|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/return/NoReturnVoidCheck.cpp:
    1|       |//===--- NoReturnVoidCheck.cpp - clang-tidy -------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "NoReturnVoidCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void NoReturnVoidCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(functionDecl(isNoReturn(), unless(hasReturnTypeLoc(
   19|    131|                                                    loc(asString("void")))))
   20|    131|                         .bind("func"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|     33|void NoReturnVoidCheck::check(const MatchFinder::MatchResult &Result) {
   25|     33|  const auto *MatchedDecl = Result.Nodes.getNodeAs<FunctionDecl>("func");
   26|     33|  if (MatchedDecl->getIdentifier()) {
  ------------------
  |  Branch (26:7): [True: 33, False: 0]
  ------------------
   27|     33|    diag(MatchedDecl->getLocation(), "use 'void' as return type")
   28|     33|        << MatchedDecl;
   29|     33|  }
   30|     33|}
   31|       |
   32|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidHashOperatorCheck.cpp:
    1|       |//===--- AvoidHashOperatorCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidHashOperatorCheck.h"
   10|       |#include "clang/Basic/TokenKinds.h"
   11|       |#include "clang/Lex/PPCallbacks.h"
   12|       |#include "clang/Lex/Preprocessor.h"
   13|       |
   14|       |using namespace clang::tok;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |class AvoidHashOperatorPPCallbacks : public PPCallbacks {
   21|       |public:
   22|    131|  explicit AvoidHashOperatorPPCallbacks(ClangTidyCheck &Check) : Check(Check) {}
   23|       |
   24|       |  void MacroDefined(const Token &MacroNameTok,
   25|       |                    const MacroDirective *MD) override;
   26|       |
   27|       |private:
   28|       |  ClangTidyCheck &Check;
   29|       |};
   30|       |
   31|       |void AvoidHashOperatorPPCallbacks::MacroDefined(const Token &MacroNameTok,
   32|  64.1k|                                                const MacroDirective *MD) {
   33|  64.1k|  const MacroInfo *Info = MD->getMacroInfo();
   34|       |
   35|  64.1k|  if (Info) {
  ------------------
  |  Branch (35:7): [True: 64.1k, False: 0]
  ------------------
   36|  91.5k|    for (const Token &Tok : Info->tokens()) {
  ------------------
  |  Branch (36:27): [True: 91.5k, False: 64.1k]
  ------------------
   37|       |
   38|  91.5k|      if (Tok.isOneOf(tok::hash, tok::hashhash)) {
  ------------------
  |  Branch (38:11): [True: 1.02k, False: 90.4k]
  ------------------
   39|  1.02k|        SourceLocation Loc = Tok.getLocation();
   40|  1.02k|        Check.diag(Loc, "avoid preprocessor operator '%0'")
   41|  1.02k|            << getPunctuatorSpelling(Tok.getKind());
   42|  1.02k|      }
   43|  91.5k|    }
   44|  64.1k|  }
   45|  64.1k|}
   46|       |
   47|       |} // anonymous namespace
   48|       |
   49|       |void AvoidHashOperatorCheck::registerPPCallbacks(
   50|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   51|    131|  PP->addPPCallbacks(std::make_unique<AvoidHashOperatorPPCallbacks>(*this));
   52|    131|}
   53|       |
   54|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMacroIdentifierConflictCheck.h:
    1|       |//===--- AvoidMacroIdentifierConflictCheck.h - clang-tidy -------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACROIDENTIFIERCONFLICTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACROIDENTIFIERCONFLICTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "llvm/ADT/StringMap.h"
   14|       |#include <string>
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |/// @ingroup misra-c25-preprocessor
   19|       |/// @brief Detects macro identifiers that conflict with other identifiers.
   20|       |///
   21|       |/// Macro identifiers shall be distinct from other identifiers (variables,
   22|       |/// functions, types, labels) in the translation unit. Having the same name
   23|       |/// for a macro and another identifier can lead to confusion and unexpected
   24|       |/// behavior during preprocessing.
   25|       |///
   26|       |/// @par MISRA C:2023 Rule 5.4
   27|       |/// Macro identifiers shall be distinct from other identifiers.
   28|       |/// @par Category: Required
   29|       |///
   30|       |/// Example:
   31|       |/// @code
   32|       |///   #define MAX_SIZE 100
   33|       |///   int MAX_SIZE;           // Warning: variable has same name as macro
   34|       |///
   35|       |///   #define calculate(x) ((x) * 2)
   36|       |///   void calculate(int x);  // Warning: function has same name as macro
   37|       |/// @endcode
   38|       |class AvoidMacroIdentifierConflictCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  AvoidMacroIdentifierConflictCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~AvoidMacroIdentifierConflictCheck() override = default;
   45|       |
   46|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   47|       |                           Preprocessor *ModuleExpanderPP) override;
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |  void onEndOfTranslationUnit() override;
   51|       |
   52|       |  // Storage for macro names and their locations
   53|       |  struct MacroInfo {
   54|       |    std::string Name;
   55|       |    SourceLocation Location;
   56|       |  };
   57|       |
   58|       |  void addMacro(StringRef Name, SourceLocation Loc);
   59|       |  void addIdentifier(StringRef Name, SourceLocation Loc, StringRef Type);
   60|       |
   61|       |private:
   62|       |  llvm::StringMap<SourceLocation> MacroNames;
   63|       |  llvm::StringMap<std::pair<SourceLocation, std::string>> IdentifierNames;
   64|       |};
   65|       |
   66|       |} // namespace clang::tidy::automotive
   67|       |
   68|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACROIDENTIFIERCONFLICTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/MissingHeaderGuardCheck.h:
    1|       |//===--- MissingHeaderGuardCheck.h - clang-tidy ----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGHEADERGUARDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGHEADERGUARDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects header files that lack proper include guard protection.
   18|       |///
   19|       |/// Header files should be protected against multiple inclusion to prevent
   20|       |/// compilation errors and improve build performance. This can be achieved
   21|       |/// using either traditional include guards (#ifndef/#define/#endif pattern)
   22|       |/// or the #pragma once directive.
   23|       |///
   24|       |/// @par MISRA C:2023 Directive 4.10
   25|       |/// Precautions shall be taken in order to prevent the contents of a header
   26|       |/// file being included more than once.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example of compliant code with traditional guards:
   30|       |/// @code
   31|       |///   // header.h
   32|       |///   #ifndef HEADER_H
   33|       |///   #define HEADER_H
   34|       |///
   35|       |///   void foo();
   36|       |///
   37|       |///   #endif // HEADER_H
   38|       |/// @endcode
   39|       |///
   40|       |/// Example of compliant code with #pragma once:
   41|       |/// @code
   42|       |///   // header.h
   43|       |///   #pragma once
   44|       |///
   45|       |///   void foo();
   46|       |/// @endcode
   47|       |///
   48|       |/// Example of non-compliant code (no protection):
   49|       |/// @code
   50|       |///   // header.h - WARNING: missing header guard
   51|       |///   void foo();
   52|       |/// @endcode
   53|       |class MissingHeaderGuardCheck : public ClangTidyCheck {
   54|       |public:
   55|       |  MissingHeaderGuardCheck(StringRef Name, ClangTidyContext *Context)
   56|    131|      : ClangTidyCheck(Name, Context) {}
   57|       |
   58|       |  /// Destructor.
   59|    131|  ~MissingHeaderGuardCheck() override = default;
   60|       |
   61|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   62|       |                           Preprocessor *ModuleExpanderPP) override;
   63|       |};
   64|       |
   65|       |} // namespace clang::tidy::automotive
   66|       |
   67|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGHEADERGUARDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidReservedMacroIdentifierCheck.h:
    1|       |//===--- AvoidReservedMacroIdentifierCheck.h - clang-tidy -------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDMACROIDENTIFIERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDMACROIDENTIFIERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects #define and #undef of reserved identifiers.
   18|       |///
   19|       |/// Reserved identifiers (those starting with underscore followed by uppercase
   20|       |/// or another underscore, and standard library names) shall not be defined or
   21|       |/// undefined. Modifying these can cause undefined behavior and break the
   22|       |/// standard library.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 21.1
   25|       |/// #define and #undef shall not be used on a reserved identifier or reserved
   26|       |/// macro name.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   #define _RESERVED 1     // Warning: starts with underscore + uppercase
   32|       |///   #define __internal 2    // Warning: starts with double underscore
   33|       |///   #define errno 0         // Warning: standard library name
   34|       |///   #undef NULL             // Warning: standard library name
   35|       |/// @endcode
   36|       |class AvoidReservedMacroIdentifierCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidReservedMacroIdentifierCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidReservedMacroIdentifierCheck() override = default;
   43|       |
   44|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   45|       |                           Preprocessor *ModuleExpanderPP) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDRESERVEDMACROIDENTIFIERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMultipleHashOperatorsCheck.h:
    1|       |//===--- AvoidMultipleHashOperatorsCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMULTIPLEHASHOPERATORSCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMULTIPLEHASHOPERATORSCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the ## token pasting operator in macros.
   17|       |///
   18|       |/// The ## operator in preprocessor macros concatenates tokens, which can
   19|       |/// create identifiers in unexpected ways. This makes code harder to search,
   20|       |/// understand, and debug. Token pasting can also lead to subtle bugs when
   21|       |/// tokens combine in unintended ways.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 20.11 - The ## operator should not be used.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   #define CONCAT(a, b) a##b  // Warning: ## operator used
   28|       |/// \endcode
   29|       |class AvoidMultipleHashOperatorsCheck : public ClangTidyCheck {
   30|       |public:
   31|       |  /// Constructs the check with the given name and context.
   32|       |  /// \param Name The name of the check as registered.
   33|       |  /// \param Context The clang-tidy context for configuration.
   34|       |  AvoidMultipleHashOperatorsCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|       |  /// Destructor.
   38|    131|  ~AvoidMultipleHashOperatorsCheck() override = default;
   39|       |
   40|       |  /// Registers preprocessor callbacks for macro definition handling.
   41|       |  /// \param SM The source manager.
   42|       |  /// \param PP The preprocessor instance.
   43|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   44|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   45|       |                           Preprocessor *ModuleExpanderPP) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMULTIPLEHASHOPERATORSCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/PreprocessorComponent.cpp:
    1|       |//===--- PreprocessorComponent.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "PreprocessorComponent.h"
   10|       |#include "AvoidCodeBeforeIncludeCheck.h"
   11|       |#include "AvoidHashOperatorCheck.h"
   12|       |#include "AvoidIncludeSyntaxErrorCheck.h"
   13|       |#include "AvoidInvalidHeaderCharCheck.h"
   14|       |#include "AvoidLanguageExtensionCheck.h"
   15|       |#include "AvoidMacroIdentifierConflictCheck.h"
   16|       |#include "AvoidMacroNamedAsCkeywordCheck.h"
   17|       |#include "AvoidMultipleHashOperatorsCheck.h"
   18|       |#include "AvoidReservedMacroIdentifierCheck.h"
   19|       |#include "AvoidUndefCheck.h"
   20|       |#include "MissingHeaderGuardCheck.h"
   21|       |#include "UnusedMacroCheck.h"
   22|       |
   23|       |namespace clang::tidy::automotive {
   24|       |
   25|       |void PreprocessorComponent::addCheckFactories(
   26|    262|    ClangTidyCheckFactories &CheckFactories) {
   27|       |
   28|    262|  CheckFactories.registerCheck<AvoidMacroNamedAsCkeywordCheck>(
   29|    262|      "automotive-avoid-macro-named-as-ckeyword");
   30|       |
   31|    262|  CheckFactories.registerCheck<UnusedMacroCheck>("automotive-unused-macro");
   32|    262|  CheckFactories.registerCheck<AvoidUndefCheck>("automotive-avoid-undef");
   33|    262|  CheckFactories.registerCheck<AvoidHashOperatorCheck>(
   34|    262|      "automotive-avoid-hash-operator");
   35|    262|  CheckFactories.registerCheck<AvoidMultipleHashOperatorsCheck>(
   36|    262|      "automotive-avoid-multiple-hash-operators");
   37|       |
   38|       |  // Rule 20.1 - Include directive order
   39|    262|  CheckFactories.registerCheck<AvoidCodeBeforeIncludeCheck>(
   40|    262|      "automotive-avoid-code-before-include");
   41|       |
   42|       |  // Rule 20.2 - Invalid characters in header names
   43|    262|  CheckFactories.registerCheck<AvoidInvalidHeaderCharCheck>(
   44|    262|      "automotive-avoid-invalid-header-char");
   45|       |
   46|       |  // Rule 20.3 - Include syntax validation
   47|    262|  CheckFactories.registerCheck<AvoidIncludeSyntaxErrorCheck>(
   48|    262|      "automotive-c23-req-20.3");
   49|       |
   50|       |  // Rule 21.1 - Reserved macro identifiers
   51|    262|  CheckFactories.registerCheck<AvoidReservedMacroIdentifierCheck>(
   52|    262|      "automotive-avoid-reserved-macro-identifier");
   53|       |
   54|       |  // Rule 5.4 - Macro identifier conflicts
   55|    262|  CheckFactories.registerCheck<AvoidMacroIdentifierConflictCheck>(
   56|    262|      "automotive-c23-req-5.4");
   57|       |
   58|       |  // Directive 4.10 - Header guard protection
   59|    262|  CheckFactories.registerCheck<MissingHeaderGuardCheck>(
   60|    262|      "automotive-c23-req-dir-4.10");
   61|       |
   62|       |  // Rule 1.2 - Language extensions (Advisory)
   63|    262|  CheckFactories.registerCheck<AvoidLanguageExtensionCheck>(
   64|    262|      "automotive-c23-adv-1.2");
   65|    262|}
   66|       |
   67|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidLanguageExtensionCheck.h:
    1|       |//===--- AvoidLanguageExtensionCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLANGUAGEEXTENSIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLANGUAGEEXTENSIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of compiler-specific language extensions.
   17|       |///
   18|       |/// MISRA C:2025 Rule 1.2 (Advisory) recommends that language extensions
   19|       |/// should not be used, as they reduce code portability across different
   20|       |/// compilers and platforms.
   21|       |///
   22|       |/// This check detects common GCC/Clang extensions including:
   23|       |/// - __attribute__ specifiers
   24|       |/// - __typeof__ and typeof expressions
   25|       |/// - __extension__ keyword
   26|       |/// - Statement expressions ({ ... })
   27|       |/// - Compound literals in non-standard contexts
   28|       |///
   29|       |/// Example of non-compliant code:
   30|       |/// \code
   31|       |///   int x __attribute__((aligned(16)));
   32|       |///   __typeof__(x) y;
   33|       |/// \endcode
   34|       |class AvoidLanguageExtensionCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  /// Constructs the check with the given name and context.
   37|       |  AvoidLanguageExtensionCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidLanguageExtensionCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for extension constructs.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched extensions and emits diagnostics.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLANGUAGEEXTENSIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/UnusedMacroCheck.cpp:
    1|       |//===--- UnusedMacroCheck.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedMacroCheck.h"
   10|       |#include "clang/Lex/Preprocessor.h"
   11|       |
   12|       |namespace clang::tidy::automotive {
   13|       |
   14|       |namespace {
   15|       |
   16|       |class UnusedMacroPPCallbacks : public PPCallbacks {
   17|       |public:
   18|       |  explicit UnusedMacroPPCallbacks(UnusedMacroCheck &Check,
   19|       |                                  const SourceManager &SM)
   20|    131|      : Check(Check), SM(SM) {}
   21|       |
   22|       |  void MacroDefined(const Token &MacroNameTok,
   23|       |                    const MacroDirective *MD) override;
   24|       |  void MacroExpands(const Token &MacroNameTok, const MacroDefinition &MD,
   25|       |                    SourceRange Range, const MacroArgs *Args) override;
   26|       |  void MacroUndefined(const Token &MacroNameTok, const MacroDefinition &MD,
   27|       |                      const MacroDirective *Undef) override;
   28|       |  void EndOfMainFile() override;
   29|       |
   30|       |private:
   31|       |  UnusedMacroCheck &Check;
   32|       |  const SourceManager &SM;
   33|       |  llvm::StringMap<std::pair<bool, SourceLocation>> MacroUsage;
   34|       |};
   35|       |
   36|       |void UnusedMacroPPCallbacks::MacroDefined(const Token &MacroNameTok,
   37|  64.1k|                                          const MacroDirective *MD) {
   38|  64.1k|  StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   39|  64.1k|  SourceLocation Loc = MacroNameTok.getLocation();
   40|  64.1k|  MacroUsage[MacroName] = {false, Loc};
   41|  64.1k|}
   42|       |
   43|       |void UnusedMacroPPCallbacks::MacroExpands(const Token &MacroNameTok,
   44|       |                                          const MacroDefinition &MD,
   45|       |                                          SourceRange Range,
   46|  21.2k|                                          const MacroArgs *Args) {
   47|  21.2k|  StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   48|  21.2k|  MacroUsage[MacroName].first = true;
   49|  21.2k|}
   50|       |
   51|       |void UnusedMacroPPCallbacks::MacroUndefined(const Token &MacroNameTok,
   52|       |                                            const MacroDefinition &MD,
   53|  1.91k|                                            const MacroDirective *Undef) {
   54|  1.91k|  StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   55|  1.91k|  MacroUsage[MacroName].first = true;
   56|  1.91k|}
   57|       |
   58|    131|void UnusedMacroPPCallbacks::EndOfMainFile() {
   59|  64.5k|  for (const auto &Entry : MacroUsage) {
  ------------------
  |  Branch (59:26): [True: 64.5k, False: 131]
  ------------------
   60|  64.5k|    if (!Entry.getValue().first) {
  ------------------
  |  Branch (60:9): [True: 61.0k, False: 3.52k]
  ------------------
   61|  61.0k|      SourceLocation Loc = Entry.getValue().second;
   62|       |
   63|  61.0k|      if (SM.isWrittenInMainFile(Loc) && !SM.isInSystemHeader(Loc)) {
  ------------------
  |  Branch (63:11): [True: 105, False: 60.9k]
  |  Branch (63:42): [True: 105, False: 0]
  ------------------
   64|    105|        Check.diag(Loc, "unused macro definition '%0'") << Entry.getKey();
   65|    105|      }
   66|  61.0k|    }
   67|  64.5k|  }
   68|    131|}
   69|       |
   70|       |} // anonymous namespace
   71|       |
   72|       |void UnusedMacroCheck::registerPPCallbacks(const SourceManager &SM,
   73|       |                                           Preprocessor *PP,
   74|    131|                                           Preprocessor *ModuleExpanderPP) {
   75|    131|  PP->addPPCallbacks(std::make_unique<UnusedMacroPPCallbacks>(*this, SM));
   76|    131|}
   77|       |
   78|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidUndefCheck.cpp:
    1|       |//===--- AvoidUndefCheck.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidUndefCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |
   19|       |class AvoidUndefPPCallbacks : public PPCallbacks {
   20|       |public:
   21|    131|  explicit AvoidUndefPPCallbacks(ClangTidyCheck &Check) : Check(Check) {}
   22|       |
   23|       |  void MacroUndefined(const Token &MacroNameTok, const MacroDefinition &MD,
   24|       |                      const MacroDirective *Undef) override;
   25|       |
   26|       |private:
   27|       |  ClangTidyCheck &Check;
   28|       |};
   29|       |
   30|       |void AvoidUndefPPCallbacks::MacroUndefined(const Token &MacroNameTok,
   31|       |                                           const MacroDefinition &MD,
   32|  1.91k|                                           const MacroDirective *Undef) {
   33|  1.91k|  if (Undef) {
  ------------------
  |  Branch (33:7): [True: 348, False: 1.56k]
  ------------------
   34|    348|    Check.diag(Undef->getLocation(), "avoid #undef");
   35|    348|  }
   36|  1.91k|}
   37|       |
   38|       |} // anonymous namespace
   39|       |
   40|       |void AvoidUndefCheck::registerPPCallbacks(const SourceManager &SM,
   41|       |                                          Preprocessor *PP,
   42|    131|                                          Preprocessor *ModuleExpanderPP) {
   43|    131|  PP->addPPCallbacks(::std::make_unique<AvoidUndefPPCallbacks>(*this));
   44|    131|}
   45|       |
   46|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidInvalidHeaderCharCheck.h:
    1|       |//===--- AvoidInvalidHeaderCharCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINVALIDHEADERCHARCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINVALIDHEADERCHARCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects invalid characters in #include header file names.
   18|       |///
   19|       |/// The characters ', ", and \ shall not appear in header file names used
   20|       |/// with #include directives. These characters can cause portability issues
   21|       |/// and undefined behavior across different compilers and platforms.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 20.2
   24|       |/// The ', " and \ characters shall not occur in a header file name.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   #include "file'name.h"    // Warning: ' in header name
   30|       |///   #include "path\\file.h"   // Warning: \ in header name
   31|       |///   #include "file\"name.h"   // Warning: " in header name
   32|       |/// @endcode
   33|       |class AvoidInvalidHeaderCharCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidInvalidHeaderCharCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidInvalidHeaderCharCheck() override = default;
   40|       |
   41|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   42|       |                           Preprocessor *ModuleExpanderPP) override;
   43|       |};
   44|       |
   45|       |} // namespace clang::tidy::automotive
   46|       |
   47|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINVALIDHEADERCHARCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMacroIdentifierConflictCheck.cpp:
    1|       |//===--- AvoidMacroIdentifierConflictCheck.cpp - clang-tidy --------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidMacroIdentifierConflictCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "clang/Lex/PPCallbacks.h"
   13|       |#include "clang/Lex/Preprocessor.h"
   14|       |
   15|       |using namespace clang::ast_matchers;
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |namespace {
   20|       |
   21|       |class MacroIdentifierPPCallbacks : public PPCallbacks {
   22|       |public:
   23|       |  MacroIdentifierPPCallbacks(AvoidMacroIdentifierConflictCheck &Check,
   24|       |                             const SourceManager &SM)
   25|    131|      : Check(Check), SM(SM) {}
   26|       |
   27|       |  void MacroDefined(const Token &MacroNameTok,
   28|  64.1k|                    const MacroDirective *MD) override {
   29|       |    // Skip macros defined in system headers
   30|  64.1k|    if (SM.isInSystemHeader(MacroNameTok.getLocation()))
  ------------------
  |  Branch (30:9): [True: 63.8k, False: 285]
  ------------------
   31|  63.8k|      return;
   32|       |
   33|    285|    StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   34|    285|    SourceLocation Loc = MacroNameTok.getLocation();
   35|    285|    Check.addMacro(MacroName, Loc);
   36|    285|  }
   37|       |
   38|       |private:
   39|       |  AvoidMacroIdentifierConflictCheck &Check;
   40|       |  const SourceManager &SM;
   41|       |};
   42|       |
   43|       |} // anonymous namespace
   44|       |
   45|       |void AvoidMacroIdentifierConflictCheck::addMacro(StringRef Name,
   46|    285|                                                 SourceLocation Loc) {
   47|       |  // Store macro name and location for later comparison with AST identifiers
   48|    285|  MacroNames[Name] = Loc;
   49|       |
   50|       |  // Check if this macro conflicts with an already seen identifier
   51|    285|  auto It = IdentifierNames.find(Name);
   52|    285|  if (It != IdentifierNames.end()) {
  ------------------
  |  Branch (52:7): [True: 0, False: 285]
  ------------------
   53|      0|    SourceLocation IdentLoc = It->second.first;
   54|      0|    StringRef IdentType = It->second.second;
   55|       |
   56|       |    // Report the conflict
   57|      0|    diag(Loc, "macro '%0' conflicts with %1 identifier") << Name << IdentType;
   58|      0|    diag(IdentLoc, "%0 '%1' declared here", DiagnosticIDs::Note)
   59|      0|        << IdentType << Name;
   60|      0|  }
   61|    285|}
   62|       |
   63|       |void AvoidMacroIdentifierConflictCheck::addIdentifier(StringRef Name,
   64|       |                                                      SourceLocation Loc,
   65|  2.58k|                                                      StringRef Type) {
   66|       |  // Store identifier name, location, and type for later comparison with macros
   67|       |  // Only store the first occurrence of each identifier
   68|  2.58k|  if (IdentifierNames.find(Name) == IdentifierNames.end()) {
  ------------------
  |  Branch (68:7): [True: 1.92k, False: 663]
  ------------------
   69|  1.92k|    IdentifierNames[Name] = std::make_pair(Loc, Type.str());
   70|  1.92k|  }
   71|  2.58k|}
   72|       |
   73|       |void AvoidMacroIdentifierConflictCheck::registerPPCallbacks(
   74|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   75|    131|  PP->addPPCallbacks(std::make_unique<MacroIdentifierPPCallbacks>(*this, SM));
   76|    131|}
   77|       |
   78|    131|void AvoidMacroIdentifierConflictCheck::registerMatchers(MatchFinder *Finder) {
   79|       |  // Match variable declarations
   80|    131|  Finder->addMatcher(varDecl(unless(isImplicit())).bind("var"), this);
   81|       |
   82|       |  // Match function declarations
   83|    131|  Finder->addMatcher(functionDecl(unless(isImplicit())).bind("func"), this);
   84|       |
   85|       |  // Match typedef declarations
   86|    131|  Finder->addMatcher(typedefDecl(unless(isImplicit())).bind("typedef"), this);
   87|       |
   88|       |  // Match type alias declarations (using)
   89|    131|  Finder->addMatcher(typeAliasDecl(unless(isImplicit())).bind("alias"), this);
   90|       |
   91|       |  // Match record declarations (struct, union)
   92|    131|  Finder->addMatcher(recordDecl(unless(isImplicit())).bind("record"), this);
   93|       |
   94|       |  // Match enum declarations
   95|    131|  Finder->addMatcher(enumDecl().bind("enum"), this);
   96|       |
   97|       |  // Match enum constant declarations
   98|    131|  Finder->addMatcher(enumConstantDecl().bind("enumConst"), this);
   99|       |
  100|       |  // Match label statements
  101|    131|  Finder->addMatcher(labelStmt().bind("label"), this);
  102|    131|}
  103|       |
  104|       |void AvoidMacroIdentifierConflictCheck::check(
  105|  36.0k|    const MatchFinder::MatchResult &Result) {
  106|  36.0k|  const NamedDecl *Decl = nullptr;
  107|  36.0k|  StringRef DeclType;
  108|  36.0k|  std::string Name;
  109|  36.0k|  SourceLocation DeclLoc;
  110|       |
  111|  36.0k|  if (const auto *Var = Result.Nodes.getNodeAs<VarDecl>("var")) {
  ------------------
  |  Branch (111:19): [True: 18.2k, False: 17.7k]
  ------------------
  112|  18.2k|    Decl = Var;
  113|  18.2k|    DeclType = "variable";
  114|  18.2k|  } else if (const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("func")) {
  ------------------
  |  Branch (114:26): [True: 9.00k, False: 8.74k]
  ------------------
  115|  9.00k|    Decl = Func;
  116|  9.00k|    DeclType = "function";
  117|  9.00k|  } else if (const auto *TD = Result.Nodes.getNodeAs<TypedefDecl>("typedef")) {
  ------------------
  |  Branch (117:26): [True: 3.86k, False: 4.88k]
  ------------------
  118|  3.86k|    Decl = TD;
  119|  3.86k|    DeclType = "typedef";
  120|  4.88k|  } else if (const auto *TA = Result.Nodes.getNodeAs<TypeAliasDecl>("alias")) {
  ------------------
  |  Branch (120:26): [True: 1.16k, False: 3.71k]
  ------------------
  121|  1.16k|    Decl = TA;
  122|  1.16k|    DeclType = "type alias";
  123|  3.71k|  } else if (const auto *RD = Result.Nodes.getNodeAs<RecordDecl>("record")) {
  ------------------
  |  Branch (123:26): [True: 3.14k, False: 573]
  ------------------
  124|  3.14k|    Decl = RD;
  125|  3.14k|    DeclType = RD->isUnion() ? "union" : "struct";
  ------------------
  |  Branch (125:16): [True: 62, False: 3.08k]
  ------------------
  126|  3.14k|  } else if (const auto *ED = Result.Nodes.getNodeAs<EnumDecl>("enum")) {
  ------------------
  |  Branch (126:26): [True: 201, False: 372]
  ------------------
  127|    201|    Decl = ED;
  128|    201|    DeclType = "enum";
  129|    372|  } else if (const auto *EC =
  ------------------
  |  Branch (129:26): [True: 344, False: 28]
  ------------------
  130|    372|                 Result.Nodes.getNodeAs<EnumConstantDecl>("enumConst")) {
  131|    344|    Decl = EC;
  132|    344|    DeclType = "enum constant";
  133|    344|  } else if (const auto *LS = Result.Nodes.getNodeAs<LabelStmt>("label")) {
  ------------------
  |  Branch (133:26): [True: 28, False: 0]
  ------------------
  134|       |    // Handle label statements separately since they don't have a NamedDecl
  135|     28|    Name = LS->getName();
  136|     28|    DeclLoc = LS->getIdentLoc();
  137|     28|    DeclType = "label";
  138|     28|  }
  139|       |
  140|  36.0k|  if (Decl) {
  ------------------
  |  Branch (140:7): [True: 35.9k, False: 28]
  ------------------
  141|       |    // Skip declarations in system headers
  142|  35.9k|    if (Result.SourceManager->isInSystemHeader(Decl->getLocation()))
  ------------------
  |  Branch (142:9): [True: 32.6k, False: 3.34k]
  ------------------
  143|  32.6k|      return;
  144|       |
  145|       |    // Skip unnamed declarations
  146|  3.34k|    if (!Decl->getIdentifier())
  ------------------
  |  Branch (146:9): [True: 793, False: 2.55k]
  ------------------
  147|    793|      return;
  148|       |
  149|  2.55k|    Name = Decl->getName().str();
  150|  2.55k|    DeclLoc = Decl->getLocation();
  151|  2.55k|  }
  152|       |
  153|  2.58k|  if (Name.empty())
  ------------------
  |  Branch (153:7): [True: 0, False: 2.58k]
  ------------------
  154|      0|    return;
  155|       |
  156|       |  // Store this identifier for later comparison with macros
  157|  2.58k|  addIdentifier(Name, DeclLoc, DeclType);
  158|       |
  159|       |  // Check if this identifier conflicts with a macro
  160|  2.58k|  auto It = MacroNames.find(Name);
  161|  2.58k|  if (It != MacroNames.end()) {
  ------------------
  |  Branch (161:7): [True: 3, False: 2.58k]
  ------------------
  162|      3|    SourceLocation MacroLoc = It->second;
  163|       |
  164|       |    // Report the conflict
  165|      3|    diag(DeclLoc, "%0 '%1' conflicts with macro identifier")
  166|      3|        << DeclType << Name;
  167|      3|    diag(MacroLoc, "macro '%0' defined here", DiagnosticIDs::Note) << Name;
  168|      3|  }
  169|  2.58k|}
  170|       |
  171|    131|void AvoidMacroIdentifierConflictCheck::onEndOfTranslationUnit() {
  172|       |  // Clear the maps after processing the translation unit
  173|    131|  MacroNames.clear();
  174|    131|  IdentifierNames.clear();
  175|    131|}
  176|       |
  177|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/UnusedMacroCheck.h:
    1|       |//===--- UnusedMacroCheck.h - clang-tidy ------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDMACROCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDMACROCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects macros that are defined but never used.
   18|       |///
   19|       |/// Unused macros indicate dead code that should be removed. They may be
   20|       |/// remnants of old code, debugging aids left behind, or incomplete
   21|       |/// implementations that were never finished.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 2.5
   24|       |/// A project should not contain unused macro declarations.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   #define UNUSED_MACRO 42  // Warning: macro never used
   30|       |///
   31|       |///   #define USED_MACRO 100
   32|       |///   int x = USED_MACRO;      // OK: macro is used
   33|       |/// @endcode
   34|       |class UnusedMacroCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  UnusedMacroCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~UnusedMacroCheck() override = default;
   41|       |
   42|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   43|       |                           Preprocessor *ModuleExpanderPP) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDMACROCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMacroNamedAsCkeywordCheck.cpp:
    1|       |//===--- AvoidMacroNamedAsCkeywordCheck.cpp - clang-tidy ------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidMacroNamedAsCkeywordCheck.h"
   10|       |#include "../utils/CKeywordSet.h"
   11|       |#include "clang/Lex/PPCallbacks.h"
   12|       |#include "clang/Lex/Preprocessor.h"
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |
   19|       |class AvoidMacroNamedAsCkeywordPPCallbacks : public PPCallbacks {
   20|       |public:
   21|       |  AvoidMacroNamedAsCkeywordPPCallbacks(const LangOptions &LangOpts,
   22|       |                                       ClangTidyCheck &Check)
   23|    131|      : CKeywords(LangOpts), Check(Check) {}
   24|       |
   25|       |  void MacroDefined(const Token &MacroNameTok,
   26|  64.1k|                    const MacroDirective *MD) override {
   27|  64.1k|    StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   28|       |
   29|  64.1k|    if (CKeywords.isKeyword(MacroName)) {
  ------------------
  |  Branch (29:9): [True: 2, False: 64.0k]
  ------------------
   30|      2|      Check.diag(MacroNameTok.getLocation(),
   31|      2|                 "macro name '%0' conflicts with C keyword")
   32|      2|          << MacroName;
   33|      2|    }
   34|  64.1k|  }
   35|       |
   36|       |private:
   37|       |  CKeywordSet CKeywords;
   38|       |  ClangTidyCheck &Check;
   39|       |};
   40|       |
   41|       |} // anonymous namespace
   42|       |
   43|       |void AvoidMacroNamedAsCkeywordCheck::registerPPCallbacks(
   44|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   45|    131|  PP->addPPCallbacks(std::make_unique<AvoidMacroNamedAsCkeywordPPCallbacks>(
   46|    131|      PP->getLangOpts(), *this));
   47|    131|}
   48|       |
   49|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidCodeBeforeIncludeCheck.h:
    1|       |//===--- AvoidCodeBeforeIncludeCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCODEBEFOREINCLUDECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCODEBEFOREINCLUDECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects #include directives preceded by code other than preprocessor
   18|       |/// directives or comments.
   19|       |///
   20|       |/// Header file inclusions should appear at the beginning of a file, before any
   21|       |/// code. Only preprocessor directives and comments should precede #include
   22|       |/// statements to ensure headers are processed in a clean environment.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 20.1
   25|       |/// #include directives should only be preceded by preprocessor directives or
   26|       |/// comments.
   27|       |/// @par Category: Advisory
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   int x = 1;           // Code before include
   32|       |///   #include <stdio.h>   // Warning: code precedes #include
   33|       |/// @endcode
   34|       |class AvoidCodeBeforeIncludeCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  AvoidCodeBeforeIncludeCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidCodeBeforeIncludeCheck() override = default;
   41|       |
   42|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   43|       |                           Preprocessor *ModuleExpanderPP) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCODEBEFOREINCLUDECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidHashOperatorCheck.h:
    1|       |//===--- AvoidHashOperatorCheck.h - clang-tidy ------*------------- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDHASHOPERATORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDHASHOPERATORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the # stringification operator in macros.
   17|       |///
   18|       |/// The # operator in preprocessor macros converts tokens to string literals.
   19|       |/// This can lead to unexpected behavior and make debugging difficult, as the
   20|       |/// stringification happens at preprocessing time and the actual values are
   21|       |/// obscured from the code reader.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 20.10 - The # operator should not be used.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   #define STRINGIFY(x) #x  // Warning: # operator used
   28|       |/// \endcode
   29|       |class AvoidHashOperatorCheck : public ClangTidyCheck {
   30|       |public:
   31|       |  /// Constructs the check with the given name and context.
   32|       |  /// \param Name The name of the check as registered.
   33|       |  /// \param Context The clang-tidy context for configuration.
   34|       |  AvoidHashOperatorCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|       |  /// Destructor.
   38|    131|  ~AvoidHashOperatorCheck() override = default;
   39|       |
   40|       |  /// Registers preprocessor callbacks for macro definition handling.
   41|       |  /// \param SM The source manager.
   42|       |  /// \param PP The preprocessor instance.
   43|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   44|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   45|       |                           Preprocessor *ModuleExpanderPP) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDHASHOPERATORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidUndefCheck.h:
    1|       |//===--- AvoidUndefCheck.h - clang-tidy -------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNDEFCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNDEFCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the #undef preprocessor directive.
   17|       |///
   18|       |/// The #undef directive removes macro definitions, which can lead to
   19|       |/// configuration-dependent behavior and makes code harder to understand.
   20|       |/// Undefining macros, especially those defined in headers, can cause
   21|       |/// inconsistent behavior across translation units.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 20.5 - #undef should not be used.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   #define MAX_SIZE 100
   28|       |///   #undef MAX_SIZE  // Warning: #undef used
   29|       |/// \endcode
   30|       |class AvoidUndefCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidUndefCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidUndefCheck() override = default;
   40|       |
   41|       |  /// Registers preprocessor callbacks for #undef directive handling.
   42|       |  /// \param SM The source manager.
   43|       |  /// \param PP The preprocessor instance.
   44|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   45|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   46|       |                           Preprocessor *ModuleExpanderPP) override;
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDUNDEFCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMultipleHashOperatorsCheck.cpp:
    1|       |//===--- AvoidMultipleHashOperatorsCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidMultipleHashOperatorsCheck.h"
   10|       |#include "clang/Basic/TokenKinds.h"
   11|       |#include "clang/Lex/PPCallbacks.h"
   12|       |#include "clang/Lex/Preprocessor.h"
   13|       |
   14|       |using namespace clang::tok;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |class AvoidMultipleHashOperatorsPPCallbacks : public PPCallbacks {
   21|       |public:
   22|       |  explicit AvoidMultipleHashOperatorsPPCallbacks(ClangTidyCheck &Check)
   23|    131|      : Check(Check) {}
   24|       |
   25|       |  void MacroDefined(const Token &MacroNameTok,
   26|       |                    const MacroDirective *MD) override;
   27|       |
   28|       |private:
   29|       |  ClangTidyCheck &Check;
   30|       |};
   31|       |
   32|       |void AvoidMultipleHashOperatorsPPCallbacks::MacroDefined(
   33|  64.1k|    const Token &MacroNameTok, const MacroDirective *MD) {
   34|       |
   35|  64.1k|  const MacroInfo *Info = MD->getMacroInfo();
   36|       |
   37|  64.1k|  if (Info) {
  ------------------
  |  Branch (37:7): [True: 64.1k, False: 0]
  ------------------
   38|  64.1k|    const Token *PrevTok = nullptr;
   39|       |
   40|  91.5k|    for (const Token &Tok : Info->tokens()) {
  ------------------
  |  Branch (40:27): [True: 91.5k, False: 64.1k]
  ------------------
   41|       |
   42|  91.5k|      if (Tok.isOneOf(tok::hash, tok::hashhash)) {
  ------------------
  |  Branch (42:11): [True: 1.02k, False: 90.4k]
  ------------------
   43|  1.02k|        if (PrevTok) {
  ------------------
  |  Branch (43:13): [True: 12, False: 1.01k]
  ------------------
   44|     12|          SourceLocation TokLoc = Tok.getLocation();
   45|     12|          SourceLocation PrevTokLoc = PrevTok->getLocation();
   46|     12|          auto TokSpelling = getPunctuatorSpelling(Tok.getKind());
   47|     12|          auto PrevTokSpelling = getPunctuatorSpelling(PrevTok->getKind());
   48|       |
   49|     12|          Check.diag(TokLoc, "avoid '%0' operator after '%1' operator")
   50|     12|              << TokSpelling << PrevTokSpelling;
   51|     12|          Check.diag(PrevTokLoc, "location of '%0' operator",
   52|     12|                     DiagnosticIDs::Note)
   53|     12|              << PrevTokSpelling;
   54|     12|        }
   55|  1.02k|        PrevTok = &Tok;
   56|  1.02k|      }
   57|  91.5k|    }
   58|  64.1k|  }
   59|  64.1k|}
   60|       |
   61|       |} // anonymous namespace
   62|       |
   63|       |void AvoidMultipleHashOperatorsCheck::registerPPCallbacks(
   64|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   65|    131|  PP->addPPCallbacks(
   66|    131|      std::make_unique<AvoidMultipleHashOperatorsPPCallbacks>(*this));
   67|    131|}
   68|       |
   69|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidMacroNamedAsCkeywordCheck.h:
    1|       |//===--- AvoidMacroNamedAsCkeywordCheck.h - clang-tidy ----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACRONAMEDASCKEYWORDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACRONAMEDASCKEYWORDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects macro names that match C language keywords.
   17|       |///
   18|       |/// Defining macros with names that are C keywords can cause confusion and
   19|       |/// portability issues. It can make code extremely difficult to read and
   20|       |/// understand, as readers would expect keyword behavior but get macro
   21|       |/// expansion instead. This violates the principle of least surprise.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 20.4 - A macro shall not be defined with the
   24|       |/// same name as a keyword.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   #define if 0  // Warning: macro named as C keyword
   29|       |/// \endcode
   30|       |class AvoidMacroNamedAsCkeywordCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidMacroNamedAsCkeywordCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidMacroNamedAsCkeywordCheck() override = default;
   40|       |
   41|       |  /// Registers preprocessor callbacks for macro definition handling.
   42|       |  /// \param SM The source manager.
   43|       |  /// \param PP The preprocessor instance.
   44|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   45|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   46|       |                           Preprocessor *ModuleExpanderPP) override;
   47|       |};
   48|       |
   49|       |} // namespace clang::tidy::automotive
   50|       |
   51|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDMACRONAMEDASCKEYWORDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidIncludeSyntaxErrorCheck.h:
    1|       |//===--- AvoidIncludeSyntaxErrorCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCLUDESYNTAXERRORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCLUDESYNTAXERRORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-preprocessor
   17|       |/// @brief Detects non-standard #include syntax.
   18|       |///
   19|       |/// Implements MISRA Rule 20.3: The #include directive shall be followed by
   20|       |/// either a <filename> or "filename" sequence.
   21|       |///
   22|       |/// @par MISRA C:2025 Rule 20.3
   23|       |/// Non-standard include syntax is undefined behavior.
   24|       |/// @par Category: Required
   25|       |///
   26|       |/// Example:
   27|       |/// @code
   28|       |///   #include <header.h>   // OK
   29|       |///   #include "header.h"   // OK
   30|       |///   #include MACRO        // Warning if MACRO doesn't expand properly
   31|       |/// @endcode
   32|       |class AvoidIncludeSyntaxErrorCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  AvoidIncludeSyntaxErrorCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|       |  /// Destructor.
   38|    131|  ~AvoidIncludeSyntaxErrorCheck() override = default;
   39|       |
   40|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   41|       |                           Preprocessor *ModuleExpanderPP) override;
   42|       |};
   43|       |
   44|       |} // namespace clang::tidy::automotive
   45|       |
   46|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCLUDESYNTAXERRORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidIncludeSyntaxErrorCheck.cpp:
    1|       |//===--- AvoidIncludeSyntaxErrorCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidIncludeSyntaxErrorCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |
   19|       |class IncludeSyntaxPPCallbacks : public PPCallbacks {
   20|       |public:
   21|       |  IncludeSyntaxPPCallbacks(ClangTidyCheck &Check, const SourceManager &SM)
   22|    131|      : Check(Check), SM(SM) {}
   23|       |
   24|       |  void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,
   25|       |                          StringRef FileName, bool IsAngled,
   26|       |                          CharSourceRange FilenameRange,
   27|       |                          OptionalFileEntryRef File, StringRef SearchPath,
   28|       |                          StringRef RelativePath, const Module *SuggestedModule,
   29|       |                          bool ModuleImported,
   30|  1.62k|                          SrcMgr::CharacteristicKind FileType) override {
   31|       |    // Skip system headers
   32|  1.62k|    if (SM.isInSystemHeader(HashLoc))
  ------------------
  |  Branch (32:9): [True: 1.56k, False: 58]
  ------------------
   33|  1.56k|      return;
   34|       |
   35|       |    // Check if the include uses computed include syntax (macro expansion)
   36|       |    // This is flagged because the result is implementation-defined
   37|       |    // LCOV_EXCL_START - include_next is rare and causes test portability issues
   38|     58|    if (IncludeTok.getIdentifierInfo() &&
  ------------------
  |  Branch (38:9): [True: 58, False: 0]
  ------------------
   39|     58|        IncludeTok.getIdentifierInfo()->getName() == "include_next") {
  ------------------
  |  Branch (39:9): [True: 0, False: 58]
  ------------------
   40|      0|      Check.diag(HashLoc,
   41|      0|                 "#include_next is a compiler extension and should not be used "
   42|      0|                 "in portable code");
   43|      0|      return;
   44|      0|    }
   45|       |    // LCOV_EXCL_STOP
   46|       |
   47|       |    // LCOV_EXCL_START - empty filename would cause preprocessor error before check
   48|       |    // Check for empty filename
   49|     58|    if (FileName.empty()) {
  ------------------
  |  Branch (49:9): [True: 0, False: 58]
  ------------------
   50|      0|      Check.diag(HashLoc, "#include directive has empty filename");
   51|      0|      return;
   52|      0|    }
   53|       |    // LCOV_EXCL_STOP
   54|       |
   55|       |    // Check for absolute paths (non-portable)
   56|     58|    if (FileName.starts_with("/") ||
  ------------------
  |  Branch (56:9): [True: 0, False: 58]
  ------------------
   57|     58|        (FileName.size() > 2 && FileName[1] == ':')) {
  ------------------
  |  Branch (57:10): [True: 58, False: 0]
  |  Branch (57:33): [True: 0, False: 58]
  ------------------
   58|      0|      Check.diag(FilenameRange.getBegin(),
   59|      0|                 "#include uses absolute path which is not portable");
   60|      0|    }
   61|     58|  }
   62|       |
   63|       |private:
   64|       |  ClangTidyCheck &Check;
   65|       |  const SourceManager &SM;
   66|       |};
   67|       |
   68|       |} // namespace
   69|       |
   70|       |void AvoidIncludeSyntaxErrorCheck::registerPPCallbacks(
   71|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   72|    131|  PP->addPPCallbacks(std::make_unique<IncludeSyntaxPPCallbacks>(*this, SM));
   73|    131|}
   74|       |
   75|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidReservedMacroIdentifierCheck.cpp:
    1|       |//===--- AvoidReservedMacroIdentifierCheck.cpp - clang-tidy ---------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidReservedMacroIdentifierCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |#include "llvm/ADT/StringSet.h"
   13|       |#include <cctype>
   14|       |
   15|       |using namespace clang::ast_matchers;
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |namespace {
   20|       |
   21|       |// Standard library reserved names that should not be defined/undefined
   22|       |const llvm::StringSet<> ReservedNames = {
   23|       |    "assert",       "errno",     "math_errhandling",
   24|       |    "setjmp",       "va_arg",    "va_copy",
   25|       |    "va_end",       "va_start",  "offsetof",
   26|       |    "NULL",         "true",      "false",
   27|       |    "bool",         "FILE",      "fpos_t",
   28|       |    "size_t",       "ptrdiff_t", "wchar_t",
   29|       |    "int8_t",       "int16_t",   "int32_t",
   30|       |    "int64_t",      "uint8_t",   "uint16_t",
   31|       |    "uint32_t",     "uint64_t",  "intptr_t",
   32|       |    "uintptr_t",    "CHAR_BIT",  "CHAR_MAX",
   33|       |    "CHAR_MIN",     "INT_MAX",   "INT_MIN",
   34|       |    "LONG_MAX",     "LONG_MIN",  "SCHAR_MAX",
   35|       |    "SCHAR_MIN",    "SHRT_MAX",  "SHRT_MIN",
   36|       |    "UCHAR_MAX",    "UINT_MAX",  "ULONG_MAX",
   37|       |    "USHRT_MAX",    "EOF",       "SEEK_CUR",
   38|       |    "SEEK_END",     "SEEK_SET",  "BUFSIZ",
   39|       |    "FILENAME_MAX", "FOPEN_MAX", "stdin",
   40|       |    "stdout",       "stderr",    "EXIT_FAILURE",
   41|       |    "EXIT_SUCCESS", "RAND_MAX",  "MB_CUR_MAX"};
   42|       |
   43|  1.86k|bool isReservedIdentifier(StringRef Name) {
   44|  1.86k|  if (Name.empty())
  ------------------
  |  Branch (44:7): [True: 0, False: 1.86k]
  ------------------
   45|      0|    return false;
   46|       |
   47|       |  // Check for underscore followed by uppercase or another underscore
   48|  1.86k|  if (Name.size() >= 2 && Name[0] == '_') {
  ------------------
  |  Branch (48:7): [True: 1.86k, False: 0]
  |  Branch (48:27): [True: 1.33k, False: 537]
  ------------------
   49|  1.33k|    if (std::isupper(static_cast<unsigned char>(Name[1])) || Name[1] == '_')
  ------------------
  |  Branch (49:9): [True: 34, False: 1.29k]
  |  Branch (49:62): [True: 1.29k, False: 1]
  ------------------
   50|  1.33k|      return true;
   51|  1.33k|  }
   52|       |
   53|       |  // Check for known standard library names
   54|    538|  return ReservedNames.contains(Name);
   55|  1.86k|}
   56|       |
   57|       |class ReservedMacroPPCallbacks : public PPCallbacks {
   58|       |public:
   59|       |  ReservedMacroPPCallbacks(ClangTidyCheck &Check, const SourceManager &SM)
   60|    131|      : Check(Check), SM(SM) {}
   61|       |
   62|       |  void MacroDefined(const Token &MacroNameTok,
   63|  64.1k|                    const MacroDirective *MD) override {
   64|       |    // Skip macros defined in system headers
   65|  64.1k|    if (SM.isInSystemHeader(MacroNameTok.getLocation()))
  ------------------
  |  Branch (65:9): [True: 63.8k, False: 285]
  ------------------
   66|  63.8k|      return;
   67|       |
   68|    285|    StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   69|    285|    if (isReservedIdentifier(MacroName)) {
  ------------------
  |  Branch (69:9): [True: 139, False: 146]
  ------------------
   70|    139|      Check.diag(MacroNameTok.getLocation(),
   71|    139|                 "#define of reserved identifier '%0'")
   72|    139|          << MacroName;
   73|    139|    }
   74|    285|  }
   75|       |
   76|       |  void MacroUndefined(const Token &MacroNameTok, const MacroDefinition &MD,
   77|  1.91k|                      const MacroDirective *Undef) override {
   78|       |    // Skip undefs in system headers
   79|  1.91k|    if (Undef && SM.isInSystemHeader(Undef->getLocation()))
  ------------------
  |  Branch (79:9): [True: 348, False: 1.56k]
  |  Branch (79:18): [True: 326, False: 22]
  ------------------
   80|    326|      return;
   81|       |
   82|  1.58k|    StringRef MacroName = MacroNameTok.getIdentifierInfo()->getName();
   83|  1.58k|    if (isReservedIdentifier(MacroName)) {
  ------------------
  |  Branch (83:9): [True: 1.23k, False: 345]
  ------------------
   84|  1.23k|      Check.diag(MacroNameTok.getLocation(),
   85|  1.23k|                 "#undef of reserved identifier '%0'")
   86|  1.23k|          << MacroName;
   87|  1.23k|    }
   88|  1.58k|  }
   89|       |
   90|       |private:
   91|       |  ClangTidyCheck &Check;
   92|       |  const SourceManager &SM;
   93|       |};
   94|       |
   95|       |} // anonymous namespace
   96|       |
   97|       |void AvoidReservedMacroIdentifierCheck::registerPPCallbacks(
   98|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   99|    131|  PP->addPPCallbacks(std::make_unique<ReservedMacroPPCallbacks>(*this, SM));
  100|    131|}
  101|       |
  102|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/MissingHeaderGuardCheck.cpp:
    1|       |//===--- MissingHeaderGuardCheck.cpp - clang-tidy -------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingHeaderGuardCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |#include "llvm/Support/Path.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |
   20|       |/// Canonicalize a path by removing ./ and ../ components.
   21|    680|std::string cleanPath(StringRef Path) {
   22|    680|  SmallString<256> Result = Path;
   23|    680|  llvm::sys::path::remove_dots(Result, true);
   24|    680|  return std::string(Result);
   25|    680|}
   26|       |
   27|       |// LCOV_EXCL_START - only used in diagnostic path for missing header guards
   28|       |/// Generate a standard header guard macro name from a file path.
   29|      0|std::string generateHeaderGuardName(StringRef FileName) {
   30|      0|  SmallString<256> Guard;
   31|       |
   32|       |  // Get just the filename without directory
   33|      0|  StringRef BaseName = llvm::sys::path::filename(FileName);
   34|       |
   35|       |  // Convert to uppercase and replace non-alphanumeric chars with underscores
   36|      0|  for (char C : BaseName) {
  ------------------
  |  Branch (36:15): [True: 0, False: 0]
  ------------------
   37|      0|    if (std::isalnum(static_cast<unsigned char>(C))) {
  ------------------
  |  Branch (37:9): [True: 0, False: 0]
  ------------------
   38|      0|      Guard.push_back(std::toupper(static_cast<unsigned char>(C)));
   39|      0|    } else {
   40|      0|      Guard.push_back('_');
   41|      0|    }
   42|      0|  }
   43|       |
   44|      0|  Guard.push_back('_');
   45|      0|  return std::string(Guard);
   46|      0|}
   47|       |// LCOV_EXCL_STOP
   48|       |
   49|       |class HeaderGuardPPCallbacks : public PPCallbacks {
   50|       |public:
   51|       |  HeaderGuardPPCallbacks(Preprocessor *PP, MissingHeaderGuardCheck *Check)
   52|    131|      : PP(PP), Check(Check) {}
   53|       |
   54|       |  void FileChanged(SourceLocation Loc, FileChangeReason Reason,
   55|       |                   SrcMgr::CharacteristicKind FileType,
   56|  3.21k|                   FileID PrevFID) override {
   57|       |    // Only track files we enter that are user files
   58|  3.21k|    if (Reason != EnterFile || FileType != SrcMgr::C_User)
  ------------------
  |  Branch (58:9): [True: 1.65k, False: 1.55k]
  |  Branch (58:32): [True: 1.15k, False: 397]
  ------------------
   59|  2.81k|      return;
   60|       |
   61|    397|    SourceManager &SM = PP->getSourceManager();
   62|    397|    OptionalFileEntryRef FE = SM.getFileEntryRefForID(SM.getFileID(Loc));
   63|       |    // LCOV_EXCL_START - defensive check for invalid file entry
   64|    397|    if (!FE)
  ------------------
  |  Branch (64:9): [True: 262, False: 135]
  ------------------
   65|    262|      return;
   66|       |    // LCOV_EXCL_STOP
   67|       |
   68|    135|    std::string FileName = cleanPath(FE->getName());
   69|       |
   70|       |    // Only track .h and .hpp files (header files)
   71|    135|    StringRef Extension = llvm::sys::path::extension(FileName);
   72|    135|    if (Extension == ".h" || Extension == ".hpp")
  ------------------
  |  Branch (72:9): [True: 4, False: 131]
  |  Branch (72:30): [True: 0, False: 131]
  ------------------
   73|      4|      Files[FileName] = *FE;
   74|    135|  }
   75|       |
   76|       |  void PragmaDirective(SourceLocation Loc,
   77|    494|                       PragmaIntroducerKind Introducer) override {
   78|       |    // This callback is called for all pragmas, but we need to check
   79|       |    // specifically for #pragma once in PragmaOnce callback
   80|    494|  }
   81|       |
   82|       |  void MacroDefined(const Token &MacroNameTok,
   83|  64.1k|                    const MacroDirective *MD) override {
   84|       |    // Record all defined macros to check for header guard pattern
   85|  64.1k|    const MacroInfo *MI = MD->getMacroInfo();
   86|       |    // LCOV_EXCL_START - defensive check, MacroDirective always has MacroInfo
   87|  64.1k|    if (!MI)
  ------------------
  |  Branch (87:9): [True: 0, False: 64.1k]
  ------------------
   88|      0|      return;
   89|       |    // LCOV_EXCL_STOP
   90|       |
   91|  64.1k|    Macros.emplace_back(MacroNameTok, MI);
   92|  64.1k|  }
   93|       |
   94|    131|  void EndOfMainFile() override {
   95|    131|    SourceManager &SM = PP->getSourceManager();
   96|       |
   97|       |    // Check which macros are used as header guards
   98|       |    // Clang's preprocessor marks macros that are used as header guards
   99|  64.1k|    for (const auto &MacroEntry : Macros) {
  ------------------
  |  Branch (99:33): [True: 64.1k, False: 131]
  ------------------
  100|  64.1k|      const MacroInfo *MI = MacroEntry.second;
  101|  64.1k|      if (!MI->isUsedForHeaderGuard())
  ------------------
  |  Branch (101:11): [True: 63.5k, False: 545]
  ------------------
  102|  63.5k|        continue;
  103|       |
  104|       |      // This file has a proper header guard, remove it from tracking
  105|    545|      OptionalFileEntryRef FE =
  106|    545|          SM.getFileEntryRefForID(SM.getFileID(MI->getDefinitionLoc()));
  107|       |      // LCOV_EXCL_START - defensive check for invalid file entry
  108|    545|      if (!FE)
  ------------------
  |  Branch (108:11): [True: 0, False: 545]
  ------------------
  109|      0|        continue;
  110|       |      // LCOV_EXCL_STOP
  111|       |
  112|    545|      std::string FileName = cleanPath(FE->getName());
  113|    545|      Files.erase(FileName);
  114|    545|    }
  115|       |
  116|       |    // Check for files with #pragma once
  117|       |    // Note: Clang doesn't provide a direct PPCallbacks for #pragma once
  118|       |    // detection in the standard API, so we rely on the header guard mechanism
  119|       |    // above. Files with #pragma once are also marked with
  120|       |    // isUsedForHeaderGuard()
  121|       |
  122|       |    // Emit warnings for header files without guards
  123|    131|    checkGuardlessHeaders();
  124|    131|    clearAllState();
  125|    131|  }
  126|       |
  127|       |  // LCOV_EXCL_START - diagnostic path requires test headers without guards
  128|    131|  void checkGuardlessHeaders() {
  129|    131|    for (const auto &FE : Files) {
  ------------------
  |  Branch (129:25): [True: 0, False: 131]
  ------------------
  130|      0|      StringRef FileName = FE.getKey();
  131|      0|      SourceManager &SM = PP->getSourceManager();
  132|      0|      FileID FID = SM.translateFile(FE.getValue());
  133|      0|      SourceLocation StartLoc = SM.getLocForStartOfFile(FID);
  134|       |
  135|      0|      if (StartLoc.isInvalid())
  ------------------
  |  Branch (135:11): [True: 0, False: 0]
  ------------------
  136|      0|        continue;
  137|       |
  138|       |      // Check if this file was included from the main file or another header
  139|       |      // We only want to report on files that are actually being analyzed
  140|      0|      if (!SM.isInFileID(StartLoc, FID))
  ------------------
  |  Branch (140:11): [True: 0, False: 0]
  ------------------
  141|      0|        continue;
  142|       |
  143|       |      // Generate suggested header guard name
  144|      0|      std::string GuardName = generateHeaderGuardName(FileName);
  145|       |
  146|       |      // Emit diagnostic with fix-it hints
  147|      0|      Check->diag(StartLoc,
  148|      0|                  "header file is missing include guard protection; "
  149|      0|                  "consider adding '#ifndef %0' / '#define %0' at the start "
  150|      0|                  "and '#endif' at the end, or use '#pragma once'")
  151|      0|          << GuardName
  152|      0|          << FixItHint::CreateInsertion(StartLoc, "#ifndef " + GuardName +
  153|      0|                                                      "\n#define " + GuardName +
  154|      0|                                                      "\n\n")
  155|      0|          << FixItHint::CreateInsertion(SM.getLocForEndOfFile(FID),
  156|      0|                                        "\n\n#endif // " + GuardName + "\n");
  157|      0|    }
  158|    131|  }
  159|       |  // LCOV_EXCL_STOP
  160|       |
  161|       |private:
  162|    131|  void clearAllState() {
  163|    131|    Macros.clear();
  164|    131|    Files.clear();
  165|    131|  }
  166|       |
  167|       |  std::vector<std::pair<Token, const MacroInfo *>> Macros;
  168|       |  llvm::StringMap<const FileEntry *> Files;
  169|       |  Preprocessor *PP;
  170|       |  MissingHeaderGuardCheck *Check;
  171|       |};
  172|       |
  173|       |} // anonymous namespace
  174|       |
  175|       |void MissingHeaderGuardCheck::registerPPCallbacks(
  176|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
  177|    131|  PP->addPPCallbacks(std::make_unique<HeaderGuardPPCallbacks>(PP, this));
  178|    131|}
  179|       |
  180|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidLanguageExtensionCheck.cpp:
    1|       |//===--- AvoidLanguageExtensionCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidLanguageExtensionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidLanguageExtensionCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match GNU statement expressions
   19|    131|  Finder->addMatcher(stmtExpr().bind("stmtexpr"), this);
   20|       |
   21|       |  // Match declarations with aligned attribute
   22|    131|  Finder->addMatcher(decl(hasAttr(attr::Kind::Aligned)).bind("alignedattr"),
   23|    131|                     this);
   24|       |
   25|       |  // Match declarations with packed attribute
   26|    131|  Finder->addMatcher(decl(hasAttr(attr::Kind::Packed)).bind("packedattr"),
   27|    131|                     this);
   28|       |
   29|       |  // Match __builtin calls
   30|    131|  Finder->addMatcher(callExpr(callee(functionDecl(matchesName("^__builtin_"))))
   31|    131|                         .bind("builtin"),
   32|    131|                     this);
   33|    131|}
   34|       |
   35|       |void AvoidLanguageExtensionCheck::check(
   36|     24|    const MatchFinder::MatchResult &Result) {
   37|       |  // Check statement expressions
   38|     24|  if (const auto *SE = Result.Nodes.getNodeAs<StmtExpr>("stmtexpr")) {
  ------------------
  |  Branch (38:19): [True: 1, False: 23]
  ------------------
   39|      1|    if (Result.SourceManager->isInSystemHeader(SE->getBeginLoc()))
  ------------------
  |  Branch (39:9): [True: 0, False: 1]
  ------------------
   40|      0|      return;
   41|       |
   42|      1|    diag(SE->getBeginLoc(),
   43|      1|         "statement expression is a GCC/Clang extension; avoid for "
   44|      1|         "portability");
   45|      1|    return;
   46|      1|  }
   47|       |
   48|       |  // Check aligned attribute
   49|     23|  if (const auto *D = Result.Nodes.getNodeAs<Decl>("alignedattr")) {
  ------------------
  |  Branch (49:19): [True: 22, False: 1]
  ------------------
   50|     22|    if (Result.SourceManager->isInSystemHeader(D->getLocation()))
  ------------------
  |  Branch (50:9): [True: 20, False: 2]
  ------------------
   51|     20|      return;
   52|       |
   53|      2|    diag(D->getLocation(),
   54|      2|         "__attribute__((aligned)) is a compiler extension; use _Alignas in "
   55|      2|         "C11 or alignas in C++11 for portability");
   56|      2|    return;
   57|     22|  }
   58|       |
   59|       |  // Check packed attribute
   60|      1|  if (const auto *D = Result.Nodes.getNodeAs<Decl>("packedattr")) {
  ------------------
  |  Branch (60:19): [True: 1, False: 0]
  ------------------
   61|      1|    if (Result.SourceManager->isInSystemHeader(D->getLocation()))
  ------------------
  |  Branch (61:9): [True: 0, False: 1]
  ------------------
   62|      0|      return;
   63|       |
   64|      1|    diag(D->getLocation(),
   65|      1|         "__attribute__((packed)) is a compiler extension and not portable");
   66|      1|    return;
   67|      1|  }
   68|       |
   69|       |  // Check __builtin_ calls
   70|      0|  if (const auto *CE = Result.Nodes.getNodeAs<CallExpr>("builtin")) {
  ------------------
  |  Branch (70:19): [True: 0, False: 0]
  ------------------
   71|      0|    if (Result.SourceManager->isInSystemHeader(CE->getBeginLoc()))
  ------------------
  |  Branch (71:9): [True: 0, False: 0]
  ------------------
   72|      0|      return;
   73|       |
   74|      0|    diag(CE->getBeginLoc(),
   75|      0|         "__builtin_* functions are compiler extensions and not portable");
   76|      0|  }
   77|      0|}
   78|       |
   79|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidInvalidHeaderCharCheck.cpp:
    1|       |//===--- AvoidInvalidHeaderCharCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidInvalidHeaderCharCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |
   19|       |class InvalidHeaderCharPPCallbacks : public PPCallbacks {
   20|       |public:
   21|    131|  explicit InvalidHeaderCharPPCallbacks(ClangTidyCheck &Check) : Check(Check) {}
   22|       |
   23|       |  void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,
   24|       |                          StringRef FileName, bool IsAngled,
   25|       |                          CharSourceRange FilenameRange,
   26|       |                          OptionalFileEntryRef File, StringRef SearchPath,
   27|       |                          StringRef RelativePath, const Module *SuggestedModule,
   28|       |                          bool ModuleImported,
   29|  1.62k|                          SrcMgr::CharacteristicKind FileType) override {
   30|  1.62k|    std::string InvalidChars = buildInvalidCharsList(FileName);
   31|  1.62k|    if (InvalidChars.empty())
  ------------------
  |  Branch (31:9): [True: 1.62k, False: 0]
  ------------------
   32|  1.62k|      return;
   33|       |
   34|      0|    Check.diag(FilenameRange.getBegin(),
   35|      0|               "header file name contains invalid character(s): %0")
   36|      0|        << InvalidChars;
   37|      0|  }
   38|       |
   39|       |private:
   40|       |  /// Build a comma-separated list of invalid characters found in the filename.
   41|       |  // LCOV_EXCL_START - invalid chars in header names cause preprocessor errors
   42|  1.62k|  static std::string buildInvalidCharsList(StringRef FileName) {
   43|  1.62k|    llvm::SmallVector<const char *, 3> Found;
   44|  1.62k|    if (FileName.contains('\''))
  ------------------
  |  Branch (44:9): [True: 0, False: 1.62k]
  ------------------
   45|      0|      Found.push_back("'");
   46|  1.62k|    if (FileName.contains('"'))
  ------------------
  |  Branch (46:9): [True: 0, False: 1.62k]
  ------------------
   47|      0|      Found.push_back("\"");
   48|  1.62k|    if (FileName.contains('\\'))
  ------------------
  |  Branch (48:9): [True: 0, False: 1.62k]
  ------------------
   49|      0|      Found.push_back("\\");
   50|       |
   51|  1.62k|    std::string Result;
   52|  1.62k|    for (size_t I = 0; I < Found.size(); ++I) {
  ------------------
  |  Branch (52:24): [True: 0, False: 1.62k]
  ------------------
   53|      0|      if (I > 0)
  ------------------
  |  Branch (53:11): [True: 0, False: 0]
  ------------------
   54|      0|        Result += ", ";
   55|      0|      Result += Found[I];
   56|      0|    }
   57|  1.62k|    return Result;
   58|  1.62k|  }
   59|       |  // LCOV_EXCL_STOP
   60|       |
   61|       |  ClangTidyCheck &Check;
   62|       |};
   63|       |
   64|       |} // anonymous namespace
   65|       |
   66|       |void AvoidInvalidHeaderCharCheck::registerPPCallbacks(
   67|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   68|    131|  PP->addPPCallbacks(std::make_unique<InvalidHeaderCharPPCallbacks>(*this));
   69|    131|}
   70|       |
   71|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/preprocessor/AvoidCodeBeforeIncludeCheck.cpp:
    1|       |//===--- AvoidCodeBeforeIncludeCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCodeBeforeIncludeCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |
   19|       |class IncludeOrderPPCallbacks : public PPCallbacks {
   20|       |public:
   21|       |  IncludeOrderPPCallbacks(ClangTidyCheck &Check, const SourceManager &SM)
   22|    131|      : Check(Check), SM(SM) {}
   23|       |
   24|       |  void InclusionDirective(SourceLocation HashLoc, const Token &IncludeTok,
   25|       |                          StringRef FileName, bool IsAngled,
   26|       |                          CharSourceRange FilenameRange,
   27|       |                          OptionalFileEntryRef File, StringRef SearchPath,
   28|       |                          StringRef RelativePath, const Module *SuggestedModule,
   29|       |                          bool ModuleImported,
   30|  1.62k|                          SrcMgr::CharacteristicKind FileType) override {
   31|       |    // Only check in the main file
   32|  1.62k|    if (!SM.isInMainFile(HashLoc))
  ------------------
  |  Branch (32:9): [True: 1.56k, False: 58]
  ------------------
   33|  1.56k|      return;
   34|       |
   35|     58|    if (SeenCode) {
  ------------------
  |  Branch (35:9): [True: 0, False: 58]
  ------------------
   36|      0|      Check.diag(HashLoc, "#include directive should only be preceded by "
   37|      0|                          "preprocessor directives or comments");
   38|      0|    }
   39|     58|  }
   40|       |
   41|       |  void MacroDefined(const Token &MacroNameTok,
   42|  64.1k|                    const MacroDirective *MD) override {
   43|       |    // Macro definitions are preprocessor directives, so they're OK
   44|       |    // But we track if we're past the include section
   45|  64.1k|  }
   46|       |
   47|       |  void FileChanged(SourceLocation Loc, FileChangeReason Reason,
   48|       |                   SrcMgr::CharacteristicKind FileType,
   49|  3.21k|                   FileID PrevFID) override {
   50|       |    // Reset state when entering a new file
   51|  3.21k|    if (Reason == EnterFile && SM.isInMainFile(Loc)) {
  ------------------
  |  Branch (51:9): [True: 1.55k, False: 1.65k]
  |  Branch (51:32): [True: 262, False: 1.29k]
  ------------------
   52|    262|      SeenCode = false;
   53|    262|    }
   54|  3.21k|  }
   55|       |
   56|      0|  void setSeenCode() { SeenCode = true; }
   57|       |
   58|       |private:
   59|       |  ClangTidyCheck &Check;
   60|       |  const SourceManager &SM;
   61|       |  bool SeenCode = false;
   62|       |};
   63|       |
   64|       |} // anonymous namespace
   65|       |
   66|       |void AvoidCodeBeforeIncludeCheck::registerPPCallbacks(
   67|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   68|    131|  PP->addPPCallbacks(std::make_unique<IncludeOrderPPCallbacks>(*this, SM));
   69|    131|}
   70|       |
   71|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedTagCheck.cpp:
    1|       |//===--- UnusedTagCheck.cpp - clang-tidy ----------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedTagCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UnusedTagCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(tagDecl(unless(isExpansionInSystemHeader())).bind("tag"),
   18|    131|                     this);
   19|    131|}
   20|       |
   21|    288|void UnusedTagCheck::check(const MatchFinder::MatchResult &Result) {
   22|    288|  const auto *MatchedDecl = Result.Nodes.getNodeAs<TagDecl>("tag");
   23|       |
   24|    288|  if (!MatchedDecl) {
  ------------------
  |  Branch (24:7): [True: 0, False: 288]
  ------------------
   25|      0|    return;
   26|      0|  }
   27|       |
   28|    288|  if (MatchedDecl->isReferenced() || MatchedDecl->isUsed()) {
  ------------------
  |  Branch (28:7): [True: 51, False: 237]
  |  Branch (28:38): [True: 0, False: 237]
  ------------------
   29|     51|    return;
   30|     51|  }
   31|       |
   32|    237|  if (MatchedDecl->getName().empty()) {
  ------------------
  |  Branch (32:7): [True: 28, False: 209]
  ------------------
   33|     28|    return;
   34|     28|  }
   35|       |
   36|    209|  diag(MatchedDecl->getLocation(), "unused tag '%0'") << MatchedDecl->getName();
   37|    209|}
   38|       |
   39|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedObjectDefinitionCheck.cpp:
    1|       |//===--- UnusedObjectDefinitionCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedObjectDefinitionCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UnusedObjectDefinitionCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(varDecl(isDefinition(), hasLocalStorage(),
   18|    131|                             unless(parmVarDecl()), unless(isImplicit()))
   19|    131|                         .bind("unusedVar"),
   20|    131|                     this);
   21|       |
   22|    131|  Finder->addMatcher(varDecl(hasGlobalStorage(), isStaticStorageClass())
   23|    131|                         .bind("unusedStaticVar"),
   24|    131|                     this);
   25|    131|}
   26|       |
   27|       |void UnusedObjectDefinitionCheck::check(
   28|  2.08k|    const MatchFinder::MatchResult &Result) {
   29|  2.08k|  const auto *Var = Result.Nodes.getNodeAs<VarDecl>("unusedVar");
   30|  2.08k|  const auto *StaticVar = Result.Nodes.getNodeAs<VarDecl>("unusedStaticVar");
   31|       |
   32|  2.08k|  if (Var && !Var->isUsed()) {
  ------------------
  |  Branch (32:7): [True: 1.90k, False: 180]
  |  Branch (32:14): [True: 1.03k, False: 863]
  ------------------
   33|  1.03k|    diag(Var->getLocation(), "unused object definition '%0'") << Var->getName();
   34|  1.03k|  }
   35|       |
   36|  2.08k|  if (StaticVar && !StaticVar->isUsed()) {
  ------------------
  |  Branch (36:7): [True: 180, False: 1.90k]
  |  Branch (36:20): [True: 159, False: 21]
  ------------------
   37|    159|    diag(StaticVar->getLocation(), "unused static object definition '%0'")
   38|    159|        << StaticVar->getName();
   39|    159|  }
   40|  2.08k|}
   41|       |
   42|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedObjectDefinitionCheck.h:
    1|       |//===--- UnusedObjectDefinitionCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDOBJECTDEFINITIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDOBJECTDEFINITIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-unused-code
   17|       |/// @brief Detects unused object (variable) definitions.
   18|       |///
   19|       |/// This check identifies variables that are defined but never used in the code.
   20|       |/// Unused objects may indicate incomplete implementations, dead code, or
   21|       |/// refactoring remnants that should be cleaned up.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 2.8
   24|       |/// A variable should be used after being declared.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   void func(void) {
   30|       |///     int unused_var = 42;  // Warning: unused variable
   31|       |///   }
   32|       |/// @endcode
   33|       |class UnusedObjectDefinitionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  UnusedObjectDefinitionCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~UnusedObjectDefinitionCheck() override = default;
   40|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   41|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   42|       |};
   43|       |
   44|       |} // namespace clang::tidy::automotive
   45|       |
   46|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDOBJECTDEFINITIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedTagCheck.h:
    1|       |//===--- UnusedTagCheck.h - clang-tidy --------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTAGCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTAGCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-unused-code
   17|       |/// @brief Detects unused tag declarations (struct, union, enum tags).
   18|       |///
   19|       |/// This check identifies tag declarations that are defined but never used
   20|       |/// in the code. Unused tags indicate dead code that should be removed to
   21|       |/// improve code clarity and maintainability.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 2.4
   24|       |/// A tag should be used when it is declared.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   struct UnusedStruct { int x; };  // Warning: unused tag
   30|       |///   enum UnusedEnum { A, B, C };     // Warning: unused tag
   31|       |/// @endcode
   32|       |class UnusedTagCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  UnusedTagCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|       |  /// Destructor.
   38|    131|  ~UnusedTagCheck() override = default;
   39|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   40|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   41|       |};
   42|       |
   43|       |} // namespace clang::tidy::automotive
   44|       |
   45|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDTAGCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedParameterCheck.cpp:
    1|       |//===--- UnusedParameterCheck.cpp - clang-tidy ----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedParameterCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void UnusedParameterCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match function definitions with parameters
   19|    131|  Finder->addMatcher(functionDecl(isDefinition(), hasBody(compoundStmt()),
   20|    131|                                  unless(isImplicit()), unless(isDefaulted()),
   21|    131|                                  unless(isDeleted()))
   22|    131|                         .bind("func"),
   23|    131|                     this);
   24|    131|}
   25|       |
   26|  3.95k|void UnusedParameterCheck::check(const MatchFinder::MatchResult &Result) {
   27|  3.95k|  const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("func");
   28|  3.95k|  if (!Func)
  ------------------
  |  Branch (28:7): [True: 0, False: 3.95k]
  ------------------
   29|      0|    return;
   30|       |
   31|       |  // Skip functions in system headers
   32|  3.95k|  if (Result.SourceManager->isInSystemHeader(Func->getLocation()))
  ------------------
  |  Branch (32:7): [True: 3.36k, False: 585]
  ------------------
   33|  3.36k|    return;
   34|       |
   35|       |  // Check each parameter
   36|    585|  for (const ParmVarDecl *Param : Func->parameters()) {
  ------------------
  |  Branch (36:33): [True: 260, False: 585]
  ------------------
   37|       |    // Skip unnamed parameters - they're explicitly unused
   38|    260|    if (!Param->getIdentifier())
  ------------------
  |  Branch (38:9): [True: 1, False: 259]
  ------------------
   39|      1|      continue;
   40|       |
   41|       |    // Skip parameters that are used
   42|    259|    if (Param->isUsed())
  ------------------
  |  Branch (42:9): [True: 238, False: 21]
  ------------------
   43|    238|      continue;
   44|       |
   45|       |    // Skip if the parameter is referenced (covers more cases than isUsed)
   46|     21|    if (Param->isReferenced())
  ------------------
  |  Branch (46:9): [True: 4, False: 17]
  ------------------
   47|      4|      continue;
   48|       |
   49|       |    // Report unused parameter
   50|     17|    diag(Param->getLocation(), "unused parameter '%0'") << Param->getName();
   51|     17|  }
   52|    585|}
   53|       |
   54|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedParameterCheck.h:
    1|       |//===--- UnusedParameterCheck.h - clang-tidy --------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDPARAMETERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDPARAMETERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-unused-code
   17|       |/// @brief Detects unused function parameters.
   18|       |///
   19|       |/// Function parameters that are not used in the function body may indicate
   20|       |/// incomplete implementations, interface mismatches, or dead code. Unused
   21|       |/// parameters should be removed or marked to suppress the warning if they
   22|       |/// are intentionally unused (e.g., for API compatibility).
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 2.7
   25|       |/// There should be no unused parameters in functions.
   26|       |/// @par Category: Advisory
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   void func(int used, int unused) {  // Warning: 'unused' is not used
   31|       |///       return used + 1;
   32|       |///   }
   33|       |///
   34|       |///   // Compliant: cast to void to indicate intentionally unused
   35|       |///   void callback(int event, void *data) {
   36|       |///       (void)data;  // Intentionally unused
   37|       |///       handle_event(event);
   38|       |///   }
   39|       |/// @endcode
   40|       |class UnusedParameterCheck : public ClangTidyCheck {
   41|       |public:
   42|       |  UnusedParameterCheck(StringRef Name, ClangTidyContext *Context)
   43|    131|      : ClangTidyCheck(Name, Context) {}
   44|       |
   45|       |  /// Destructor.
   46|    131|  ~UnusedParameterCheck() override = default;
   47|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNUSEDPARAMETERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/unused-code/UnusedCodeModule.cpp:
    1|       |//===--- UnusedCodeModule.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnusedCodeModule.h"
   10|       |#include "UnusedObjectDefinitionCheck.h"
   11|       |#include "UnusedParameterCheck.h"
   12|       |#include "UnusedTagCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |void UnusedCodeModule::addCheckFactories(
   17|    262|    ClangTidyCheckFactories &CheckFactories) {
   18|       |
   19|       |  /* C 2023
   20|       |  ------------------------------------------------------------------ */
   21|    262|  CheckFactories.registerCheck<UnusedObjectDefinitionCheck>(
   22|    262|      "automotive-c23-adv-2.8");
   23|       |
   24|       |  // Rule 2.7 - Unused parameters (Advisory)
   25|    262|  CheckFactories.registerCheck<UnusedParameterCheck>("automotive-c23-adv-2.7");
   26|       |
   27|       |  /* C 2012
   28|       |  ------------------------------------------------------------------ */
   29|       |
   30|       |  /* Experimental
   31|       |  ------------------------------------------------------------------ */
   32|    262|  CheckFactories.registerCheck<UnusedTagCheck>("automotive-x-adv-2.4");
   33|    262|}
   34|       |
   35|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidAtomicVoidPointerCheck.h:
    1|       |//===--- AvoidAtomicVoidPointerCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDATOMICVOIDPOINTERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDATOMICVOIDPOINTERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects atomic operations on void pointers.
   17|       |///
   18|       |/// The C standard specifies that atomic operations on void pointers have
   19|       |/// undefined behavior. Using atomic void pointers circumvents type safety
   20|       |/// and can lead to subtle concurrency bugs that are difficult to diagnose
   21|       |/// and reproduce.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 18.7 - Atomic operations shall not be performed
   24|       |/// on void pointers.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   _Atomic(void*) ptr;  // Warning: atomic void pointer
   29|       |/// \endcode
   30|       |class AvoidAtomicVoidPointerCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidAtomicVoidPointerCheck(StringRef Name, ClangTidyContext *Context)
   36|      0|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|       |  ~AvoidAtomicVoidPointerCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for atomic void pointer declarations.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched atomic void pointers and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDATOMICVOIDPOINTERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidPointerIntegerCastCheck.h:
    1|       |//===--- AvoidPointerIntegerCastCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERINTEGERCASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERINTEGERCASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-pointer
   17|       |/// @brief Detects casts between pointer and integer types.
   18|       |///
   19|       |/// A conversion should not be performed between a pointer to object and an
   20|       |/// integer type. Such conversions are implementation-defined and may not
   21|       |/// preserve the pointer value correctly on all architectures.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 11.4
   24|       |/// A conversion should not be performed between a pointer to object and an
   25|       |/// integer type.
   26|       |/// @par Category: Advisory
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   int *p;
   31|       |///   int i = (int)p;           // Warning: pointer to integer
   32|       |///   int *q = (int *)i;        // Warning: integer to pointer
   33|       |///   uintptr_t u = (uintptr_t)p;  // May be allowed with option
   34|       |/// @endcode
   35|       |class AvoidPointerIntegerCastCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidPointerIntegerCastCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidPointerIntegerCastCheck() override = default;
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERINTEGERCASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/PointerComponent.cpp:
    1|       |//===--- PointerComponent.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "PointerComponent.h"
   10|       |#include "AvoidAtomicVoidPointerCheck.h"
   11|       |#include "AvoidAutoAddressEscapeCheck.h"
   12|       |#include "AvoidCastRemovingQualifierCheck.h"
   13|       |#include "AvoidIncompatiblePointerCastCheck.h"
   14|       |#include "AvoidIncompatiblePointerConversionCheck.h"
   15|       |#include "AvoidPointerIntegerCastCheck.h"
   16|       |#include "WrongNullPointerValueCheck.h"
   17|       |
   18|       |namespace clang::tidy::automotive {
   19|       |
   20|       |void PointerComponent::addCheckFactories(
   21|    262|    ClangTidyCheckFactories &CheckFactories) {
   22|       |
   23|       |  // Rules 11.2, 11.5, 11.6, 11.7 - Pointer conversions (Required)
   24|    262|  CheckFactories.registerCheck<AvoidIncompatiblePointerConversionCheck>(
   25|    262|      "automotive-c23-req-11.2");
   26|       |
   27|       |  // Rule 11.3 - Incompatible pointer cast (Required)
   28|    262|  CheckFactories.registerCheck<AvoidIncompatiblePointerCastCheck>(
   29|    262|      "automotive-c23-req-11.3");
   30|       |
   31|       |  // Rule 11.4 - Pointer to/from integer cast (Advisory)
   32|    262|  CheckFactories.registerCheck<AvoidPointerIntegerCastCheck>(
   33|    262|      "automotive-c23-adv-11.4");
   34|       |
   35|       |  // Rule 11.8 - Cast removing const/volatile (Required)
   36|    262|  CheckFactories.registerCheck<AvoidCastRemovingQualifierCheck>(
   37|    262|      "automotive-c23-req-11.8");
   38|       |
   39|    262|  CheckFactories.registerCheck<WrongNullPointerValueCheck>(
   40|    262|      "automotive-wrong-null-pointer-value");
   41|       |
   42|       |  // Rule 18.6 - Address of automatic object escaping (Required)
   43|    262|  CheckFactories.registerCheck<AvoidAutoAddressEscapeCheck>(
   44|    262|      "automotive-c23-req-18.6");
   45|    262|}
   46|       |
   47|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidAutoAddressEscapeCheck.cpp:
    1|       |//===--- AvoidAutoAddressEscapeCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidAutoAddressEscapeCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidAutoAddressEscapeCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match return statements with address-of local variable
   19|    131|  Finder->addMatcher(
   20|    131|      returnStmt(
   21|    131|          hasReturnValue(ignoringParenImpCasts(
   22|    131|              unaryOperator(
   23|    131|                  hasOperatorName("&"),
   24|    131|                  hasUnaryOperand(declRefExpr(to(
   25|    131|                      varDecl(hasAutomaticStorageDuration()).bind("local")))))
   26|    131|                  .bind("addrof"))))
   27|    131|          .bind("return"),
   28|    131|      this);
   29|       |
   30|       |  // Match assignment of address-of local to global/static pointer
   31|    131|  Finder->addMatcher(
   32|    131|      binaryOperator(
   33|    131|          isAssignmentOperator(),
   34|    131|          hasLHS(ignoringParenImpCasts(
   35|    131|              declRefExpr(to(varDecl(hasGlobalStorage()).bind("global"))))),
   36|    131|          hasRHS(ignoringParenImpCasts(unaryOperator(
   37|    131|              hasOperatorName("&"),
   38|    131|              hasUnaryOperand(declRefExpr(to(
   39|    131|                  varDecl(hasAutomaticStorageDuration()).bind("local2"))))))))
   40|    131|          .bind("assign"),
   41|    131|      this);
   42|       |
   43|       |  // Match initialization of global/static pointer with address-of local
   44|       |  // Note: This is harder to match since the local wouldn't exist at global
   45|       |  // init time, but catch the pattern for static local pointers
   46|    131|  Finder->addMatcher(varDecl(hasGlobalStorage(), hasType(pointerType()),
   47|    131|                             hasInitializer(ignoringParenImpCasts(unaryOperator(
   48|    131|                                 hasOperatorName("&"),
   49|    131|                                 hasUnaryOperand(declRefExpr(to(varDecl(
   50|    131|                                     hasAutomaticStorageDuration()))))))))
   51|    131|                         .bind("staticinit"),
   52|    131|                     this);
   53|    131|}
   54|       |
   55|       |void AvoidAutoAddressEscapeCheck::check(
   56|      5|    const MatchFinder::MatchResult &Result) {
   57|       |  // Case 1: Return address of local variable
   58|      5|  if (const auto *Return = Result.Nodes.getNodeAs<ReturnStmt>("return")) {
  ------------------
  |  Branch (58:19): [True: 2, False: 3]
  ------------------
   59|      2|    if (Result.SourceManager->isInSystemHeader(Return->getBeginLoc()))
  ------------------
  |  Branch (59:9): [True: 0, False: 2]
  ------------------
   60|      0|      return;
   61|       |
   62|      2|    const auto *Local = Result.Nodes.getNodeAs<VarDecl>("local");
   63|      2|    if (Local) {
  ------------------
  |  Branch (63:9): [True: 2, False: 0]
  ------------------
   64|      2|      diag(Return->getBeginLoc(),
   65|      2|           "address of automatic variable %0 returned; object will not exist "
   66|      2|           "after function returns")
   67|      2|          << Local;
   68|      2|      diag(Local->getLocation(), "variable %0 declared here",
   69|      2|           DiagnosticIDs::Note)
   70|      2|          << Local;
   71|      2|    }
   72|      2|    return;
   73|      2|  }
   74|       |
   75|       |  // Case 2: Assignment of local address to global pointer
   76|      3|  if (const auto *Assign = Result.Nodes.getNodeAs<BinaryOperator>("assign")) {
  ------------------
  |  Branch (76:19): [True: 3, False: 0]
  ------------------
   77|      3|    if (Result.SourceManager->isInSystemHeader(Assign->getOperatorLoc()))
  ------------------
  |  Branch (77:9): [True: 0, False: 3]
  ------------------
   78|      0|      return;
   79|       |
   80|      3|    const auto *Global = Result.Nodes.getNodeAs<VarDecl>("global");
   81|      3|    const auto *Local = Result.Nodes.getNodeAs<VarDecl>("local2");
   82|      3|    if (Global && Local) {
  ------------------
  |  Branch (82:9): [True: 3, False: 0]
  |  Branch (82:19): [True: 3, False: 0]
  ------------------
   83|      3|      diag(Assign->getOperatorLoc(),
   84|      3|           "address of automatic variable %0 assigned to object %1 with "
   85|      3|           "greater lifetime")
   86|      3|          << Local << Global;
   87|      3|      diag(Local->getLocation(), "automatic variable %0 declared here",
   88|      3|           DiagnosticIDs::Note)
   89|      3|          << Local;
   90|      3|    }
   91|      3|    return;
   92|      3|  }
   93|       |
   94|       |  // Case 3: Static/global initialized with address of local
   95|      0|  if (const auto *StaticInit = Result.Nodes.getNodeAs<VarDecl>("staticinit")) {
  ------------------
  |  Branch (95:19): [True: 0, False: 0]
  ------------------
   96|      0|    if (Result.SourceManager->isInSystemHeader(StaticInit->getLocation()))
  ------------------
  |  Branch (96:9): [True: 0, False: 0]
  ------------------
   97|      0|      return;
   98|       |
   99|      0|    diag(StaticInit->getLocation(),
  100|      0|         "static or global pointer %0 initialized with address of automatic "
  101|      0|         "variable")
  102|      0|        << StaticInit;
  103|      0|  }
  104|      0|}
  105|       |
  106|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/WrongNullPointerValueCheck.h:
    1|       |//===--- WrongNullPointerValueCheck.h - clang-tidy --------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGNULLPOINTERVALUECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGNULLPOINTERVALUECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of integer zero instead of NULL or nullptr for null pointers.
   17|       |///
   18|       |/// Using the integer constant 0 to represent a null pointer is less clear
   19|       |/// than using NULL (in C) or nullptr (in C++). Explicit null pointer constants
   20|       |/// improve code readability and help distinguish pointer contexts from integer
   21|       |/// contexts, reducing the risk of confusion and errors.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 11.9 - The null pointer constant should be
   24|       |/// defined as NULL rather than 0.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int *ptr = 0;  // Warning: use NULL instead of 0
   29|       |///   if (ptr == 0)  // Warning: use NULL for comparison
   30|       |///     return;
   31|       |/// \endcode
   32|       |class WrongNullPointerValueCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  WrongNullPointerValueCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~WrongNullPointerValueCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for null pointer value usage.
   44|       |  /// \param Finder The match finder to register matchers with.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched null pointer values and emits diagnostics.
   48|       |  /// \param Result The match result containing the matched AST node.
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGNULLPOINTERVALUECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidPointerIntegerCastCheck.cpp:
    1|       |//===--- AvoidPointerIntegerCastCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidPointerIntegerCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidPointerIntegerCastCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match casts from pointer to integer
   19|    131|  Finder->addMatcher(castExpr(hasSourceExpression(hasType(pointerType())),
   20|    131|                              hasType(isInteger()))
   21|    131|                         .bind("ptrToInt"),
   22|    131|                     this);
   23|       |
   24|       |  // Match casts from integer to pointer
   25|    131|  Finder->addMatcher(castExpr(hasSourceExpression(hasType(isInteger())),
   26|    131|                              hasType(pointerType()))
   27|    131|                         .bind("intToPtr"),
   28|    131|                     this);
   29|    131|}
   30|       |
   31|       |void AvoidPointerIntegerCastCheck::check(
   32|    255|    const MatchFinder::MatchResult &Result) {
   33|       |  // Handle pointer to integer cast
   34|    255|  if (const auto *Cast = Result.Nodes.getNodeAs<CastExpr>("ptrToInt")) {
  ------------------
  |  Branch (34:19): [True: 110, False: 145]
  ------------------
   35|       |    // Skip if in system header
   36|    110|    if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (36:9): [True: 90, False: 20]
  ------------------
   37|     90|      return;
   38|       |
   39|       |    // Skip implicit casts that are part of normal operations
   40|     20|    if (isa<ImplicitCastExpr>(Cast) &&
  ------------------
  |  Branch (40:9): [True: 1, False: 19]
  ------------------
   41|     20|        Cast->getCastKind() != CK_PointerToIntegral)
  ------------------
  |  Branch (41:9): [True: 1, False: 0]
  ------------------
   42|      1|      return;
   43|       |
   44|       |    // Only report explicit casts or pointer-to-integral conversions
   45|     19|    if (Cast->getCastKind() == CK_PointerToIntegral ||
  ------------------
  |  Branch (45:9): [True: 19, False: 0]
  ------------------
   46|     19|        isa<CStyleCastExpr>(Cast) || isa<CXXReinterpretCastExpr>(Cast)) {
  ------------------
  |  Branch (46:9): [True: 0, False: 0]
  |  Branch (46:38): [True: 0, False: 0]
  ------------------
   47|     19|      diag(Cast->getBeginLoc(), "cast from pointer type %0 to integer type %1")
   48|     19|          << Cast->getSubExpr()->getType() << Cast->getType();
   49|     19|    }
   50|     19|    return;
   51|     20|  }
   52|       |
   53|       |  // Handle integer to pointer cast
   54|    145|  if (const auto *Cast = Result.Nodes.getNodeAs<CastExpr>("intToPtr")) {
  ------------------
  |  Branch (54:19): [True: 145, False: 0]
  ------------------
   55|       |    // Skip if in system header
   56|    145|    if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (56:9): [True: 80, False: 65]
  ------------------
   57|     80|      return;
   58|       |
   59|       |    // Skip implicit casts
   60|     65|    if (isa<ImplicitCastExpr>(Cast) &&
  ------------------
  |  Branch (60:9): [True: 18, False: 47]
  ------------------
   61|     65|        Cast->getCastKind() != CK_IntegralToPointer)
  ------------------
  |  Branch (61:9): [True: 16, False: 2]
  ------------------
   62|     16|      return;
   63|       |
   64|       |    // Skip null pointer constant (0 or NULL)
   65|     49|    const Expr *SubExpr = Cast->getSubExpr()->IgnoreParenImpCasts();
   66|     49|    if (SubExpr->isNullPointerConstant(*Result.Context,
  ------------------
  |  Branch (66:9): [True: 27, False: 22]
  ------------------
   67|     49|                                       Expr::NPC_ValueDependentIsNull))
   68|     27|      return;
   69|       |
   70|       |    // Only report explicit casts or integral-to-pointer conversions
   71|     22|    if (Cast->getCastKind() == CK_IntegralToPointer ||
  ------------------
  |  Branch (71:9): [True: 22, False: 0]
  ------------------
   72|     22|        isa<CStyleCastExpr>(Cast) || isa<CXXReinterpretCastExpr>(Cast)) {
  ------------------
  |  Branch (72:9): [True: 0, False: 0]
  |  Branch (72:38): [True: 0, False: 0]
  ------------------
   73|     22|      diag(Cast->getBeginLoc(), "cast from integer type %0 to pointer type %1")
   74|     22|          << Cast->getSubExpr()->getType() << Cast->getType();
   75|     22|    }
   76|     22|  }
   77|    145|}
   78|       |
   79|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidCastRemovingQualifierCheck.h:
    1|       |//===--- AvoidCastRemovingQualifierCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCASTREMOVINGQUALIFIERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCASTREMOVINGQUALIFIERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-pointer
   17|       |/// @brief Detects casts that remove const or volatile qualifiers from pointers.
   18|       |///
   19|       |/// A cast shall not remove any const or volatile qualification from the type
   20|       |/// pointed to by a pointer. Casting away const allows modification of objects
   21|       |/// that were intended to be read-only, potentially causing undefined behavior.
   22|       |/// Casting away volatile may cause the compiler to optimize away necessary
   23|       |/// accesses.
   24|       |///
   25|       |/// @par MISRA C:2025 Rule 11.8
   26|       |/// A cast shall not remove any const or volatile qualification from the type
   27|       |/// pointed to by a pointer.
   28|       |/// @par Category: Required
   29|       |///
   30|       |/// Example:
   31|       |/// @code
   32|       |///   const int *pc = &x;
   33|       |///   int *p = (int *)pc;          // Warning: removes const
   34|       |///
   35|       |///   volatile int *pv = &v;
   36|       |///   int *q = (int *)pv;          // Warning: removes volatile
   37|       |///
   38|       |///   const volatile int *pcv;
   39|       |///   int *r = (int *)pcv;         // Warning: removes const and volatile
   40|       |/// @endcode
   41|       |class AvoidCastRemovingQualifierCheck : public ClangTidyCheck {
   42|       |public:
   43|       |  AvoidCastRemovingQualifierCheck(StringRef Name, ClangTidyContext *Context)
   44|    131|      : ClangTidyCheck(Name, Context) {}
   45|       |
   46|       |  /// Destructor.
   47|    131|  ~AvoidCastRemovingQualifierCheck() override = default;
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCASTREMOVINGQUALIFIERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/WrongNullPointerValueCheck.cpp:
    1|       |//===--- WrongNullPointerValueCheck.cpp - clang-tidy ----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "WrongNullPointerValueCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void WrongNullPointerValueCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(
   18|    131|      expr(anyOf(
   19|    131|          implicitCastExpr(hasSourceExpression(integerLiteral(equals(0))),
   20|    131|                           hasType(pointerType()))
   21|    131|              .bind("assign"),
   22|    131|          binaryOperator(hasOperatorName("=="),
   23|    131|                         hasLHS(expr(hasType(pointerType()))),
   24|    131|                         hasRHS(integerLiteral(equals(0))))
   25|    131|              .bind("compare"),
   26|    131|          conditionalOperator(hasTrueExpression(integerLiteral(equals(0))),
   27|    131|                              hasFalseExpression(hasType(pointerType())))
   28|    131|              .bind("ternary"),
   29|    131|          conditionalOperator(hasFalseExpression(integerLiteral(equals(0))),
   30|    131|                              hasTrueExpression(hasType(pointerType())))
   31|    131|              .bind("ternary"))),
   32|    131|      this);
   33|    131|}
   34|       |
   35|     97|void WrongNullPointerValueCheck::check(const MatchFinder::MatchResult &Result) {
   36|     97|  if (const auto *E = Result.Nodes.getNodeAs<Expr>("assign")) {
  ------------------
  |  Branch (36:19): [True: 95, False: 2]
  ------------------
   37|     95|    diag(E->getBeginLoc(),
   38|     95|         "Use NULL instead of 0 for null pointer assignment.");
   39|     95|  } else if (const auto *E = Result.Nodes.getNodeAs<Expr>("compare")) {
  ------------------
  |  Branch (39:26): [True: 2, False: 0]
  ------------------
   40|      2|    diag(E->getBeginLoc(), "Use NULL instead of 0 in pointer comparisons.");
   41|      2|  } else if (const auto *E = Result.Nodes.getNodeAs<Expr>("ternary")) {
  ------------------
  |  Branch (41:26): [True: 0, False: 0]
  ------------------
   42|      0|    diag(
   43|      0|        E->getBeginLoc(),
   44|      0|        "Use NULL instead of 0 in conditional expressions involving pointers.");
   45|      0|  }
   46|     97|}
   47|       |
   48|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidIncompatiblePointerConversionCheck.h:
    1|       |//===--- AvoidIncompatiblePointerConversionCheck.h - clang-tidy -*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPOINTERCONVERSIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPOINTERCONVERSIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-pointer
   17|       |/// @brief Detects incompatible pointer conversions.
   18|       |///
   19|       |/// Implements MISRA Rules 11.2, 11.5, 11.6, 11.7:
   20|       |/// - 11.2: Conversion from incomplete type pointer
   21|       |/// - 11.5: Conversion from void pointer to object pointer
   22|       |/// - 11.6: Conversion between pointer to void and arithmetic type
   23|       |/// - 11.7: Conversion between pointer to object and non-integer arithmetic
   24|       |///
   25|       |/// @par Category: Required/Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   void *vp;
   30|       |///   int *ip = (int *)vp;     // Warning: void* to object pointer
   31|       |///   int x = (int)vp;          // Warning: pointer to integer
   32|       |/// @endcode
   33|       |class AvoidIncompatiblePointerConversionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidIncompatiblePointerConversionCheck(StringRef Name,
   36|       |                                          ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidIncompatiblePointerConversionCheck() override = default;
   41|       |
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPOINTERCONVERSIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidCastRemovingQualifierCheck.cpp:
    1|       |//===--- AvoidCastRemovingQualifierCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCastRemovingQualifierCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidCastRemovingQualifierCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match C-style casts and explicit casts
   19|    131|  Finder->addMatcher(cStyleCastExpr().bind("cast"), this);
   20|    131|  Finder->addMatcher(cxxStaticCastExpr().bind("cast"), this);
   21|    131|  Finder->addMatcher(cxxReinterpretCastExpr().bind("cast"), this);
   22|    131|  Finder->addMatcher(cxxConstCastExpr().bind("cast"), this);
   23|    131|}
   24|       |
   25|       |void AvoidCastRemovingQualifierCheck::check(
   26|    870|    const MatchFinder::MatchResult &Result) {
   27|    870|  const auto *Cast = Result.Nodes.getNodeAs<ExplicitCastExpr>("cast");
   28|    870|  if (!Cast)
  ------------------
  |  Branch (28:7): [True: 0, False: 870]
  ------------------
   29|      0|    return;
   30|       |
   31|       |  // Skip casts in system headers
   32|    870|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (32:7): [True: 440, False: 430]
  ------------------
   33|    440|    return;
   34|       |
   35|    430|  QualType SourceType = Cast->getSubExpr()->getType();
   36|    430|  QualType DestType = Cast->getType();
   37|       |
   38|       |  // We only care about pointer types
   39|    430|  if (!SourceType->isPointerType() || !DestType->isPointerType())
  ------------------
  |  Branch (39:7): [True: 278, False: 152]
  |  Branch (39:39): [True: 85, False: 67]
  ------------------
   40|    363|    return;
   41|       |
   42|       |  // Get the pointed-to types
   43|     67|  QualType SourcePointee = SourceType->getPointeeType();
   44|     67|  QualType DestPointee = DestType->getPointeeType();
   45|       |
   46|       |  // Check for removed qualifiers
   47|     67|  bool RemovedConst =
   48|     67|      SourcePointee.isConstQualified() && !DestPointee.isConstQualified();
  ------------------
  |  Branch (48:7): [True: 13, False: 54]
  |  Branch (48:43): [True: 10, False: 3]
  ------------------
   49|     67|  bool RemovedVolatile =
   50|     67|      SourcePointee.isVolatileQualified() && !DestPointee.isVolatileQualified();
  ------------------
  |  Branch (50:7): [True: 9, False: 58]
  |  Branch (50:46): [True: 7, False: 2]
  ------------------
   51|       |
   52|     67|  if (RemovedConst && RemovedVolatile) {
  ------------------
  |  Branch (52:7): [True: 10, False: 57]
  |  Branch (52:23): [True: 2, False: 8]
  ------------------
   53|      2|    diag(Cast->getBeginLoc(),
   54|      2|         "cast removes 'const' and 'volatile' qualifiers from pointer type");
   55|     65|  } else if (RemovedConst) {
  ------------------
  |  Branch (55:14): [True: 8, False: 57]
  ------------------
   56|      8|    diag(Cast->getBeginLoc(),
   57|      8|         "cast removes 'const' qualifier from pointer type");
   58|     57|  } else if (RemovedVolatile) {
  ------------------
  |  Branch (58:14): [True: 5, False: 52]
  ------------------
   59|      5|    diag(Cast->getBeginLoc(),
   60|      5|         "cast removes 'volatile' qualifier from pointer type");
   61|      5|  }
   62|     67|}
   63|       |
   64|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidAutoAddressEscapeCheck.h:
    1|       |//===--- AvoidAutoAddressEscapeCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAUTOADDRESSESCAPECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAUTOADDRESSESCAPECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects address of automatic objects escaping their scope.
   17|       |///
   18|       |/// MISRA C:2025 Rule 18.6 requires that the address of an object with
   19|       |/// automatic storage duration shall not be copied to another object that
   20|       |/// persists after the first object has ceased to exist.
   21|       |///
   22|       |/// This check detects common cases where an address of a local variable:
   23|       |/// - Is returned from a function
   24|       |/// - Is assigned to a global or static pointer
   25|       |/// - Is stored in a struct/array that outlives the local
   26|       |///
   27|       |/// Example of non-compliant code:
   28|       |/// \code
   29|       |///   int *global_ptr;
   30|       |///   int *get_ptr(void) {
   31|       |///     int local = 42;
   32|       |///     return &local;      // Address escapes via return
   33|       |///   }
   34|       |///   void store_ptr(void) {
   35|       |///     int local = 42;
   36|       |///     global_ptr = &local; // Address escapes to global
   37|       |///   }
   38|       |/// \endcode
   39|       |class AvoidAutoAddressEscapeCheck : public ClangTidyCheck {
   40|       |public:
   41|       |  /// Constructs the check with the given name and context.
   42|       |  AvoidAutoAddressEscapeCheck(StringRef Name, ClangTidyContext *Context)
   43|    131|      : ClangTidyCheck(Name, Context) {}
   44|       |
   45|       |  /// Destructor.
   46|    131|  ~AvoidAutoAddressEscapeCheck() override = default;
   47|       |
   48|       |  /// Registers AST matchers for address-of expressions.
   49|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   50|       |
   51|       |  /// Handles matched expressions and emits diagnostics.
   52|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   53|       |};
   54|       |
   55|       |} // namespace clang::tidy::automotive
   56|       |
   57|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDAUTOADDRESSESCAPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidIncompatiblePointerCastCheck.cpp:
    1|       |//===--- AvoidIncompatiblePointerCastCheck.cpp - clang-tidy ---------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidIncompatiblePointerCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidIncompatiblePointerCastCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match C-style casts and reinterpret_cast
   19|    131|  Finder->addMatcher(castExpr(hasSourceExpression(hasType(pointerType())),
   20|    131|                              hasType(pointerType()))
   21|    131|                         .bind("cast"),
   22|    131|                     this);
   23|    131|}
   24|       |
   25|       |void AvoidIncompatiblePointerCastCheck::check(
   26|  1.56k|    const MatchFinder::MatchResult &Result) {
   27|  1.56k|  const auto *Cast = Result.Nodes.getNodeAs<CastExpr>("cast");
   28|  1.56k|  if (!Cast)
  ------------------
  |  Branch (28:7): [True: 0, False: 1.56k]
  ------------------
   29|      0|    return;
   30|       |
   31|       |  // Skip if in system header
   32|  1.56k|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (32:7): [True: 1.23k, False: 326]
  ------------------
   33|  1.23k|    return;
   34|       |
   35|       |  // Skip implicit casts
   36|    326|  if (Cast->getCastKind() == CK_LValueToRValue ||
  ------------------
  |  Branch (36:7): [True: 215, False: 111]
  ------------------
   37|    326|      Cast->getCastKind() == CK_NoOp ||
  ------------------
  |  Branch (37:7): [True: 51, False: 60]
  ------------------
   38|    326|      Cast->getCastKind() == CK_ArrayToPointerDecay ||
  ------------------
  |  Branch (38:7): [True: 0, False: 60]
  ------------------
   39|    326|      Cast->getCastKind() == CK_FunctionToPointerDecay)
  ------------------
  |  Branch (39:7): [True: 0, False: 60]
  ------------------
   40|    266|    return;
   41|       |
   42|       |  // Get the source and destination types
   43|     60|  QualType SrcType = Cast->getSubExpr()->getType();
   44|     60|  QualType DstType = Cast->getType();
   45|       |
   46|       |  // Get pointee types
   47|     60|  const PointerType *SrcPtr = SrcType->getAs<PointerType>();
   48|     60|  const PointerType *DstPtr = DstType->getAs<PointerType>();
   49|       |
   50|     60|  if (!SrcPtr || !DstPtr)
  ------------------
  |  Branch (50:7): [True: 0, False: 60]
  |  Branch (50:18): [True: 0, False: 60]
  ------------------
   51|      0|    return;
   52|       |
   53|     60|  QualType SrcPointee = SrcPtr->getPointeeType().getUnqualifiedType();
   54|     60|  QualType DstPointee = DstPtr->getPointeeType().getUnqualifiedType();
   55|       |
   56|       |  // Skip if same type (ignoring qualifiers)
   57|     60|  if (SrcPointee == DstPointee)
  ------------------
  |  Branch (57:7): [True: 0, False: 60]
  ------------------
   58|      0|    return;
   59|       |
   60|       |  // Allow casts to/from void*
   61|     60|  if (SrcPointee->isVoidType() || DstPointee->isVoidType())
  ------------------
  |  Branch (61:7): [True: 24, False: 36]
  |  Branch (61:35): [True: 8, False: 28]
  ------------------
   62|     32|    return;
   63|       |
   64|       |  // Allow casts to char* or unsigned char* (commonly used for byte access)
   65|     28|  if (DstPointee->isCharType() ||
  ------------------
  |  Branch (65:7): [True: 2, False: 26]
  ------------------
   66|     28|      (DstPointee->isSpecificBuiltinType(BuiltinType::UChar)))
  ------------------
  |  Branch (66:7): [True: 0, False: 26]
  ------------------
   67|      2|    return;
   68|       |
   69|       |  // Allow casts from char* or unsigned char*
   70|     26|  if (SrcPointee->isCharType() ||
  ------------------
  |  Branch (70:7): [True: 3, False: 23]
  ------------------
   71|     26|      (SrcPointee->isSpecificBuiltinType(BuiltinType::UChar)))
  ------------------
  |  Branch (71:7): [True: 0, False: 23]
  ------------------
   72|      3|    return;
   73|       |
   74|       |  // Report incompatible pointer cast
   75|     23|  diag(Cast->getBeginLoc(),
   76|     23|       "cast from %0 to %1 converts between incompatible pointer types")
   77|     23|      << SrcType << DstType;
   78|     23|}
   79|       |
   80|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidIncompatiblePointerCastCheck.h:
    1|       |//===--- AvoidIncompatiblePointerCastCheck.h - clang-tidy -------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPTRCASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPTRCASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-pointer
   17|       |/// @brief Detects casts between pointers to incompatible object types.
   18|       |///
   19|       |/// A cast shall not be performed between a pointer to object type and a
   20|       |/// pointer to a different object type. Such casts can violate alignment
   21|       |/// requirements and lead to undefined behavior due to strict aliasing rules.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 11.3
   24|       |/// A cast shall not be performed between a pointer to object type and a
   25|       |/// pointer to a different object type.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   int *pi = &i;
   31|       |///   float *pf = (float *)pi;    // Warning: incompatible pointer cast
   32|       |///   char *pc = (char *)pi;      // Allowed: char* is special case
   33|       |///   void *pv = (void *)pi;      // Allowed: void* is generic
   34|       |///   int *pi2 = (int *)pv;       // Allowed: converting back from void*
   35|       |/// @endcode
   36|       |class AvoidIncompatiblePointerCastCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidIncompatiblePointerCastCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidIncompatiblePointerCastCheck() override = default;
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPATIBLEPTRCASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/pointer/AvoidIncompatiblePointerConversionCheck.cpp:
    1|       |//===--- AvoidIncompatiblePointerConversionCheck.cpp - clang-tidy ---------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidIncompatiblePointerConversionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void AvoidIncompatiblePointerConversionCheck::registerMatchers(
   18|    131|    MatchFinder *Finder) {
   19|       |  // Match C-style casts involving pointers
   20|    131|  Finder->addMatcher(cStyleCastExpr().bind("cast"), this);
   21|    131|}
   22|       |
   23|       |void AvoidIncompatiblePointerConversionCheck::check(
   24|    603|    const MatchFinder::MatchResult &Result) {
   25|    603|  const auto *Cast = Result.Nodes.getNodeAs<CStyleCastExpr>("cast");
   26|    603|  if (!Cast)
  ------------------
  |  Branch (26:7): [True: 0, False: 603]
  ------------------
   27|      0|    return;
   28|       |
   29|    603|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (29:7): [True: 192, False: 411]
  ------------------
   30|    192|    return;
   31|       |
   32|    411|  QualType FromType = Cast->getSubExpr()->getType();
   33|    411|  QualType ToType = Cast->getType();
   34|       |
   35|       |  // Rule 11.5: void* to object pointer
   36|    411|  if (FromType->isVoidPointerType() && ToType->isPointerType() &&
  ------------------
  |  Branch (36:7): [True: 17, False: 394]
  |  Branch (36:40): [True: 6, False: 11]
  ------------------
   37|    411|      !ToType->isVoidPointerType()) {
  ------------------
  |  Branch (37:7): [True: 6, False: 0]
  ------------------
   38|      6|    diag(Cast->getBeginLoc(),
   39|      6|         "conversion from void pointer to object pointer; consider using "
   40|      6|         "explicit type from the start");
   41|      6|    return;
   42|      6|  }
   43|       |
   44|       |  // Rule 11.6: pointer to void and arithmetic type conversions
   45|    405|  if (FromType->isVoidPointerType() && ToType->isArithmeticType()) {
  ------------------
  |  Branch (45:7): [True: 11, False: 394]
  |  Branch (45:40): [True: 4, False: 7]
  ------------------
   46|      4|    diag(Cast->getBeginLoc(),
   47|      4|         "conversion from void pointer to arithmetic type is not allowed");
   48|      4|    return;
   49|      4|  }
   50|    401|  if (FromType->isArithmeticType() && ToType->isVoidPointerType()) {
  ------------------
  |  Branch (50:7): [True: 258, False: 143]
  |  Branch (50:39): [True: 30, False: 228]
  ------------------
   51|     30|    diag(Cast->getBeginLoc(),
   52|     30|         "conversion from arithmetic type to void pointer is not allowed");
   53|     30|    return;
   54|     30|  }
   55|       |
   56|       |  // Rule 11.7: pointer to object and non-integer arithmetic
   57|    371|  if (FromType->isPointerType() && ToType->isFloatingType()) {
  ------------------
  |  Branch (57:7): [True: 134, False: 237]
  |  Branch (57:36): [True: 0, False: 134]
  ------------------
   58|      0|    diag(Cast->getBeginLoc(),
   59|      0|         "conversion from pointer to floating type is not allowed");
   60|      0|    return;
   61|      0|  }
   62|    371|  if (FromType->isFloatingType() && ToType->isPointerType()) {
  ------------------
  |  Branch (62:7): [True: 12, False: 359]
  |  Branch (62:37): [True: 0, False: 12]
  ------------------
   63|      0|    diag(Cast->getBeginLoc(),
   64|      0|         "conversion from floating type to pointer is not allowed");
   65|      0|    return;
   66|      0|  }
   67|       |
   68|       |  // Rule 11.2: conversion involving incomplete type pointer
   69|    371|  if (!FromType->isPointerType())
  ------------------
  |  Branch (69:7): [True: 237, False: 134]
  ------------------
   70|    237|    return;
   71|       |
   72|    134|  QualType PointeeType = FromType->getPointeeType();
   73|    134|  if (PointeeType->isIncompleteType() && !PointeeType->isVoidType())
  ------------------
  |  Branch (73:7): [True: 8, False: 126]
  |  Branch (73:42): [True: 1, False: 7]
  ------------------
   74|      1|    diag(Cast->getBeginLoc(),
   75|      1|         "conversion from pointer to incomplete type is not allowed");
   76|    134|}
   77|       |
   78|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/AvoidBitfieldInUnionCheck.h:
    1|       |//===--- AvoidBitfieldInUnionCheck.h - clang-tidy ---------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBITFIELDINUNIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBITFIELDINUNIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects bit-field members within union declarations.
   17|       |///
   18|       |/// Bit-fields in unions have implementation-defined behavior and can lead to
   19|       |/// portability issues. The storage allocation and padding of bit-fields within
   20|       |/// unions varies across different compilers and architectures, making code
   21|       |/// non-portable and difficult to reason about.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 19.2 - A union shall not contain bit-field
   24|       |/// members.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   union Data {
   29|       |///     unsigned int flags : 8;  // Warning: bit-field in union
   30|       |///     int value;
   31|       |///   };
   32|       |/// \endcode
   33|       |class AvoidBitfieldInUnionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  AvoidBitfieldInUnionCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidBitfieldInUnionCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for bit-field members in unions.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched bit-field members and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDBITFIELDINUNIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/AvoidSignedSingleBitFieldCheck.h:
    1|       |//===--- AvoidSignedSingleBitFieldCheck.h - clang-tidy ----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNEDSINGLEBITFIELDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNEDSINGLEBITFIELDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-types
   17|       |/// @brief Detects single-bit bit-fields with signed types.
   18|       |///
   19|       |/// A signed bit-field with width of 1 can only represent values 0 and -1,
   20|       |/// which is rarely the intended behavior and often leads to confusion.
   21|       |/// Developers typically expect single-bit fields to represent boolean values
   22|       |/// (0 or 1), which requires an unsigned type.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 6.2
   25|       |/// Single-bit named bit-fields shall not be of a signed type.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// \code
   30|       |///   struct Flags {
   31|       |///     signed int flag : 1;  // Warning: signed single-bit field
   32|       |///   };
   33|       |/// \endcode
   34|       |class AvoidSignedSingleBitFieldCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  /// Constructs the check with the given name and context.
   37|       |  /// \param Name The name of the check as registered.
   38|       |  /// \param Context The clang-tidy context for configuration.
   39|       |  AvoidSignedSingleBitFieldCheck(StringRef Name, ClangTidyContext *Context)
   40|    131|      : ClangTidyCheck(Name, Context) {}
   41|       |
   42|       |  /// Destructor.
   43|    131|  ~AvoidSignedSingleBitFieldCheck() override = default;
   44|       |
   45|       |  /// Registers AST matchers for signed single-bit fields.
   46|       |  /// \param Finder The match finder to register matchers with.
   47|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   48|       |
   49|       |  /// Handles matched signed single-bit fields and emits diagnostics.
   50|       |  /// \param Result The match result containing the matched AST node.
   51|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   52|       |};
   53|       |
   54|       |} // namespace clang::tidy::automotive
   55|       |
   56|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSIGNEDSINGLEBITFIELDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/WrongBitfieldTypeCheck.h:
    1|       |//===--- WrongBitfieldTypeCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGBITFIELDTYPECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGBITFIELDTYPECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects bit-fields declared with inappropriate types.
   17|       |///
   18|       |/// Bit-fields should only be declared with appropriate integer types to ensure
   19|       |/// portability and well-defined behavior. Using other types like enums or
   20|       |/// non-standard integer types can lead to implementation-defined behavior and
   21|       |/// portability issues across different compilers and platforms.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 6.1 - Bit-fields shall only be declared with an
   24|       |/// appropriate type.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   struct Config {
   29|       |///     _Bool flag : 2;     // Warning: inappropriate type for bit-field
   30|       |///     float value : 4;    // Warning: inappropriate type for bit-field
   31|       |///   };
   32|       |/// \endcode
   33|       |class WrongBitfieldTypeCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  WrongBitfieldTypeCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~WrongBitfieldTypeCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for bit-field declarations.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched bit-fields and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGBITFIELDTYPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/AvoidSignedSingleBitFieldCheck.cpp:
    1|       |//===--- AvoidSignedSingleBitFieldCheck.cpp - clang-tidy ------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSignedSingleBitFieldCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidSignedSingleBitFieldCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(fieldDecl(allOf(isBitField(), hasType(isSignedInteger()),
   19|    131|                                     hasDescendant(integerLiteral(equals(1)))))
   20|    131|                         .bind("signedBitField"),
   21|    131|                     this);
   22|    131|}
   23|       |
   24|       |void AvoidSignedSingleBitFieldCheck::check(
   25|      5|    const MatchFinder::MatchResult &Result) {
   26|      5|  const auto *MatchedDecl = Result.Nodes.getNodeAs<FieldDecl>("signedBitField");
   27|       |
   28|      5|  if (MatchedDecl) {
  ------------------
  |  Branch (28:7): [True: 5, False: 0]
  ------------------
   29|      5|    diag(MatchedDecl->getLocation(),
   30|      5|         "avoid signed type for bitfields of single bit");
   31|      5|  }
   32|      5|}
   33|       |
   34|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/WrongBitfieldTypeCheck.cpp:
    1|       |//===--- WrongBitfieldTypeCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "WrongBitfieldTypeCheck.h"
   10|       |#include "clang/AST/Decl.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void WrongBitfieldTypeCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      fieldDecl(allOf(isBitField(),
   20|    131|                      unless(hasType(qualType(hasCanonicalType(anyOf(
   21|    131|                          asString("signed int"), asString("unsigned int")))))),
   22|    131|                      unless(hasType(booleanType()))))
   23|    131|          .bind("bitField"),
   24|    131|      this);
   25|    131|}
   26|       |
   27|     16|void WrongBitfieldTypeCheck::check(const MatchFinder::MatchResult &Result) {
   28|       |
   29|     16|  const auto *MatchedBitField = Result.Nodes.getNodeAs<FieldDecl>("bitField");
   30|       |
   31|     16|  if (!MatchedBitField) {
  ------------------
  |  Branch (31:7): [True: 0, False: 16]
  ------------------
   32|      0|    return;
   33|      0|  }
   34|       |
   35|     16|  diag(MatchedBitField->getLocation(), "wrong type in bitfield");
   36|     16|}
   37|       |
   38|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/BitfieldComponent.cpp:
    1|       |//===--- BitfieldComponent.cpp - clang-tidy ----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "BitfieldComponent.h"
   10|       |#include "AvoidBitfieldInUnionCheck.h"
   11|       |#include "AvoidSignedSingleBitFieldCheck.h"
   12|       |#include "WrongBitfieldTypeCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |void BitfieldComponent::addCheckFactories(
   17|    262|    ClangTidyCheckFactories &CheckFactories) {
   18|       |
   19|    262|  CheckFactories.registerCheck<WrongBitfieldTypeCheck>(
   20|    262|      "automotive-wrong-bitfield-type");
   21|    262|  CheckFactories.registerCheck<AvoidSignedSingleBitFieldCheck>(
   22|    262|      "automotive-avoid-signed-single-bitfield");
   23|    262|  CheckFactories.registerCheck<AvoidBitfieldInUnionCheck>(
   24|    262|      "automotive-avoid-bitfield-in-union");
   25|    262|}
   26|       |
   27|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/bitfield/AvoidBitfieldInUnionCheck.cpp:
    1|       |//===--- AvoidBitfieldInUnionCheck.cpp - clang-tidy -----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidBitfieldInUnionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidBitfieldInUnionCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(recordDecl(allOf(isUnion(), has(fieldDecl(isBitField()))))
   19|    131|                         .bind("unionWithBitfield"),
   20|    131|                     this);
   21|    131|}
   22|       |
   23|      4|void AvoidBitfieldInUnionCheck::check(const MatchFinder::MatchResult &Result) {
   24|      4|  const auto *MatchedDecl =
   25|      4|      Result.Nodes.getNodeAs<RecordDecl>("unionWithBitfield");
   26|       |
   27|      4|  if (MatchedDecl) {
  ------------------
  |  Branch (27:7): [True: 4, False: 0]
  ------------------
   28|      4|    diag(MatchedDecl->getLocation(), "avoid bitfield in union");
   29|      4|  }
   30|      4|}
   31|       |
   32|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/comment/CommentComponent.cpp:
    1|       |//===--- CommentComponent.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "CommentComponent.h"
   10|       |#include "AvoidCommentWithinCommentCheck.h"
   11|       |#include "AvoidLinesplicingWithinCommentCheck.h"
   12|       |
   13|       |namespace clang::tidy::automotive {
   14|       |
   15|       |void CommentComponent::addCheckFactories(
   16|    262|    ClangTidyCheckFactories &CheckFactories) {
   17|       |
   18|    262|  CheckFactories.registerCheck<AvoidCommentWithinCommentCheck>(
   19|    262|      "automotive-avoid-comment-within-comment");
   20|    262|  CheckFactories.registerCheck<AvoidLinesplicingWithinCommentCheck>(
   21|    262|      "automotive-avoid-line-splicing-within-comment");
   22|    262|}
   23|       |
   24|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/comment/CommentMatch.h:
    1|       |//===--- CommentMatch.h - clang-tidy ---------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_COMMENTMATCH_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_COMMENTMATCH_H
   11|       |
   12|       |#include "../utils/IgnoreLineSpliceRef.h"
   13|       |#include "llvm/ADT/StringRef.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |enum class CommentKind { None, SingleLine, MultiLine };
   18|       |
   19|       |struct CommentMatch {
   20|       |  size_t Index = 0;
   21|       |  size_t Size = 0;
   22|       |  CommentKind Kind = CommentKind::None;
   23|       |
   24|  22.3k|  bool isValid() const { return Kind != CommentKind::None; }
   25|      0|  bool isMultiLine() const { return Kind == CommentKind::MultiLine; }
   26|  22.3k|  bool isSingleLine() const { return Kind == CommentKind::SingleLine; }
   27|       |};
   28|       |
   29|  44.7k|inline CommentMatch matchComment(StringRef CommentText) {
   30|  44.7k|  if (CommentText.size() >= 2) {
  ------------------
  |  Branch (30:7): [True: 44.7k, False: 0]
  ------------------
   31|  44.7k|    IgnoreLineSpliceRef FilteredText(CommentText);
   32|       |
   33|  44.7k|    auto It = FilteredText.begin();
   34|  44.7k|    char PrevCh = *It;
   35|  44.7k|    char Ch = *(++It);
   36|       |
   37|  44.7k|    if (PrevCh == '/' && Ch == '*') {
  ------------------
  |  Branch (37:9): [True: 44.7k, False: 0]
  |  Branch (37:26): [True: 23.3k, False: 21.4k]
  ------------------
   38|  23.3k|      auto ReverseIt = FilteredText.rbegin();
   39|  23.3k|      char RPrevCh = *ReverseIt;
   40|  23.3k|      char RCh = *(--ReverseIt);
   41|       |
   42|  23.3k|      if (RPrevCh == '/' && RCh == '*') {
  ------------------
  |  Branch (42:11): [True: 23.3k, False: 0]
  |  Branch (42:29): [True: 23.3k, False: 0]
  ------------------
   43|  23.3k|        size_t StartIndex = It.position();
   44|  23.3k|        size_t EndIndex = ReverseIt.position();
   45|  23.3k|        size_t Size = EndIndex - StartIndex;
   46|       |
   47|  23.3k|        return {StartIndex, Size, CommentKind::MultiLine};
   48|  23.3k|      }
   49|  23.3k|    }
   50|       |
   51|  21.4k|    else if (PrevCh == '/' && Ch == '/') {
  ------------------
  |  Branch (51:14): [True: 21.4k, False: 0]
  |  Branch (51:31): [True: 21.4k, False: 0]
  ------------------
   52|  21.4k|      size_t StartIndex = It.position();
   53|  21.4k|      size_t Size = CommentText.size() - StartIndex;
   54|  21.4k|      return {StartIndex, Size, CommentKind::SingleLine};
   55|  21.4k|    }
   56|  44.7k|  }
   57|      0|  return {};
   58|  44.7k|}
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_COMMENTMATCH_H

/home/e/Development/clang-tidy-automotive/src/automotive/comment/AvoidCommentWithinCommentCheck.h:
    1|       |//===--- AvoidCommentWithinCommentCheck.h - clang-tidy ----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMENTWITHINCOMMENTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMENTWITHINCOMMENTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "clang/Lex/Preprocessor.h"
   14|       |#include "llvm/ADT/StringSet.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |/// Detects nested comment sequences within C-style comments.
   19|       |///
   20|       |/// Attempting to nest comments can lead to unintended code being commented out
   21|       |/// or activated, as the first occurrence of */ will close the outer comment.
   22|       |/// This can cause logic errors and make code difficult to maintain.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 3.1 - The character sequences /* and // shall
   25|       |/// not appear within a comment.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   /* This is a comment /* with nested comment */ markers */  // Warning
   30|       |/// \endcode
   31|       |class AvoidCommentWithinCommentCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  /// \param x Unused parameter for compatibility.
   37|       |  AvoidCommentWithinCommentCheck(StringRef Name, ClangTidyContext *Context,
   38|       |                                 int x = 0)
   39|    131|      : ClangTidyCheck(Name, Context), Handler(*this) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidCommentWithinCommentCheck() override = default;
   43|       |
   44|       |  /// Registers preprocessor callbacks for comment handling.
   45|       |  /// \param SM The source manager.
   46|       |  /// \param PP The preprocessor instance.
   47|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   48|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   49|       |                           Preprocessor *ModuleExpanderPP) override;
   50|       |
   51|       |private:
   52|       |  class InternalCommentHandler : public CommentHandler {
   53|       |  public:
   54|       |    explicit InternalCommentHandler(AvoidCommentWithinCommentCheck &Check);
   55|    131|    ~InternalCommentHandler() override = default;
   56|       |    bool HandleComment(Preprocessor &PP, SourceRange Comment) override;
   57|       |
   58|       |  private:
   59|       |    void CheckComment(SourceLocation CommentLoc, StringRef CommentText);
   60|       |    void checkURLProtocol(SourceLocation CommentLoc, StringRef CommentText,
   61|       |                          size_t Index);
   62|       |
   63|       |    AvoidCommentWithinCommentCheck &Check;
   64|       |    llvm::StringSet<> Protocols;
   65|       |  };
   66|       |
   67|       |  InternalCommentHandler Handler;
   68|       |};
   69|       |
   70|       |} // namespace clang::tidy::automotive
   71|       |
   72|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMENTWITHINCOMMENTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/comment/AvoidCommentWithinCommentCheck.cpp:
    1|       |//===--- AvoidCommentWithinCommentCheck.cpp - clang-tidy ------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCommentWithinCommentCheck.h"
   10|       |#include "../utils/IgnoreLineSpliceRef.h"
   11|       |#include "CommentMatch.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |static constexpr std::initializer_list<const char *> DefaultProtocols = {
   18|       |    "http", "https", "ftp", "ftps", "ssh", "file", "sftp", "svn", "git"};
   19|       |
   20|       |enum State {
   21|       |  Normal = 0,
   22|       |  ExpectCommentStart,
   23|       |  ExpectCommentEnd,
   24|       |  ExpectURLPattern,
   25|       |  CommentSingleLine,
   26|       |  CommentStart,
   27|       |  CommentEnd
   28|       |};
   29|       |
   30|       |static constexpr State getNextState(State CurrentState, char Ch);
   31|       |
   32|       |static constexpr State stateNormal(char Ch);
   33|       |static constexpr State stateExpectCommentStart(char Ch);
   34|       |static constexpr State stateExpectCommentEnd(char Ch);
   35|       |
   36|       |void AvoidCommentWithinCommentCheck::registerPPCallbacks(
   37|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   38|    131|  PP->addCommentHandler(&Handler);
   39|    131|}
   40|       |
   41|       |AvoidCommentWithinCommentCheck::InternalCommentHandler::InternalCommentHandler(
   42|       |    AvoidCommentWithinCommentCheck &Check)
   43|    131|    : Check(Check) {
   44|  1.17k|  for (const char *Protocol : DefaultProtocols) {
  ------------------
  |  Branch (44:29): [True: 1.17k, False: 131]
  ------------------
   45|  1.17k|    Protocols.insert(Protocol);
   46|  1.17k|  }
   47|    131|}
   48|       |
   49|       |bool AvoidCommentWithinCommentCheck::InternalCommentHandler::HandleComment(
   50|  22.3k|    Preprocessor &PP, SourceRange Comment) {
   51|       |
   52|  22.3k|  StringRef CommentText =
   53|  22.3k|      Lexer::getSourceText(CharSourceRange::getCharRange(Comment),
   54|  22.3k|                           PP.getSourceManager(), PP.getLangOpts());
   55|       |
   56|  22.3k|  CommentMatch Match = matchComment(CommentText);
   57|  22.3k|  if (Match.isValid()) {
  ------------------
  |  Branch (57:7): [True: 22.3k, False: 0]
  ------------------
   58|  22.3k|    CheckComment(Comment.getBegin().getLocWithOffset(Match.Index),
   59|  22.3k|                 CommentText.substr(Match.Index, Match.Size));
   60|  22.3k|  }
   61|       |
   62|  22.3k|  return false;
   63|  22.3k|}
   64|       |
   65|       |void AvoidCommentWithinCommentCheck::InternalCommentHandler::checkURLProtocol(
   66|  7.73k|    SourceLocation CommentLoc, StringRef CommentText, size_t Index) {
   67|  7.73k|  if (CommentText.substr(Index, 3) != "://")
  ------------------
  |  Branch (67:7): [True: 6.81k, False: 924]
  ------------------
   68|  6.81k|    return;
   69|       |
   70|       |  // Find the start of the protocol by scanning backwards
   71|    924|  size_t Start = Index;
   72|  5.36k|  while (Start > 0 && llvm::isAlnum(CommentText[Start - 1]))
  ------------------
  |  Branch (72:10): [True: 5.36k, False: 0]
  |  Branch (72:23): [True: 4.44k, False: 924]
  ------------------
   73|  4.44k|    --Start;
   74|       |
   75|    924|  StringRef Protocol = CommentText.substr(Start, Index - Start);
   76|    924|  if (!Protocols.contains(Protocol)) {
  ------------------
  |  Branch (76:7): [True: 0, False: 924]
  ------------------
   77|      0|    Check.diag(CommentLoc.getLocWithOffset(Index), "unknown protocol '%0'",
   78|      0|               DiagnosticIDs::Note)
   79|      0|        << Protocol;
   80|      0|  }
   81|    924|}
   82|       |
   83|       |void AvoidCommentWithinCommentCheck::InternalCommentHandler::CheckComment(
   84|  22.3k|    SourceLocation CommentLoc, StringRef CommentText) {
   85|       |
   86|  22.3k|  IgnoreLineSpliceRef FilteredText(CommentText);
   87|  22.3k|  State CurrentState = State::Normal;
   88|  22.3k|  size_t Index;
   89|       |
   90|  2.48M|  for (auto It = FilteredText.begin(); It != FilteredText.end(); ++It) {
  ------------------
  |  Branch (90:40): [True: 2.46M, False: 22.3k]
  ------------------
   91|  2.46M|    CurrentState = getNextState(CurrentState, *It);
   92|       |
   93|  2.46M|    switch (CurrentState) {
   94|  1.51k|    case State::CommentSingleLine:
  ------------------
  |  Branch (94:5): [True: 1.51k, False: 2.45M]
  ------------------
   95|  1.51k|      Index = It.prevPosition();
   96|  1.51k|      Check.diag(CommentLoc.getLocWithOffset(Index),
   97|  1.51k|                 "avoid '//' within comment");
   98|  1.51k|      break;
   99|       |
  100|     10|    case State::CommentStart:
  ------------------
  |  Branch (100:5): [True: 10, False: 2.46M]
  ------------------
  101|     10|      Index = It.prevPosition();
  102|     10|      Check.diag(CommentLoc.getLocWithOffset(Index),
  103|     10|                 "avoid '/*' within comment");
  104|     10|      break;
  105|       |
  106|      2|    case State::CommentEnd:
  ------------------
  |  Branch (106:5): [True: 2, False: 2.46M]
  ------------------
  107|      2|      Index = It.prevPosition();
  108|      2|      Check.diag(CommentLoc.getLocWithOffset(Index),
  109|      2|                 "avoid '*/' within comment");
  110|      2|      break;
  111|       |
  112|  7.73k|    case ExpectURLPattern:
  ------------------
  |  Branch (112:5): [True: 7.73k, False: 2.45M]
  ------------------
  113|  7.73k|      Index = It.position();
  114|  7.73k|      checkURLProtocol(CommentLoc, CommentText, Index);
  115|  7.73k|      if (CommentText.substr(Index, 3) == "://")
  ------------------
  |  Branch (115:11): [True: 924, False: 6.81k]
  ------------------
  116|    924|        std::advance(It, 2);
  117|  7.73k|      break;
  118|       |
  119|  2.45M|    default:
  ------------------
  |  Branch (119:5): [True: 2.45M, False: 9.26k]
  ------------------
  120|  2.45M|      break;
  121|  2.46M|    }
  122|  2.46M|  }
  123|  22.3k|}
  124|       |
  125|  2.46M|static constexpr State getNextState(State CurrentState, char Ch) {
  126|  2.46M|  switch (CurrentState) {
  127|  14.6k|  case State::ExpectCommentStart:
  ------------------
  |  Branch (127:3): [True: 14.6k, False: 2.44M]
  ------------------
  128|  14.6k|    return stateExpectCommentStart(Ch);
  129|       |
  130|  21.0k|  case State::ExpectCommentEnd:
  ------------------
  |  Branch (130:3): [True: 21.0k, False: 2.43M]
  ------------------
  131|  21.0k|    return stateExpectCommentEnd(Ch);
  132|       |
  133|  2.42M|  default:
  ------------------
  |  Branch (133:3): [True: 2.42M, False: 35.6k]
  ------------------
  134|  2.42M|    return stateNormal(Ch);
  135|  2.46M|  }
  136|  2.46M|}
  137|       |
  138|  2.42M|static constexpr State stateNormal(char Ch) {
  139|  2.42M|  switch (Ch) {
  140|  15.0k|  case '/':
  ------------------
  |  Branch (140:3): [True: 15.0k, False: 2.40M]
  ------------------
  141|  15.0k|    return State::ExpectCommentStart;
  142|       |
  143|  21.0k|  case '*':
  ------------------
  |  Branch (143:3): [True: 21.0k, False: 2.40M]
  ------------------
  144|  21.0k|    return State::ExpectCommentEnd;
  145|       |
  146|  7.73k|  case ':':
  ------------------
  |  Branch (146:3): [True: 7.73k, False: 2.41M]
  ------------------
  147|  7.73k|    return State::ExpectURLPattern;
  148|       |
  149|  2.38M|  default:
  ------------------
  |  Branch (149:3): [True: 2.38M, False: 43.8k]
  ------------------
  150|  2.38M|    return State::Normal;
  151|  2.42M|  }
  152|  2.42M|}
  153|       |
  154|  14.6k|static constexpr State stateExpectCommentStart(char Ch) {
  155|  14.6k|  switch (Ch) {
  156|  1.51k|  case '/':
  ------------------
  |  Branch (156:3): [True: 1.51k, False: 13.1k]
  ------------------
  157|  1.51k|    return State::CommentSingleLine;
  158|       |
  159|     10|  case '*':
  ------------------
  |  Branch (159:3): [True: 10, False: 14.6k]
  ------------------
  160|     10|    return State::CommentStart;
  161|       |
  162|  13.1k|  default:
  ------------------
  |  Branch (162:3): [True: 13.1k, False: 1.52k]
  ------------------
  163|  13.1k|    return State::Normal;
  164|  14.6k|  }
  165|  14.6k|}
  166|       |
  167|  21.0k|static constexpr State stateExpectCommentEnd(char Ch) {
  168|  21.0k|  switch (Ch) {
  169|      2|  case '/':
  ------------------
  |  Branch (169:3): [True: 2, False: 21.0k]
  ------------------
  170|      2|    return State::CommentEnd;
  171|       |
  172|  21.0k|  default:
  ------------------
  |  Branch (172:3): [True: 21.0k, False: 2]
  ------------------
  173|  21.0k|    return State::Normal;
  174|  21.0k|  }
  175|  21.0k|}
  176|       |
  177|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/comment/AvoidLinesplicingWithinCommentCheck.h:
    1|       |//===--- AvoidLinesplicingWithinCommentCheck.h - clang-tidy -----*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLINESPLICINGWITHINCOMMENTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLINESPLICINGWITHINCOMMENTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "clang/Lex/Preprocessor.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Detects line splicing (backslash-newline) within comments.
   18|       |///
   19|       |/// Line splicing inside comments can cause confusion about comment boundaries
   20|       |/// and may lead to unexpected behavior where code intended to be active gets
   21|       |/// commented out. This is particularly dangerous with // comments where a
   22|       |/// trailing backslash continues the comment to the next line.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 3.2 - Line-splicing shall not be used in
   25|       |/// // comments.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   // This comment has line splicing \
   30|       |///      and continues here  // Warning
   31|       |/// \endcode
   32|       |class AvoidLinesplicingWithinCommentCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  AvoidLinesplicingWithinCommentCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context),
   39|    131|        Handler(*this, Options.get("FixitEnabled", false)) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidLinesplicingWithinCommentCheck() override = default;
   43|       |
   44|       |  /// Registers preprocessor callbacks for comment handling.
   45|       |  /// \param SM The source manager.
   46|       |  /// \param PP The preprocessor instance.
   47|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   48|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   49|       |                           Preprocessor *ModuleExpanderPP) override;
   50|       |
   51|       |private:
   52|       |  class InternalCommentHandler : public CommentHandler {
   53|       |  public:
   54|       |    InternalCommentHandler(ClangTidyCheck &Check, bool FixitEnabled)
   55|    131|        : Check(Check), FixitEnabled(FixitEnabled) {}
   56|    131|    ~InternalCommentHandler() override = default;
   57|       |    bool HandleComment(Preprocessor &PP, SourceRange Comment) override;
   58|       |
   59|       |  private:
   60|       |    ClangTidyCheck &Check;
   61|       |    bool FixitEnabled;
   62|       |  };
   63|       |
   64|       |  InternalCommentHandler Handler;
   65|       |};
   66|       |
   67|       |} // namespace clang::tidy::automotive
   68|       |
   69|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLINESPLICINGWITHINCOMMENTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/comment/AvoidLinesplicingWithinCommentCheck.cpp:
    1|       |//===--- AvoidLinesplicingWithinCommentCheck.cpp - clang-tidy ------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidLinesplicingWithinCommentCheck.h"
   10|       |#include "CommentMatch.h"
   11|       |
   12|       |namespace clang::tidy::automotive {
   13|       |
   14|       |bool AvoidLinesplicingWithinCommentCheck::InternalCommentHandler::HandleComment(
   15|  22.3k|    Preprocessor &PP, SourceRange Comment) {
   16|  22.3k|  StringRef CommentText =
   17|  22.3k|      Lexer::getSourceText(CharSourceRange::getCharRange(Comment),
   18|  22.3k|                           PP.getSourceManager(), PP.getLangOpts());
   19|       |
   20|  22.3k|  CommentMatch Match = matchComment(CommentText);
   21|  22.3k|  bool LineSpliceExist = false;
   22|       |
   23|  22.3k|  if (Match.isSingleLine()) {
  ------------------
  |  Branch (23:7): [True: 10.7k, False: 11.6k]
  ------------------
   24|  10.7k|    SourceLocation StartLoc = Comment.getBegin();
   25|       |
   26|  10.7k|    for (size_t Pos = 0;
   27|  10.7k|         (Pos = CommentText.find("\\\n", Pos)) != StringRef::npos; Pos += 2) {
  ------------------
  |  Branch (27:10): [True: 10, False: 10.7k]
  ------------------
   28|     10|      SourceLocation LineSpliceLoc = StartLoc.getLocWithOffset(Pos);
   29|       |
   30|     10|      if (!FixitEnabled) {
  ------------------
  |  Branch (30:11): [True: 10, False: 0]
  ------------------
   31|     10|        Check.diag(LineSpliceLoc, "avoid line-spliceing within a '//' comment");
   32|     10|      } else {
   33|      0|        Check.diag(LineSpliceLoc, "avoid line-spliceing within a '//' comment")
   34|      0|            << FixItHint::CreateRemoval(SourceRange(
   35|      0|                   LineSpliceLoc, LineSpliceLoc.getLocWithOffset(1)));
   36|      0|      }
   37|     10|      LineSpliceExist = true;
   38|     10|    }
   39|       |
   40|       |    // LCOV_EXCL_START - fix-it code requires special test configuration
   41|  10.7k|    if (FixitEnabled && LineSpliceExist) {
  ------------------
  |  Branch (41:9): [True: 0, False: 10.7k]
  |  Branch (41:25): [True: 0, False: 0]
  ------------------
   42|      0|      SourceLocation EndLoc = Comment.getEnd();
   43|       |
   44|      0|      for (size_t Pos = 0;
   45|      0|           (Pos = CommentText.find("*/", Pos)) != StringRef::npos; Pos += 2) {
  ------------------
  |  Branch (45:12): [True: 0, False: 0]
  ------------------
   46|      0|        SourceLocation EndBlockCommentLoc = StartLoc.getLocWithOffset(Pos);
   47|       |
   48|      0|        Check.diag(EndBlockCommentLoc, "unexpected end of block comment")
   49|      0|            << FixItHint::CreateRemoval(SourceRange(
   50|      0|                   EndBlockCommentLoc, EndBlockCommentLoc.getLocWithOffset(2)));
   51|      0|      }
   52|       |
   53|      0|      Check.diag(StartLoc, "replace single-line comment with block comment")
   54|      0|          << FixItHint::CreateReplacement(
   55|      0|                 SourceRange(StartLoc, StartLoc.getLocWithOffset(Match.Index)),
   56|      0|                 "/*");
   57|      0|      Check.diag(EndLoc, "replace single-line comment with block comment")
   58|      0|          << FixItHint::CreateInsertion(EndLoc, " */");
   59|      0|    }
   60|       |    // LCOV_EXCL_STOP
   61|  10.7k|  }
   62|  22.3k|  return false;
   63|  22.3k|}
   64|       |
   65|       |void AvoidLinesplicingWithinCommentCheck::registerPPCallbacks(
   66|    131|    const SourceManager &SM, Preprocessor *PP, Preprocessor *ModuleExpanderPP) {
   67|       |
   68|    131|  PP->addCommentHandler(&Handler);
   69|    131|}
   70|       |
   71|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidVariableLengthArrayCheck.cpp:
    1|       |//===--- AvoidVariableLengthArrayCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidVariableLengthArrayCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |static SourceLocation getLBrace(const TypeLoc *MatchedTypeLoc);
   17|       |
   18|    131|void AvoidVariableLengthArrayCheck::registerMatchers(MatchFinder *Finder) {
   19|    131|  Finder->addMatcher(typeLoc(loc(variableArrayType())).bind("vlaTypeLoc"),
   20|    131|                     this);
   21|    131|}
   22|       |
   23|       |void AvoidVariableLengthArrayCheck::check(
   24|     10|    const MatchFinder::MatchResult &Result) {
   25|     10|  const auto *MatchedTypeLoc = Result.Nodes.getNodeAs<TypeLoc>("vlaTypeLoc");
   26|       |
   27|     10|  if (!MatchedTypeLoc) {
  ------------------
  |  Branch (27:7): [True: 0, False: 10]
  ------------------
   28|      0|    return;
   29|      0|  }
   30|       |
   31|     10|  diag(getLBrace(MatchedTypeLoc), "avoid variable-length array");
   32|     10|}
   33|       |
   34|     10|static SourceLocation getLBrace(const TypeLoc *MatchedTypeLoc) {
   35|     10|  SourceLocation LBracketLoc =
   36|     10|      MatchedTypeLoc->getAs<VariableArrayTypeLoc>().getLBracketLoc();
   37|       |
   38|     10|  if (LBracketLoc.isValid()) {
  ------------------
  |  Branch (38:7): [True: 10, False: 0]
  ------------------
   39|     10|    return LBracketLoc;
   40|     10|  } else {
   41|      0|    return MatchedTypeLoc->getBeginLoc();
   42|      0|  }
   43|     10|}
   44|       |
   45|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidVariableLengthArrayCheck.h:
    1|       |//===--- AvoidVariableLengthArrayCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDVARIABLELENGTHARRAYCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDVARIABLELENGTHARRAYCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of variable length arrays (VLAs).
   17|       |///
   18|       |/// Variable length arrays have runtime-determined size, which can lead to
   19|       |/// stack overflow if the size is large or unbounded. VLAs also make static
   20|       |/// analysis more difficult and are optional in C11. This check flags all
   21|       |/// VLA declarations.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 18.8 - Variable-length array types shall not
   24|       |/// be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   void func(int n) {
   29|       |///     int arr[n];  // Warning: variable length array detected
   30|       |///   }
   31|       |/// \endcode
   32|       |class AvoidVariableLengthArrayCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  AvoidVariableLengthArrayCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidVariableLengthArrayCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for variable length array declarations.
   44|       |  /// \param Finder The match finder to register matchers with.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched VLA declarations and emits diagnostics.
   48|       |  /// \param Result The match result containing the matched AST node.
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDVARIABLELENGTHARRAYCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidFlexibleArrayMemberCheck.h:
    1|       |//===--- AvoidFlexibleArrayMemberCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFLEXIBLEARRAYMEMBERCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFLEXIBLEARRAYMEMBERCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-arrays
   17|       |/// @brief Detects flexible array members in structures.
   18|       |///
   19|       |/// Flexible array members (arrays with unspecified size at the end of a struct)
   20|       |/// require special handling for memory allocation and can lead to buffer
   21|       |/// overflows if not managed correctly. They make code less portable and
   22|       |/// harder to analyze statically.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 18.7
   25|       |/// Flexible array members shall not be declared.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   struct Message {
   31|       |///     int length;
   32|       |///     char data[];  // Warning: flexible array member
   33|       |///   };
   34|       |/// @endcode
   35|       |class AvoidFlexibleArrayMemberCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidFlexibleArrayMemberCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~AvoidFlexibleArrayMemberCheck() override = default;
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   44|       |};
   45|       |
   46|       |} // namespace clang::tidy::automotive
   47|       |
   48|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFLEXIBLEARRAYMEMBERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPartialArrayInitCheck.h:
    1|       |//===--- AvoidPartialArrayInitCheck.h - clang-tidy --------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPARTIALARRAYINITCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPARTIALARRAYINITCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-arrays
   17|       |/// @brief Detects partially initialized arrays.
   18|       |///
   19|       |/// Partial array initialization (where only some elements are explicitly
   20|       |/// initialized) can be error-prone. It may be unclear which elements are
   21|       |/// initialized and to what values. Either initialize all elements explicitly
   22|       |/// or use {0} to zero-initialize the entire array.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 9.3
   25|       |/// Arrays shall not be partially initialized.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   int arr[5] = {1, 2};  // Warning: partial initialization
   31|       |///   int ok[5] = {1, 2, 3, 4, 5};  // OK: fully initialized
   32|       |///   int zeros[5] = {0};   // OK: explicit zero-init
   33|       |/// @endcode
   34|       |class AvoidPartialArrayInitCheck : public ClangTidyCheck {
   35|       |public:
   36|       |  AvoidPartialArrayInitCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidPartialArrayInitCheck() override = default;
   41|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   42|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   43|       |};
   44|       |
   45|       |} // namespace clang::tidy::automotive
   46|       |
   47|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPARTIALARRAYINITCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidFlexibleArrayMemberCheck.cpp:
    1|       |//===--- AvoidFlexibleArrayMemberCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidFlexibleArrayMemberCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void AvoidFlexibleArrayMemberCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(
   18|    131|      fieldDecl(hasType(incompleteArrayType())).bind("flexArray"), this);
   19|    131|}
   20|       |
   21|       |void AvoidFlexibleArrayMemberCheck::check(
   22|      2|    const MatchFinder::MatchResult &Result) {
   23|      2|  const auto *MatchedDecl = Result.Nodes.getNodeAs<FieldDecl>("flexArray");
   24|       |
   25|      2|  if (MatchedDecl) {
  ------------------
  |  Branch (25:7): [True: 2, False: 0]
  ------------------
   26|      2|    diag(MatchedDecl->getLocation(), "avoid flexible array members");
   27|      2|  }
   28|      2|}
   29|       |
   30|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/ArrayComponent.cpp:
    1|       |//===--- ArrayComponent.cpp - clang-tidy ----------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ArrayComponent.h"
   10|       |#include "AvoidDesignatedInitializerBoundsCheck.h"
   11|       |#include "AvoidFlexibleArrayMemberCheck.h"
   12|       |#include "AvoidIncompleteInitializationCheck.h"
   13|       |#include "AvoidPartialArrayInitCheck.h"
   14|       |#include "AvoidPointerArithmeticBoundsCheck.h"
   15|       |#include "AvoidPointerArithmeticCheck.h"
   16|       |#include "AvoidVariableLengthArrayCheck.h"
   17|       |#include "MissingExternalArraySizeCheck.h"
   18|       |
   19|       |namespace clang::tidy::automotive {
   20|       |
   21|       |void ArrayComponent::addCheckFactories(
   22|    262|    ClangTidyCheckFactories &CheckFactories) {
   23|       |
   24|    262|  CheckFactories.registerCheck<AvoidPartialArrayInitCheck>(
   25|    262|      "automotive-avoid-partial-array-init");
   26|    262|  CheckFactories.registerCheck<AvoidFlexibleArrayMemberCheck>(
   27|    262|      "automotive-avoid-flexible-array-member");
   28|    262|  CheckFactories.registerCheck<AvoidVariableLengthArrayCheck>(
   29|    262|      "automotive-avoid-variable-length-array");
   30|    262|  CheckFactories.registerCheck<MissingExternalArraySizeCheck>(
   31|    262|      "automotive-missing-external-array-size");
   32|       |
   33|       |  // Rules 18.1, 18.2, 18.3, 18.5 - Pointer arithmetic bounds (Required)
   34|    262|  CheckFactories.registerCheck<AvoidPointerArithmeticBoundsCheck>(
   35|    262|      "automotive-c23-req-18.1");
   36|       |
   37|       |  // Rule 18.4 - Pointer arithmetic (Advisory)
   38|    262|  CheckFactories.registerCheck<AvoidPointerArithmeticCheck>(
   39|    262|      "automotive-c23-adv-18.4");
   40|       |
   41|       |  // Rule 9.4 - Incomplete aggregate initialization (Required)
   42|    262|  CheckFactories.registerCheck<AvoidIncompleteInitializationCheck>(
   43|    262|      "automotive-c23-req-9.4");
   44|       |
   45|       |  // Rule 9.5 - Designated initializer bounds (Required)
   46|    262|  CheckFactories.registerCheck<AvoidDesignatedInitializerBoundsCheck>(
   47|    262|      "automotive-c23-req-9.5");
   48|    262|}
   49|       |
   50|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/MissingExternalArraySizeCheck.h:
    1|       |//===--- MissingExternalArraySizeCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGEXTERNALARRAYSIZECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGEXTERNALARRAYSIZECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-arrays
   17|       |/// @brief Detects extern array declarations without explicit size.
   18|       |///
   19|       |/// Extern array declarations without an explicit size make it impossible
   20|       |/// to perform bounds checking at compile time. The size should be specified
   21|       |/// to enable static analysis and prevent buffer overflows.
   22|       |///
   23|       |/// @par MISRA C:2025 Rule 8.11
   24|       |/// When an array with external linkage is declared, its size should be
   25|       |/// explicitly specified.
   26|       |/// @par Category: Advisory
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   extern int arr[];    // Warning: no size specified
   31|       |///   extern int arr[10];  // OK: size specified
   32|       |/// @endcode
   33|       |class MissingExternalArraySizeCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  MissingExternalArraySizeCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~MissingExternalArraySizeCheck() override = default;
   40|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   41|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   42|       |};
   43|       |
   44|       |} // namespace clang::tidy::automotive
   45|       |
   46|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_MISSINGEXTERNALARRAYSIZECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidIncompleteInitializationCheck.h:
    1|       |//===--- AvoidIncompleteInitializationCheck.h - clang-tidy ------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPLETEINITIALIZATIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPLETEINITIALIZATIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects incomplete aggregate initialization.
   17|       |///
   18|       |/// MISRA C:2025 Rule 9.4 requires that if any element of an aggregate
   19|       |/// (array or struct) is initialized, then all elements shall be explicitly
   20|       |/// initialized. This prevents accidental reliance on implicit zero
   21|       |/// initialization.
   22|       |///
   23|       |/// Example of non-compliant code:
   24|       |/// \code
   25|       |///   struct Point { int x; int y; int z; };
   26|       |///   struct Point p = { .x = 1, .y = 2 }; // z not initialized
   27|       |///   int arr[5] = { 1, 2 }; // Elements 2-4 not initialized
   28|       |/// \endcode
   29|       |///
   30|       |/// Example of compliant code:
   31|       |/// \code
   32|       |///   struct Point p = { .x = 1, .y = 2, .z = 0 };
   33|       |///   int arr[5] = { 1, 2, 0, 0, 0 };
   34|       |/// \endcode
   35|       |class AvoidIncompleteInitializationCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  /// Constructs the check with the given name and context.
   38|       |  AvoidIncompleteInitializationCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidIncompleteInitializationCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for aggregate initializations.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched initializers and emits diagnostics.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |
   50|       |private:
   51|       |  /// Gets the number of fields in a record type.
   52|       |  unsigned getRecordFieldCount(const RecordType *RT) const;
   53|       |};
   54|       |
   55|       |} // namespace clang::tidy::automotive
   56|       |
   57|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDINCOMPLETEINITIALIZATIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidIncompleteInitializationCheck.cpp:
    1|       |//===--- AvoidIncompleteInitializationCheck.cpp - clang-tidy --------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidIncompleteInitializationCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |namespace {
   18|       |/// Returns true if the initializer list is a single {0} (zero-initialization).
   19|       |/// Uses the syntactic form to check what the user actually wrote.
   20|     40|bool isZeroInitializer(const InitListExpr *Init, ASTContext &Context) {
   21|       |  // Get the syntactic form (what the user wrote)
   22|     40|  const InitListExpr *SyntacticForm =
   23|     40|      Init->isSyntacticForm() ? Init : Init->getSyntacticForm();
  ------------------
  |  Branch (23:7): [True: 0, False: 40]
  ------------------
   24|     40|  if (!SyntacticForm)
  ------------------
  |  Branch (24:7): [True: 0, False: 40]
  ------------------
   25|      0|    SyntacticForm = Init;
   26|       |
   27|     40|  if (SyntacticForm->getNumInits() != 1)
  ------------------
  |  Branch (27:7): [True: 23, False: 17]
  ------------------
   28|     23|    return false;
   29|     17|  const auto *FirstInit = SyntacticForm->getInit(0);
   30|     17|  if (!FirstInit)
  ------------------
  |  Branch (30:7): [True: 0, False: 17]
  ------------------
   31|      0|    return false;
   32|     17|  auto Value = FirstInit->getIntegerConstantExpr(Context);
   33|     17|  return Value && *Value == 0;
  ------------------
  |  Branch (33:10): [True: 12, False: 5]
  |  Branch (33:19): [True: 7, False: 5]
  ------------------
   34|     17|}
   35|       |
   36|       |/// Counts explicit initializers (excludes ImplicitValueInitExpr).
   37|     95|unsigned countExplicitInits(const InitListExpr *Init) {
   38|     95|  unsigned Count = 0;
   39|    364|  for (unsigned I = 0; I < Init->getNumInits(); ++I) {
  ------------------
  |  Branch (39:24): [True: 269, False: 95]
  ------------------
   40|    269|    if (!isa<ImplicitValueInitExpr>(Init->getInit(I)))
  ------------------
  |  Branch (40:9): [True: 233, False: 36]
  ------------------
   41|    233|      ++Count;
   42|    269|  }
   43|     95|  return Count;
   44|     95|}
   45|       |} // namespace
   46|       |
   47|    131|void AvoidIncompleteInitializationCheck::registerMatchers(MatchFinder *Finder) {
   48|       |  // Match variable declarations with initializer lists
   49|    131|  Finder->addMatcher(
   50|    131|      varDecl(hasInitializer(initListExpr().bind("init"))).bind("var"), this);
   51|    131|}
   52|       |
   53|       |void AvoidIncompleteInitializationCheck::check(
   54|    103|    const MatchFinder::MatchResult &Result) {
   55|    103|  const auto *VD = Result.Nodes.getNodeAs<VarDecl>("var");
   56|    103|  const auto *Init = Result.Nodes.getNodeAs<InitListExpr>("init");
   57|    103|  if (!VD || !Init)
  ------------------
  |  Branch (57:7): [True: 0, False: 103]
  |  Branch (57:14): [True: 0, False: 103]
  ------------------
   58|      0|    return;
   59|       |
   60|       |  // Skip system headers
   61|    103|  if (Result.SourceManager->isInSystemHeader(VD->getLocation()))
  ------------------
  |  Branch (61:7): [True: 8, False: 95]
  ------------------
   62|      8|    return;
   63|       |
   64|       |  // Get the semantic form of the initializer list
   65|     95|  const InitListExpr *SemaInit =
   66|     95|      Init->isSemanticForm() ? Init : Init->getSemanticForm();
  ------------------
  |  Branch (66:7): [True: 95, False: 0]
  ------------------
   67|     95|  if (!SemaInit)
  ------------------
  |  Branch (67:7): [True: 0, False: 95]
  ------------------
   68|      0|    SemaInit = Init;
   69|       |
   70|     95|  QualType VarType = VD->getType().getCanonicalType();
   71|       |
   72|       |  // Count only explicit initializers (semantic form may include implicit ones)
   73|     95|  unsigned NumExplicitInits = countExplicitInits(SemaInit);
   74|       |
   75|       |  // Check array types
   76|     95|  if (const auto *AT = dyn_cast<ConstantArrayType>(VarType.getTypePtr())) {
  ------------------
  |  Branch (76:19): [True: 74, False: 21]
  ------------------
   77|     74|    uint64_t ArraySize = AT->getSize().getZExtValue();
   78|       |
   79|       |    // If some but not all elements are initialized, warn
   80|       |    // Allow {0} as a special case for zero-initialization
   81|     74|    if (NumExplicitInits > 0 && NumExplicitInits < ArraySize &&
  ------------------
  |  Branch (81:9): [True: 71, False: 3]
  |  Branch (81:33): [True: 33, False: 38]
  ------------------
   82|     74|        !isZeroInitializer(SemaInit, *Result.Context)) {
  ------------------
  |  Branch (82:9): [True: 27, False: 6]
  ------------------
   83|     27|      diag(Init->getBeginLoc(),
   84|     27|           "array has %0 elements but only %1 initializers provided; all "
   85|     27|           "elements should be explicitly initialized")
   86|     27|          << static_cast<unsigned>(ArraySize) << NumExplicitInits;
   87|     27|    }
   88|     74|    return;
   89|     74|  }
   90|       |
   91|       |  // Check struct/union types
   92|     21|  if (const auto *RT = VarType->getAs<RecordType>()) {
  ------------------
  |  Branch (92:19): [True: 21, False: 0]
  ------------------
   93|     21|    const RecordDecl *RD = RT->getDecl();
   94|     21|    if (!RD->isCompleteDefinition())
  ------------------
  |  Branch (94:9): [True: 0, False: 21]
  ------------------
   95|      0|      return;
   96|       |
   97|     21|    unsigned FieldCount = getRecordFieldCount(RT);
   98|       |
   99|       |    // If some but not all fields are initialized, warn
  100|       |    // Allow {0} as special case for zero-initialization
  101|     21|    if (NumExplicitInits > 0 && NumExplicitInits < FieldCount &&
  ------------------
  |  Branch (101:9): [True: 20, False: 1]
  |  Branch (101:33): [True: 7, False: 13]
  ------------------
  102|     21|        !isZeroInitializer(SemaInit, *Result.Context)) {
  ------------------
  |  Branch (102:9): [True: 6, False: 1]
  ------------------
  103|      6|      diag(Init->getBeginLoc(),
  104|      6|           "aggregate has %0 members but only %1 initializers provided; all "
  105|      6|           "members should be explicitly initialized")
  106|      6|          << FieldCount << NumExplicitInits;
  107|      6|    }
  108|     21|  }
  109|     21|}
  110|       |
  111|       |unsigned AvoidIncompleteInitializationCheck::getRecordFieldCount(
  112|     21|    const RecordType *RT) const {
  113|     21|  unsigned Count = 0;
  114|     21|  const RecordDecl *RD = RT->getDecl();
  115|     50|  for (const auto *Field : RD->fields()) {
  ------------------
  |  Branch (115:26): [True: 50, False: 21]
  ------------------
  116|     50|    (void)Field;
  117|     50|    ++Count;
  118|     50|  }
  119|     21|  return Count;
  120|     21|}
  121|       |
  122|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPointerArithmeticBoundsCheck.h:
    1|       |//===--- AvoidPointerArithmeticBoundsCheck.h - clang-tidy -------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICBOUNDSCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICBOUNDSCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-array
   17|       |/// @brief Detects potentially out-of-bounds pointer arithmetic.
   18|       |///
   19|       |/// Implements MISRA Rules 18.1, 18.2, 18.3, 18.5, 18.6:
   20|       |/// - 18.1: Pointer arithmetic shall result in pointer to same array
   21|       |/// - 18.2: Subtraction between pointers shall address same array
   22|       |/// - 18.3: Relational operators shall not be applied to pointer types
   23|       |///   except to address same array
   24|       |/// - 18.5: Declaration shall contain no more than two levels of pointer
   25|       |/// - 18.6: Address of auto object shall not persist after scope
   26|       |///
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   int a[10], b[10];
   32|       |///   int *p = a + 20;       // Warning: may exceed bounds
   33|       |///   int diff = p - b;      // Warning: different arrays
   34|       |///   int ***ppp;            // Warning: more than 2 levels
   35|       |/// @endcode
   36|       |class AvoidPointerArithmeticBoundsCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidPointerArithmeticBoundsCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidPointerArithmeticBoundsCheck() override = default;
   43|       |
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |
   47|       |private:
   48|       |  unsigned getPointerNestingLevel(QualType Type) const;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICBOUNDSCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidDesignatedInitializerBoundsCheck.cpp:
    1|       |//===--- AvoidDesignatedInitializerBoundsCheck.cpp - clang-tidy -----------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidDesignatedInitializerBoundsCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void AvoidDesignatedInitializerBoundsCheck::registerMatchers(
   18|    131|    MatchFinder *Finder) {
   19|       |  // Match designated initializer expressions
   20|    131|  Finder->addMatcher(designatedInitExpr().bind("designated"), this);
   21|    131|}
   22|       |
   23|       |void AvoidDesignatedInitializerBoundsCheck::checkArrayDesignator(
   24|       |    const DesignatedInitExpr::Designator &D, const DesignatedInitExpr *DIE,
   25|     22|    const MatchFinder::MatchResult &Result) {
   26|     22|  const Expr *IndexExpr = DIE->getArrayIndex(D);
   27|     22|  if (!IndexExpr)
  ------------------
  |  Branch (27:7): [True: 0, False: 22]
  ------------------
   28|      0|    return;
   29|       |
   30|     22|  auto IndexValue = IndexExpr->getIntegerConstantExpr(*Result.Context);
   31|     22|  if (!IndexValue)
  ------------------
  |  Branch (31:7): [True: 0, False: 22]
  ------------------
   32|      0|    return;
   33|       |
   34|     22|  int64_t Index = IndexValue->getSExtValue();
   35|     22|  if (Index < 0) {
  ------------------
  |  Branch (35:7): [True: 0, False: 22]
  ------------------
   36|      0|    diag(D.getLBracketLoc(),
   37|      0|         "designated initializer has negative array index %0")
   38|      0|        << static_cast<int>(Index);
   39|      0|  }
   40|     22|}
   41|       |
   42|       |void AvoidDesignatedInitializerBoundsCheck::checkArrayRangeDesignator(
   43|       |    const DesignatedInitExpr::Designator &D, const DesignatedInitExpr *DIE,
   44|      2|    const MatchFinder::MatchResult &Result) {
   45|      2|  const Expr *StartExpr = DIE->getArrayRangeStart(D);
   46|      2|  const Expr *EndExpr = DIE->getArrayRangeEnd(D);
   47|      2|  if (!StartExpr || !EndExpr)
  ------------------
  |  Branch (47:7): [True: 0, False: 2]
  |  Branch (47:21): [True: 0, False: 2]
  ------------------
   48|      0|    return;
   49|       |
   50|      2|  auto StartValue = StartExpr->getIntegerConstantExpr(*Result.Context);
   51|      2|  auto EndValue = EndExpr->getIntegerConstantExpr(*Result.Context);
   52|      2|  if (!StartValue || !EndValue)
  ------------------
  |  Branch (52:7): [True: 0, False: 2]
  |  Branch (52:22): [True: 0, False: 2]
  ------------------
   53|      0|    return;
   54|       |
   55|      2|  int64_t Start = StartValue->getSExtValue();
   56|      2|  int64_t End = EndValue->getSExtValue();
   57|       |
   58|      2|  if (Start < 0 || End < 0) {
  ------------------
  |  Branch (58:7): [True: 0, False: 2]
  |  Branch (58:20): [True: 0, False: 2]
  ------------------
   59|      0|    diag(D.getLBracketLoc(),
   60|      0|         "designated initializer array range has negative index");
   61|      0|    return;
   62|      0|  }
   63|       |
   64|      2|  if (Start > End) {
  ------------------
  |  Branch (64:7): [True: 0, False: 2]
  ------------------
   65|      0|    diag(D.getLBracketLoc(),
   66|      0|         "designated initializer array range has start index %0 "
   67|      0|         "greater than end index %1")
   68|      0|        << static_cast<int>(Start) << static_cast<int>(End);
   69|      0|  }
   70|      2|}
   71|       |
   72|       |void AvoidDesignatedInitializerBoundsCheck::check(
   73|     45|    const MatchFinder::MatchResult &Result) {
   74|     45|  const auto *DIE = Result.Nodes.getNodeAs<DesignatedInitExpr>("designated");
   75|     45|  if (!DIE)
  ------------------
  |  Branch (75:7): [True: 0, False: 45]
  ------------------
   76|      0|    return;
   77|       |
   78|     45|  if (Result.SourceManager->isInSystemHeader(DIE->getBeginLoc()))
  ------------------
  |  Branch (78:7): [True: 0, False: 45]
  ------------------
   79|      0|    return;
   80|       |
   81|     49|  for (const auto &D : DIE->designators()) {
  ------------------
  |  Branch (81:22): [True: 49, False: 45]
  ------------------
   82|     49|    if (D.isArrayDesignator())
  ------------------
  |  Branch (82:9): [True: 22, False: 27]
  ------------------
   83|     22|      checkArrayDesignator(D, DIE, Result);
   84|     27|    else if (D.isArrayRangeDesignator())
  ------------------
  |  Branch (84:14): [True: 2, False: 25]
  ------------------
   85|      2|      checkArrayRangeDesignator(D, DIE, Result);
   86|     49|  }
   87|     45|}
   88|       |
   89|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPointerArithmeticCheck.h:
    1|       |//===--- AvoidPointerArithmeticCheck.h - clang-tidy -------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-array
   17|       |/// @brief Detects arithmetic operations on pointer types.
   18|       |///
   19|       |/// The +, -, += and -= operators should not be applied to an expression of
   20|       |/// pointer type. Pointer arithmetic is error-prone and can easily lead to
   21|       |/// out-of-bounds access. Array indexing (ptr[i]) is preferred as it's more
   22|       |/// readable and intention is clearer.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 18.4
   25|       |/// The +, -, += and -= operators should not be applied to an expression of
   26|       |/// pointer type.
   27|       |/// @par Category: Advisory
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   int arr[10];
   32|       |///   int *p = arr;
   33|       |///
   34|       |///   p++;            // Warning: pointer arithmetic
   35|       |///   p += 2;         // Warning: pointer arithmetic
   36|       |///   int *q = p + 3; // Warning: pointer arithmetic
   37|       |///   p--;            // Warning: pointer arithmetic
   38|       |///
   39|       |///   // Preferred: use array indexing
   40|       |///   int x = arr[5]; // Compliant
   41|       |/// @endcode
   42|       |class AvoidPointerArithmeticCheck : public ClangTidyCheck {
   43|       |public:
   44|       |  AvoidPointerArithmeticCheck(StringRef Name, ClangTidyContext *Context)
   45|    131|      : ClangTidyCheck(Name, Context) {}
   46|       |
   47|       |  /// Destructor.
   48|    131|  ~AvoidPointerArithmeticCheck() override = default;
   49|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDPOINTERARITHMETICCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPartialArrayInitCheck.cpp:
    1|       |//===--- AvoidPartialArrayInitCheck.cpp - clang-tidy ----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidPartialArrayInitCheck.h"
   10|       |#include "../utils/ASTMatchers.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidPartialArrayInitCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      varDecl(
   20|    131|          hasType(arrayType()),
   21|    131|          hasInitializer(initListExpr(unless(automotive::isZeroInitializer()),
   22|    131|                                      unless(automotive::isStringLiteralInit()))
   23|    131|                             .bind("init")))
   24|    131|          .bind("arrayVar"),
   25|    131|      this);
   26|    131|}
   27|       |
   28|     69|void AvoidPartialArrayInitCheck::check(const MatchFinder::MatchResult &Result) {
   29|     69|  const auto *Var = Result.Nodes.getNodeAs<VarDecl>("arrayVar");
   30|     69|  const auto *Init = Result.Nodes.getNodeAs<InitListExpr>("init");
   31|       |
   32|     69|  if (!Var || !Init) {
  ------------------
  |  Branch (32:7): [True: 0, False: 69]
  |  Branch (32:15): [True: 0, False: 69]
  ------------------
   33|      0|    return;
   34|      0|  }
   35|       |
   36|     69|  const auto *ArrayTy = Result.Context->getAsConstantArrayType(Var->getType());
   37|     69|  if (!ArrayTy) {
  ------------------
  |  Branch (37:7): [True: 2, False: 67]
  ------------------
   38|      2|    return;
   39|      2|  }
   40|       |
   41|     67|  uint64_t ArraySize = ArrayTy->getSize().getZExtValue();
   42|     67|  unsigned InitCount = Init->getNumInits();
   43|       |
   44|     67|  if (InitCount < ArraySize) {
  ------------------
  |  Branch (44:7): [True: 28, False: 39]
  ------------------
   45|     28|    diag(Var->getLocation(), "avoid partially initialized array");
   46|     28|  }
   47|     67|}
   48|       |
   49|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPointerArithmeticCheck.cpp:
    1|       |//===--- AvoidPointerArithmeticCheck.cpp - clang-tidy ---------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidPointerArithmeticCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidPointerArithmeticCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match binary + and - with pointer operand
   19|    131|  Finder->addMatcher(binaryOperator(hasAnyOperatorName("+", "-", "+=", "-="),
   20|    131|                                    hasEitherOperand(hasType(pointerType())))
   21|    131|                         .bind("binop"),
   22|    131|                     this);
   23|       |
   24|       |  // Match unary ++ and -- on pointers
   25|    131|  Finder->addMatcher(unaryOperator(hasAnyOperatorName("++", "--"),
   26|    131|                                   hasUnaryOperand(hasType(pointerType())))
   27|    131|                         .bind("unaryop"),
   28|    131|                     this);
   29|    131|}
   30|       |
   31|       |void AvoidPointerArithmeticCheck::check(
   32|    102|    const MatchFinder::MatchResult &Result) {
   33|       |  // Skip if in system header
   34|    102|  SourceLocation Loc;
   35|    102|  StringRef OpStr;
   36|       |
   37|    102|  if (const auto *BinOp = Result.Nodes.getNodeAs<BinaryOperator>("binop")) {
  ------------------
  |  Branch (37:19): [True: 84, False: 18]
  ------------------
   38|     84|    Loc = BinOp->getOperatorLoc();
   39|     84|    OpStr = BinOp->getOpcodeStr();
   40|       |
   41|       |    // Skip pointer subtraction that results in ptrdiff_t (pointer - pointer)
   42|       |    // This is actually allowed - we only want to catch pointer +/- integer
   43|     84|    if (BinOp->getOpcode() == BO_Sub &&
  ------------------
  |  Branch (43:9): [True: 50, False: 34]
  |  Branch (43:9): [True: 47, False: 37]
  ------------------
   44|     84|        BinOp->getLHS()->getType()->isPointerType() &&
  ------------------
  |  Branch (44:9): [True: 50, False: 0]
  ------------------
   45|     84|        BinOp->getRHS()->getType()->isPointerType()) {
  ------------------
  |  Branch (45:9): [True: 47, False: 3]
  ------------------
   46|     47|      return;
   47|     47|    }
   48|     84|  } else if (const auto *UnOp =
  ------------------
  |  Branch (48:26): [True: 18, False: 0]
  ------------------
   49|     18|                 Result.Nodes.getNodeAs<UnaryOperator>("unaryop")) {
   50|     18|    Loc = UnOp->getOperatorLoc();
   51|     18|    OpStr = UnaryOperator::getOpcodeStr(UnOp->getOpcode());
   52|     18|  } else {
   53|      0|    return;
   54|      0|  }
   55|       |
   56|     55|  if (Loc.isInvalid() || Result.SourceManager->isInSystemHeader(Loc))
  ------------------
  |  Branch (56:7): [True: 0, False: 55]
  |  Branch (56:26): [True: 32, False: 23]
  ------------------
   57|     32|    return;
   58|       |
   59|     23|  diag(Loc, "pointer arithmetic using '%0' is error-prone; "
   60|     23|            "consider using array indexing instead")
   61|     23|      << OpStr;
   62|     23|}
   63|       |
   64|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidDesignatedInitializerBoundsCheck.h:
    1|       |//===--- AvoidDesignatedInitializerBoundsCheck.h - clang-tidy ---*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDDESIGNATEDINITIALIZERBOUNDSCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDDESIGNATEDINITIALIZERBOUNDSCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects designated initializers with out-of-bounds array indices.
   17|       |///
   18|       |/// MISRA C:2025 Rule 9.5 requires that designated initializers shall not
   19|       |/// specify array indices that exceed the declared array bounds or reference
   20|       |/// non-existent struct members.
   21|       |///
   22|       |/// Example of non-compliant code:
   23|       |/// \code
   24|       |///   int arr[3] = { [5] = 10 };  // Index 5 exceeds array bounds
   25|       |/// \endcode
   26|       |///
   27|       |/// Example of compliant code:
   28|       |/// \code
   29|       |///   int arr[3] = { [2] = 10 };  // Valid index within bounds
   30|       |/// \endcode
   31|       |class AvoidDesignatedInitializerBoundsCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  AvoidDesignatedInitializerBoundsCheck(StringRef Name,
   35|       |                                        ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidDesignatedInitializerBoundsCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for designated initializers.
   42|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   43|       |
   44|       |  /// Handles matched initializers and emits diagnostics.
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |
   47|       |private:
   48|       |  /// Check a single array designator for bounds issues.
   49|       |  void
   50|       |  checkArrayDesignator(const DesignatedInitExpr::Designator &D,
   51|       |                       const DesignatedInitExpr *DIE,
   52|       |                       const ast_matchers::MatchFinder::MatchResult &Result);
   53|       |
   54|       |  /// Check a GNU array range designator for bounds issues.
   55|       |  void checkArrayRangeDesignator(
   56|       |      const DesignatedInitExpr::Designator &D, const DesignatedInitExpr *DIE,
   57|       |      const ast_matchers::MatchFinder::MatchResult &Result);
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDDESIGNATEDINITIALIZERBOUNDSCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/array/MissingExternalArraySizeCheck.cpp:
    1|       |//===--- MissingExternalArraySizeCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "MissingExternalArraySizeCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void MissingExternalArraySizeCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(varDecl(hasType(arrayType()), hasExternalFormalLinkage(),
   18|    131|                             hasType(incompleteArrayType()))
   19|    131|                         .bind("array"),
   20|    131|                     this);
   21|    131|}
   22|       |
   23|       |void MissingExternalArraySizeCheck::check(
   24|      3|    const MatchFinder::MatchResult &Result) {
   25|      3|  const auto *MatchedDecl = Result.Nodes.getNodeAs<VarDecl>("array");
   26|       |
   27|      3|  if (MatchedDecl) {
  ------------------
  |  Branch (27:7): [True: 3, False: 0]
  ------------------
   28|      3|    diag(MatchedDecl->getLocation(),
   29|      3|         "missing explicit size of external array '%0'")
   30|      3|        << MatchedDecl->getName();
   31|      3|  }
   32|      3|}
   33|       |
   34|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/array/AvoidPointerArithmeticBoundsCheck.cpp:
    1|       |//===--- AvoidPointerArithmeticBoundsCheck.cpp - clang-tidy ---------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidPointerArithmeticBoundsCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidPointerArithmeticBoundsCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Rule 18.3: Relational operators on pointers
   19|    131|  Finder->addMatcher(binaryOperator(hasAnyOperatorName("<", ">", "<=", ">="),
   20|    131|                                    hasLHS(hasType(pointerType())),
   21|    131|                                    hasRHS(hasType(pointerType())))
   22|    131|                         .bind("relop"),
   23|    131|                     this);
   24|       |
   25|       |  // Rule 18.2: Pointer subtraction
   26|    131|  Finder->addMatcher(binaryOperator(hasOperatorName("-"),
   27|    131|                                    hasLHS(hasType(pointerType())),
   28|    131|                                    hasRHS(hasType(pointerType())))
   29|    131|                         .bind("ptrsub"),
   30|    131|                     this);
   31|       |
   32|       |  // Rule 18.5: Declaration with more than 2 levels of pointer
   33|    131|  Finder->addMatcher(varDecl().bind("vardecl"), this);
   34|    131|}
   35|       |
   36|       |void AvoidPointerArithmeticBoundsCheck::check(
   37|  18.4k|    const MatchFinder::MatchResult &Result) {
   38|       |  // Rule 18.3: Relational operators on pointers
   39|  18.4k|  if (const auto *RelOp = Result.Nodes.getNodeAs<BinaryOperator>("relop")) {
  ------------------
  |  Branch (39:19): [True: 11, False: 18.4k]
  ------------------
   40|     11|    if (Result.SourceManager->isInSystemHeader(RelOp->getOperatorLoc()))
  ------------------
  |  Branch (40:9): [True: 10, False: 1]
  ------------------
   41|     10|      return;
   42|       |
   43|      1|    diag(RelOp->getOperatorLoc(),
   44|      1|         "relational operator applied to pointers; ensure they address "
   45|      1|         "elements of the same array");
   46|      1|    return;
   47|     11|  }
   48|       |
   49|       |  // Rule 18.2: Pointer subtraction
   50|  18.4k|  if (const auto *PtrSub = Result.Nodes.getNodeAs<BinaryOperator>("ptrsub")) {
  ------------------
  |  Branch (50:19): [True: 47, False: 18.4k]
  ------------------
   51|     47|    if (Result.SourceManager->isInSystemHeader(PtrSub->getOperatorLoc()))
  ------------------
  |  Branch (51:9): [True: 44, False: 3]
  ------------------
   52|     44|      return;
   53|       |
   54|      3|    diag(PtrSub->getOperatorLoc(),
   55|      3|         "pointer subtraction; ensure both pointers address elements of "
   56|      3|         "the same array object");
   57|      3|    return;
   58|     47|  }
   59|       |
   60|       |  // Rule 18.5: More than 2 levels of pointer nesting
   61|  18.4k|  if (const auto *VD = Result.Nodes.getNodeAs<VarDecl>("vardecl")) {
  ------------------
  |  Branch (61:19): [True: 18.4k, False: 0]
  ------------------
   62|  18.4k|    if (Result.SourceManager->isInSystemHeader(VD->getLocation()))
  ------------------
  |  Branch (62:9): [True: 16.1k, False: 2.28k]
  ------------------
   63|  16.1k|      return;
   64|       |
   65|  2.28k|    unsigned NestingLevel = getPointerNestingLevel(VD->getType());
   66|  2.28k|    if (NestingLevel > 2) {
  ------------------
  |  Branch (66:9): [True: 0, False: 2.28k]
  ------------------
   67|      0|      diag(VD->getLocation(),
   68|      0|           "declaration has %0 levels of pointer nesting; maximum allowed is 2")
   69|      0|          << NestingLevel;
   70|      0|    }
   71|  2.28k|  }
   72|  18.4k|}
   73|       |
   74|       |unsigned
   75|  2.28k|AvoidPointerArithmeticBoundsCheck::getPointerNestingLevel(QualType Type) const {
   76|  2.28k|  unsigned Level = 0;
   77|  3.06k|  while (Type->isPointerType()) {
  ------------------
  |  Branch (77:10): [True: 785, False: 2.28k]
  ------------------
   78|    785|    Level++;
   79|    785|    Type = Type->getPointeeType();
   80|    785|  }
   81|  2.28k|  return Level;
   82|  2.28k|}
   83|       |
   84|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidNarrowingConversionCheck.cpp:
    1|       |//===--- AvoidNarrowingConversionCheck.cpp - clang-tidy -------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidNarrowingConversionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidNarrowingConversionCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match implicit casts that could be narrowing
   22|     17|  Finder->addMatcher(
   23|     17|      implicitCastExpr(hasImplicitDestinationType(qualType().bind("toType")),
   24|     17|                       has(expr(hasType(qualType().bind("fromType")))))
   25|     17|          .bind("cast"),
   26|     17|      this);
   27|     17|}
   28|       |
   29|       |void AvoidNarrowingConversionCheck::check(
   30|  6.88k|    const MatchFinder::MatchResult &Result) {
   31|  6.88k|  const auto *Cast = Result.Nodes.getNodeAs<ImplicitCastExpr>("cast");
   32|  6.88k|  if (!Cast)
  ------------------
  |  Branch (32:7): [True: 0, False: 6.88k]
  ------------------
   33|      0|    return;
   34|       |
   35|       |  // Skip casts in system headers
   36|  6.88k|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (36:7): [True: 6.76k, False: 128]
  ------------------
   37|  6.76k|    return;
   38|       |
   39|       |  // Skip casts in macros
   40|    128|  if (Cast->getBeginLoc().isMacroID())
  ------------------
  |  Branch (40:7): [True: 0, False: 128]
  ------------------
   41|      0|    return;
   42|       |
   43|       |  // Only check certain cast kinds that could be narrowing
   44|    128|  auto CastKind = Cast->getCastKind();
   45|    128|  if (CastKind != CK_IntegralCast && CastKind != CK_FloatingToIntegral &&
  ------------------
  |  Branch (45:7): [True: 117, False: 11]
  |  Branch (45:38): [True: 113, False: 4]
  ------------------
   46|    128|      CastKind != CK_FloatingCast && CastKind != CK_IntegralToFloating)
  ------------------
  |  Branch (46:7): [True: 113, False: 0]
  |  Branch (46:38): [True: 106, False: 7]
  ------------------
   47|    106|    return;
   48|       |
   49|     22|  QualType FromType = Cast->getSubExpr()->getType().getCanonicalType();
   50|     22|  QualType ToType = Cast->getType().getCanonicalType();
   51|       |
   52|     22|  if (!isNarrowingConversion(FromType, ToType, *Result.Context))
  ------------------
  |  Branch (52:7): [True: 12, False: 10]
  ------------------
   53|     12|    return;
   54|       |
   55|     10|  diag(Cast->getBeginLoc(),
   56|     10|       "narrowing conversion from %0 to %1 may result in data loss")
   57|     10|      << FromType << ToType;
   58|     10|}
   59|       |
   60|       |bool AvoidNarrowingConversionCheck::isNarrowingConversion(
   61|     22|    QualType FromType, QualType ToType, const ASTContext &Ctx) const {
   62|       |  // Get canonical types
   63|     22|  FromType = FromType.getCanonicalType();
   64|     22|  ToType = ToType.getCanonicalType();
   65|       |
   66|       |  // Same type is not narrowing
   67|     22|  if (FromType == ToType)
  ------------------
  |  Branch (67:7): [True: 0, False: 22]
  ------------------
   68|      0|    return false;
   69|       |
   70|     22|  const auto *FromBuiltin = FromType->getAs<BuiltinType>();
   71|     22|  const auto *ToBuiltin = ToType->getAs<BuiltinType>();
   72|       |
   73|     22|  if (!FromBuiltin || !ToBuiltin)
  ------------------
  |  Branch (73:7): [True: 0, False: 22]
  |  Branch (73:23): [True: 0, False: 22]
  ------------------
   74|      0|    return false;
   75|       |
   76|       |  // Floating-point to integer is always narrowing
   77|     22|  if (FromType->isFloatingType() && ToType->isIntegerType())
  ------------------
  |  Branch (77:7): [True: 4, False: 18]
  |  Branch (77:37): [True: 4, False: 0]
  ------------------
   78|      4|    return true;
   79|       |
   80|       |  // Larger floating-point to smaller floating-point
   81|     18|  if (FromType->isFloatingType() && ToType->isFloatingType()) {
  ------------------
  |  Branch (81:7): [True: 0, False: 18]
  |  Branch (81:37): [True: 0, False: 0]
  ------------------
   82|      0|    unsigned FromSize = Ctx.getTypeSize(FromType);
   83|      0|    unsigned ToSize = Ctx.getTypeSize(ToType);
   84|      0|    return FromSize > ToSize;
   85|      0|  }
   86|       |
   87|       |  // Integer conversions
   88|     18|  if (FromType->isIntegerType() && ToType->isIntegerType()) {
  ------------------
  |  Branch (88:7): [True: 18, False: 0]
  |  Branch (88:36): [True: 11, False: 7]
  ------------------
   89|     11|    unsigned FromSize = Ctx.getTypeSize(FromType);
   90|     11|    unsigned ToSize = Ctx.getTypeSize(ToType);
   91|       |
   92|       |    // Larger to smaller is narrowing
   93|     11|    if (FromSize > ToSize)
  ------------------
  |  Branch (93:9): [True: 2, False: 9]
  ------------------
   94|      2|      return true;
   95|       |
   96|       |    // Same size but signed to unsigned or vice versa with potential loss
   97|      9|    if (FromSize == ToSize &&
  ------------------
  |  Branch (97:9): [True: 4, False: 5]
  ------------------
   98|      9|        FromType->isSignedIntegerType() != ToType->isSignedIntegerType())
  ------------------
  |  Branch (98:9): [True: 4, False: 0]
  ------------------
   99|      4|      return true;
  100|      9|  }
  101|       |
  102|       |  // Integer to floating-point can lose precision for large integers
  103|     12|  if (FromType->isIntegerType() && ToType->isFloatingType()) {
  ------------------
  |  Branch (103:7): [True: 12, False: 0]
  |  Branch (103:36): [True: 7, False: 5]
  ------------------
  104|      7|    unsigned FromSize = Ctx.getTypeSize(FromType);
  105|       |    // int64_t to float loses precision (float has ~24 bits of mantissa)
  106|       |    // int64_t to double can also lose precision (double has ~53 bits)
  107|      7|    if (ToType->isSpecificBuiltinType(BuiltinType::Float) && FromSize > 24)
  ------------------
  |  Branch (107:9): [True: 0, False: 7]
  |  Branch (107:62): [True: 0, False: 0]
  ------------------
  108|      0|      return true;
  109|      7|    if (ToType->isSpecificBuiltinType(BuiltinType::Double) && FromSize > 53)
  ------------------
  |  Branch (109:9): [True: 7, False: 0]
  |  Branch (109:63): [True: 0, False: 7]
  ------------------
  110|      0|      return true;
  111|      7|  }
  112|       |
  113|     12|  return false;
  114|     12|}
  115|       |
  116|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidCStyleCastCheck.h:
    1|       |//===--- AvoidCStyleCastCheck.h - clang-tidy -------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCSTYLECASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCSTYLECASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects C-style casts in C++ code.
   18|       |///
   19|       |/// C-style casts can perform a wide variety of conversions and are harder to
   20|       |/// search for and understand. They can accidentally perform dangerous
   21|       |/// conversions and do not provide the same level of type safety as C++ casts.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 8.2.1
   24|       |/// C-style casts shall not be used.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   int x = 42;
   30|       |///   double d = (double)x;  // Warning: C-style cast detected
   31|       |///   // Use: double d = static_cast<double>(x);
   32|       |/// @endcode
   33|       |class AvoidCStyleCastCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  AvoidCStyleCastCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidCStyleCastCheck() override = default;
   43|       |
   44|       |  /// Determines if this check is language-version sensitive.
   45|       |  /// \param LangOpts Language options to check.
   46|       |  /// \return true if the check is applicable to C++.
   47|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   48|    131|    return LangOpts.CPlusPlus;
   49|    131|  }
   50|       |
   51|       |  /// Registers AST matchers for C-style casts.
   52|       |  /// \param Finder The match finder to register matchers with.
   53|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   54|       |
   55|       |  /// Handles matched C-style casts and emits diagnostics.
   56|       |  /// \param Result The match result containing the matched AST node.
   57|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCSTYLECASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidThrowingDestructorCheck.h:
    1|       |//===--- AvoidThrowingDestructorCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINGDESTRUCTORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINGDESTRUCTORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-exceptions
   17|       |/// @brief Detects destructors that may throw exceptions.
   18|       |///
   19|       |/// Destructors should not throw exceptions because they are often called during
   20|       |/// stack unwinding when another exception is active. Throwing in this context
   21|       |/// results in std::terminate being called.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 18.4.1
   24|       |/// Destructors shall not throw exceptions.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   class Bad {
   30|       |///     ~Bad() { throw std::runtime_error("error"); }  // Warning
   31|       |///   };
   32|       |/// @endcode
   33|       |class AvoidThrowingDestructorCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidThrowingDestructorCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|    131|  ~AvoidThrowingDestructorCheck() override = default;
   39|       |
   40|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   41|    131|    return LangOpts.CPlusPlus;
   42|    131|  }
   43|       |
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINGDESTRUCTORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidImplicitConversionCheck.h:
    1|       |//===--- AvoidImplicitConversionCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects implicit conversions that should be explicit.
   18|       |///
   19|       |/// Implicit conversions can lead to unexpected behavior, especially when
   20|       |/// converting between different numeric types or when precision loss occurs.
   21|       |/// This check identifies implicit conversions in function arguments and
   22|       |/// return statements that should be made explicit.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 8.3.1
   25|       |/// Implicit conversions shall be made explicit.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   void foo(double d);
   31|       |///   int x = 42;
   32|       |///   foo(x);  // Warning: implicit conversion from int to double
   33|       |///   foo(static_cast<double>(x));  // OK: explicit conversion
   34|       |/// @endcode
   35|       |class AvoidImplicitConversionCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidImplicitConversionCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|    131|  ~AvoidImplicitConversionCheck() override = default;
   41|       |
   42|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   43|    131|    return LangOpts.CPlusPlus;
   44|    131|  }
   45|       |
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |
   49|       |private:
   50|       |  bool isSignificantConversion(QualType From, QualType To,
   51|       |                               const ASTContext &Ctx) const;
   52|       |};
   53|       |
   54|       |} // namespace clang::tidy::automotive
   55|       |
   56|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/NoexceptMoveCheck.cpp:
    1|       |//===--- NoexceptMoveCheck.cpp - clang-tidy -------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "NoexceptMoveCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void NoexceptMoveCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus11)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match move constructors
   22|     17|  Finder->addMatcher(cxxConstructorDecl(isMoveConstructor(),
   23|     17|                                        unless(isImplicit()),
   24|     17|                                        unless(isDeleted()))
   25|     17|                         .bind("move_ctor"),
   26|     17|                     this);
   27|       |
   28|       |  // Match move assignment operators
   29|     17|  Finder->addMatcher(cxxMethodDecl(isMoveAssignmentOperator(),
   30|     17|                                   unless(isImplicit()), unless(isDeleted()))
   31|     17|                         .bind("move_assign"),
   32|     17|                     this);
   33|     17|}
   34|       |
   35|     97|void NoexceptMoveCheck::check(const MatchFinder::MatchResult &Result) {
   36|     97|  const FunctionDecl *Func = nullptr;
   37|     97|  bool IsMoveConstructor = false;
   38|       |
   39|     97|  if (const auto *MoveCtor =
  ------------------
  |  Branch (39:19): [True: 58, False: 39]
  ------------------
   40|     97|          Result.Nodes.getNodeAs<CXXConstructorDecl>("move_ctor")) {
   41|     58|    Func = MoveCtor;
   42|     58|    IsMoveConstructor = true;
   43|     58|  } else if (const auto *MoveAssign =
  ------------------
  |  Branch (43:26): [True: 39, False: 0]
  ------------------
   44|     39|                 Result.Nodes.getNodeAs<CXXMethodDecl>("move_assign")) {
   45|     39|    Func = MoveAssign;
   46|     39|    IsMoveConstructor = false;
   47|     39|  }
   48|       |
   49|     97|  if (!Func)
  ------------------
  |  Branch (49:7): [True: 0, False: 97]
  ------------------
   50|      0|    return;
   51|       |
   52|       |  // Skip system headers
   53|     97|  if (Result.SourceManager->isInSystemHeader(Func->getLocation()))
  ------------------
  |  Branch (53:7): [True: 86, False: 11]
  ------------------
   54|     86|    return;
   55|       |
   56|       |  // Check if the function is noexcept
   57|     11|  const auto *FPT = Func->getType()->getAs<FunctionProtoType>();
   58|     11|  if (!FPT)
  ------------------
  |  Branch (58:7): [True: 0, False: 11]
  ------------------
   59|      0|    return;
   60|       |
   61|       |  // Check exception specification
   62|     11|  ExceptionSpecificationType EST = FPT->getExceptionSpecType();
   63|       |
   64|       |  // noexcept or noexcept(true) is acceptable
   65|     11|  if (EST == EST_BasicNoexcept || EST == EST_NoexceptTrue)
  ------------------
  |  Branch (65:7): [True: 4, False: 7]
  |  Branch (65:35): [True: 2, False: 5]
  ------------------
   66|      6|    return;
   67|       |
   68|       |  // noexcept(false) or throw() specifications are not acceptable
   69|       |  // Also catch functions with no exception specification
   70|       |
   71|      5|  const char *FuncType =
   72|      5|      IsMoveConstructor ? "move constructor" : "move assignment operator";
  ------------------
  |  Branch (72:7): [True: 3, False: 2]
  ------------------
   73|       |
   74|      5|  diag(Func->getLocation(), "%0 should be declared noexcept") << FuncType;
   75|      5|}
   76|       |
   77|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/VirtualDestructorCheck.cpp:
    1|       |//===--- VirtualDestructorCheck.cpp - clang-tidy -------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "VirtualDestructorCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include <algorithm>
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|     17|void VirtualDestructorCheck::registerMatchers(MatchFinder *Finder) {
   19|       |  // Only match in C++ code
   20|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (20:7): [True: 0, False: 17]
  ------------------
   21|      0|    return;
   22|       |
   23|       |  // Match classes that have at least one virtual method
   24|     17|  Finder->addMatcher(cxxRecordDecl(isClass(),
   25|     17|                                   hasMethod(cxxMethodDecl(isVirtual())),
   26|     17|                                   unless(isLambda()))
   27|     17|                         .bind("class"),
   28|     17|                     this);
   29|     17|}
   30|       |
   31|       |/// Check if any base class has a virtual destructor.
   32|      5|static bool hasVirtualDestructorInBase(const CXXRecordDecl *ClassDecl) {
   33|      5|  return std::any_of(ClassDecl->bases().begin(), ClassDecl->bases().end(),
   34|      5|                     [](const CXXBaseSpecifier &Base) {
   35|      2|                       const auto *BaseClass =
   36|      2|                           Base.getType()->getAsCXXRecordDecl();
   37|      2|                       if (!BaseClass || !BaseClass->hasDefinition())
  ------------------
  |  Branch (37:28): [True: 0, False: 2]
  |  Branch (37:42): [True: 0, False: 2]
  ------------------
   38|      0|                         return false;
   39|      2|                       const CXXDestructorDecl *BaseDtor =
   40|      2|                           BaseClass->getDestructor();
   41|      2|                       return BaseDtor && BaseDtor->isVirtual();
  ------------------
  |  Branch (41:31): [True: 2, False: 0]
  |  Branch (41:43): [True: 2, False: 0]
  ------------------
   42|      2|                     });
   43|      5|}
   44|       |
   45|     52|void VirtualDestructorCheck::check(const MatchFinder::MatchResult &Result) {
   46|     52|  const auto *ClassDecl = Result.Nodes.getNodeAs<CXXRecordDecl>("class");
   47|     52|  if (!ClassDecl || !ClassDecl->hasDefinition())
  ------------------
  |  Branch (47:7): [True: 0, False: 52]
  |  Branch (47:21): [True: 0, False: 52]
  ------------------
   48|      0|    return;
   49|       |
   50|       |  // Skip system headers
   51|     52|  if (Result.SourceManager->isInSystemHeader(ClassDecl->getBeginLoc()))
  ------------------
  |  Branch (51:7): [True: 38, False: 14]
  ------------------
   52|     38|    return;
   53|       |
   54|       |  // Get the destructor
   55|     14|  const CXXDestructorDecl *Destructor = ClassDecl->getDestructor();
   56|       |
   57|       |  // If there's no destructor or it's implicit, check if any base has virtual
   58|       |  // destructor
   59|     14|  if (!Destructor || Destructor->isImplicit()) {
  ------------------
  |  Branch (59:7): [True: 0, False: 14]
  |  Branch (59:22): [True: 5, False: 9]
  ------------------
   60|      5|    if (!hasVirtualDestructorInBase(ClassDecl))
  ------------------
  |  Branch (60:9): [True: 3, False: 2]
  ------------------
   61|      3|      diag(ClassDecl->getLocation(),
   62|      3|           "class '%0' has virtual functions but no explicit virtual "
   63|      3|           "destructor")
   64|      3|          << ClassDecl->getQualifiedNameAsString();
   65|      5|    return;
   66|      5|  }
   67|       |
   68|       |  // Check if the explicit destructor is virtual
   69|      9|  if (!Destructor->isVirtual())
  ------------------
  |  Branch (69:7): [True: 3, False: 6]
  ------------------
   70|      3|    diag(Destructor->getLocation(),
   71|      3|         "class '%0' has virtual functions but destructor is not virtual")
   72|      3|        << ClassDecl->getQualifiedNameAsString();
   73|      9|}
   74|       |
   75|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidDynamicCastCheck.cpp:
    1|       |//===--- AvoidDynamicCastCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidDynamicCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidDynamicCastCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match dynamic_cast expressions
   22|     17|  Finder->addMatcher(cxxDynamicCastExpr().bind("cast"), this);
   23|     17|}
   24|       |
   25|      4|void AvoidDynamicCastCheck::check(const MatchFinder::MatchResult &Result) {
   26|      4|  const auto *Cast = Result.Nodes.getNodeAs<CXXDynamicCastExpr>("cast");
   27|      4|  if (!Cast)
  ------------------
  |  Branch (27:7): [True: 0, False: 4]
  ------------------
   28|      0|    return;
   29|       |
   30|       |  // Skip casts in system headers
   31|      4|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (31:7): [True: 2, False: 2]
  ------------------
   32|      2|    return;
   33|       |
   34|      2|  diag(Cast->getBeginLoc(),
   35|      2|       "dynamic_cast should not be used; prefer static polymorphism or "
   36|      2|       "static_cast with prior type checking");
   37|      2|}
   38|       |
   39|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidConstCastCheck.cpp:
    1|       |//===--- AvoidConstCastCheck.cpp - clang-tidy -----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidConstCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidConstCastCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  Finder->addMatcher(cxxConstCastExpr().bind("cast"), this);
   19|     17|}
   20|       |
   21|     16|void AvoidConstCastCheck::check(const MatchFinder::MatchResult &Result) {
   22|     16|  const auto *Cast = Result.Nodes.getNodeAs<CXXConstCastExpr>("cast");
   23|     16|  if (!Cast)
  ------------------
  |  Branch (23:7): [True: 0, False: 16]
  ------------------
   24|      0|    return;
   25|       |
   26|       |  // Skip system headers
   27|     16|  if (Result.SourceManager->isInSystemHeader(Cast->getOperatorLoc()))
  ------------------
  |  Branch (27:7): [True: 12, False: 4]
  ------------------
   28|     12|    return;
   29|       |
   30|      4|  diag(Cast->getOperatorLoc(), "const_cast shall not be used");
   31|      4|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidCStyleCastCheck.cpp:
    1|       |//===--- AvoidCStyleCastCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCStyleCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidCStyleCastCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Only match in C++ code
   19|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (19:7): [True: 0, False: 17]
  ------------------
   20|      0|    return;
   21|       |
   22|       |  // Match C-style casts
   23|     17|  Finder->addMatcher(cStyleCastExpr().bind("cast"), this);
   24|     17|}
   25|       |
   26|    234|void AvoidCStyleCastCheck::check(const MatchFinder::MatchResult &Result) {
   27|    234|  const auto *Cast = Result.Nodes.getNodeAs<CStyleCastExpr>("cast");
   28|    234|  if (!Cast)
  ------------------
  |  Branch (28:7): [True: 0, False: 234]
  ------------------
   29|      0|    return;
   30|       |
   31|       |  // Skip casts in system headers
   32|    234|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (32:7): [True: 192, False: 42]
  ------------------
   33|    192|    return;
   34|       |
   35|       |  // Skip implicit casts that appear as C-style in AST
   36|     42|  if (Cast->getBeginLoc().isMacroID())
  ------------------
  |  Branch (36:7): [True: 0, False: 42]
  ------------------
   37|      0|    return;
   38|       |
   39|     42|  diag(Cast->getBeginLoc(),
   40|     42|       "C-style casts shall not be used; use static_cast, const_cast, "
   41|     42|       "reinterpret_cast, or dynamic_cast instead");
   42|     42|}
   43|       |
   44|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidReinterpretCastCheck.cpp:
    1|       |//===--- AvoidReinterpretCastCheck.cpp - clang-tidy -----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidReinterpretCastCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidReinterpretCastCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  Finder->addMatcher(cxxReinterpretCastExpr().bind("cast"), this);
   19|     17|}
   20|       |
   21|      6|void AvoidReinterpretCastCheck::check(const MatchFinder::MatchResult &Result) {
   22|      6|  const auto *Cast = Result.Nodes.getNodeAs<CXXReinterpretCastExpr>("cast");
   23|      6|  if (!Cast)
  ------------------
  |  Branch (23:7): [True: 0, False: 6]
  ------------------
   24|      0|    return;
   25|       |
   26|       |  // Skip system headers
   27|      6|  if (Result.SourceManager->isInSystemHeader(Cast->getOperatorLoc()))
  ------------------
  |  Branch (27:7): [True: 2, False: 4]
  ------------------
   28|      2|    return;
   29|       |
   30|      4|  diag(Cast->getOperatorLoc(), "reinterpret_cast shall not be used");
   31|      4|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/VirtualDestructorCheck.h:
    1|       |//===--- VirtualDestructorCheck.h - clang-tidy -----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_VIRTUALDESTRUCTORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_VIRTUALDESTRUCTORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-classes
   17|       |/// @brief Detects base classes with virtual functions but non-virtual
   18|       |/// destructors.
   19|       |///
   20|       |/// A class with virtual functions that is intended to be used polymorphically
   21|       |/// should have a virtual destructor. Without a virtual destructor, deleting a
   22|       |/// derived class object through a base class pointer results in undefined
   23|       |/// behavior as the derived class destructor will not be called.
   24|       |///
   25|       |/// @par MISRA C++:2023 Rule 15.7.1
   26|       |/// A class which has virtual functions shall have a virtual destructor.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   class Base {
   32|       |///   public:
   33|       |///     virtual void foo();
   34|       |///     ~Base() { }  // Warning: non-virtual destructor in class with virtual
   35|       |///     functions
   36|       |///   };
   37|       |/// @endcode
   38|       |class VirtualDestructorCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  /// Constructs the check with the given name and context.
   41|       |  /// \param Name The name of the check as registered.
   42|       |  /// \param Context The clang-tidy context for configuration.
   43|       |  VirtualDestructorCheck(StringRef Name, ClangTidyContext *Context)
   44|    131|      : ClangTidyCheck(Name, Context) {}
   45|       |
   46|       |  /// Destructor.
   47|    131|  ~VirtualDestructorCheck() override = default;
   48|       |
   49|       |  /// Determines if this check is language-version sensitive.
   50|       |  /// \param LangOpts Language options to check.
   51|       |  /// \return true if the check is applicable to C++.
   52|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   53|    131|    return LangOpts.CPlusPlus;
   54|    131|  }
   55|       |
   56|       |  /// Registers AST matchers for classes with virtual functions.
   57|       |  /// \param Finder The match finder to register matchers with.
   58|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   59|       |
   60|       |  /// Handles matched classes and checks destructor virtuality.
   61|       |  /// \param Result The match result containing the matched AST node.
   62|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   63|       |};
   64|       |
   65|       |} // namespace clang::tidy::automotive
   66|       |
   67|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_VIRTUALDESTRUCTORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/ProperConceptDefinitionCheck.cpp:
    1|       |//===--- ProperConceptDefinitionCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ProperConceptDefinitionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|      1|void ProperConceptDefinitionCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match concept declarations
   19|      1|  Finder->addMatcher(
   20|      1|      conceptDecl(unless(isExpansionInSystemHeader())).bind("concept"), this);
   21|      1|}
   22|       |
   23|      5|bool ProperConceptDefinitionCheck::isTrivialConstraint(const Expr *E) const {
   24|      5|  if (!E)
  ------------------
  |  Branch (24:7): [True: 0, False: 5]
  ------------------
   25|      0|    return false;
   26|       |
   27|       |  // Strip any implicit casts
   28|      5|  E = E->IgnoreParenImpCasts();
   29|       |
   30|       |  // Check for boolean literals (true/false)
   31|      5|  if (isa<CXXBoolLiteralExpr>(E))
  ------------------
  |  Branch (31:7): [True: 2, False: 3]
  ------------------
   32|      2|    return true;
   33|       |
   34|       |  // Check for integral constant that evaluates to true/false
   35|      3|  if (isa<IntegerLiteral>(E))
  ------------------
  |  Branch (35:7): [True: 0, False: 3]
  ------------------
   36|      0|    return true;
   37|       |
   38|      3|  return false;
   39|      3|}
   40|       |
   41|       |void ProperConceptDefinitionCheck::check(
   42|      5|    const MatchFinder::MatchResult &Result) {
   43|      5|  const auto *CD = Result.Nodes.getNodeAs<ConceptDecl>("concept");
   44|      5|  if (!CD)
  ------------------
  |  Branch (44:7): [True: 0, False: 5]
  ------------------
   45|      0|    return;
   46|       |
   47|      5|  const Expr *ConstraintExpr = CD->getConstraintExpr();
   48|      5|  if (!ConstraintExpr)
  ------------------
  |  Branch (48:7): [True: 0, False: 5]
  ------------------
   49|      0|    return;
   50|       |
   51|       |  // Check for trivially satisfied concepts (e.g., concept X = true;)
   52|      5|  if (isTrivialConstraint(ConstraintExpr)) {
  ------------------
  |  Branch (52:7): [True: 2, False: 3]
  ------------------
   53|      2|    diag(CD->getLocation(),
   54|      2|         "concept %0 is trivially satisfied; concepts should express "
   55|      2|         "meaningful constraints")
   56|      2|        << CD;
   57|      2|    return;
   58|      2|  }
   59|      5|}
   60|       |
   61|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidThrowInNoexceptCheck.h:
    1|       |//===--- AvoidThrowInNoexceptCheck.h - clang-tidy ---------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINNOEXCEPTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINNOEXCEPTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-exceptions
   17|       |/// @brief Detects throw expressions inside noexcept functions.
   18|       |///
   19|       |/// A throw expression in a noexcept function will result in std::terminate
   20|       |/// being called if the exception propagates. This is often unintended and
   21|       |/// indicates a design issue.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 18.4.3
   24|       |/// A noexcept function shall not throw.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   void foo() noexcept {
   30|       |///     throw std::runtime_error("error");  // Warning: throw in noexcept
   31|       |///   }
   32|       |/// @endcode
   33|       |class AvoidThrowInNoexceptCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidThrowInNoexceptCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|    131|  ~AvoidThrowInNoexceptCheck() override = default;
   39|       |
   40|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   41|    131|    return LangOpts.CPlusPlus11; // noexcept requires C++11
   42|    131|  }
   43|       |
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDTHROWINNOEXCEPTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/RuleOfFiveCheck.h:
    1|       |//===--- RuleOfFiveCheck.h - clang-tidy -------------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_RULEOFFIVECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_RULEOFFIVECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-classes
   17|       |/// @brief Enforces the Rule of Five for classes with custom resource
   18|       |/// management.
   19|       |///
   20|       |/// If a class defines any of the following special member functions, it should
   21|       |/// define all five: destructor, copy constructor, copy assignment operator,
   22|       |/// move constructor, and move assignment operator.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 15.0.1
   25|       |/// If a class has a user-declared destructor, copy/move constructor, or
   26|       |/// copy/move assignment operator, then all five should be declared.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   class Resource {
   32|       |///     int* ptr;
   33|       |///   public:
   34|       |///     ~Resource() { delete ptr; }  // Warning: defines destructor but not
   35|       |///     others
   36|       |///   };
   37|       |/// @endcode
   38|       |class RuleOfFiveCheck : public ClangTidyCheck {
   39|       |public:
   40|       |  RuleOfFiveCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|    131|  ~RuleOfFiveCheck() override = default;
   44|       |
   45|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   46|    131|    return LangOpts.CPlusPlus11; // Rule of Five requires C++11 for move
   47|    131|  }
   48|       |
   49|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_RULEOFFIVECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidReinterpretCastCheck.h:
    1|       |//===--- AvoidReinterpretCastCheck.h - clang-tidy ---------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDREINTERPRETCASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDREINTERPRETCASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects usage of reinterpret_cast.
   18|       |///
   19|       |/// reinterpret_cast performs low-level type reinterpretation with no safety
   20|       |/// checks. It can easily lead to undefined behavior and should be avoided
   21|       |/// in safety-critical code.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 8.2.4
   24|       |/// reinterpret_cast shall not be used.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   int x = 42;
   30|       |///   float* fp = reinterpret_cast<float*>(&x);  // Warning
   31|       |/// @endcode
   32|       |class AvoidReinterpretCastCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  AvoidReinterpretCastCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|    131|  ~AvoidReinterpretCastCheck() override = default;
   38|       |
   39|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   40|    131|    return LangOpts.CPlusPlus;
   41|    131|  }
   42|       |
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDREINTERPRETCASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/Cpp23Component.cpp:
    1|       |//===--- Cpp23Component.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "Cpp23Component.h"
   10|       |#include "AvoidCStyleCastCheck.h"
   11|       |#include "AvoidConstCastCheck.h"
   12|       |#include "AvoidDynamicCastCheck.h"
   13|       |#include "AvoidImplicitConversionCheck.h"
   14|       |#include "AvoidImplicitConversionOperatorCheck.h"
   15|       |#include "AvoidNarrowingConversionCheck.h"
   16|       |#include "AvoidReinterpretCastCheck.h"
   17|       |#include "AvoidSlicingCheck.h"
   18|       |#include "AvoidThrowInNoexceptCheck.h"
   19|       |#include "AvoidThrowingDestructorCheck.h"
   20|       |#include "ExplicitConstructorCheck.h"
   21|       |#include "NoexceptMoveCheck.h"
   22|       |#include "ProperConceptDefinitionCheck.h"
   23|       |#include "RuleOfFiveCheck.h"
   24|       |#include "UnconstrainedTemplateCheck.h"
   25|       |#include "VirtualDestructorCheck.h"
   26|       |
   27|       |namespace clang::tidy::automotive {
   28|       |
   29|       |void Cpp23Component::addCheckFactories(
   30|    262|    ClangTidyCheckFactories &CheckFactories) {
   31|       |
   32|       |  // MISRA C++:2023 Rule 8.2.1 - C-style casts shall not be used
   33|    262|  CheckFactories.registerCheck<AvoidCStyleCastCheck>(
   34|    262|      "automotive-cpp23-req-8.2.1");
   35|       |
   36|       |  // MISRA C++:2023 Rule 15.3.1 - Avoid object slicing
   37|    262|  CheckFactories.registerCheck<AvoidSlicingCheck>("automotive-cpp23-req-15.3");
   38|       |
   39|       |  // MISRA C++:2023 Rule 15.7.1 - Base classes with virtual functions need
   40|       |  // virtual destructors
   41|    262|  CheckFactories.registerCheck<VirtualDestructorCheck>(
   42|    262|      "automotive-cpp23-req-15.7");
   43|       |
   44|       |  // MISRA C++:2023 Rule 15.1.3 - Single-argument constructors shall be explicit
   45|    262|  CheckFactories.registerCheck<ExplicitConstructorCheck>(
   46|    262|      "automotive-cpp23-req-15.1.3");
   47|       |
   48|       |  // MISRA C++:2023 Rule 18.4.2 - Move operations shall be noexcept
   49|    262|  CheckFactories.registerCheck<NoexceptMoveCheck>(
   50|    262|      "automotive-cpp23-req-18.4.2");
   51|       |
   52|       |  // MISRA C++:2023 Rule 8.4.1 - Narrowing conversions shall not be used
   53|    262|  CheckFactories.registerCheck<AvoidNarrowingConversionCheck>(
   54|    262|      "automotive-cpp23-req-8.4.1");
   55|       |
   56|       |  // MISRA C++:2023 Rule 15.0.1 - Rule of Five for special member functions
   57|    262|  CheckFactories.registerCheck<RuleOfFiveCheck>("automotive-cpp23-req-15.0.1");
   58|       |
   59|       |  // MISRA C++:2023 Rule 8.2.5 - dynamic_cast should not be used
   60|    262|  CheckFactories.registerCheck<AvoidDynamicCastCheck>(
   61|    262|      "automotive-cpp23-adv-8.2.5");
   62|       |
   63|       |  // MISRA C++:2023 Rule 18.4.1 - Destructors shall not throw exceptions
   64|    262|  CheckFactories.registerCheck<AvoidThrowingDestructorCheck>(
   65|    262|      "automotive-cpp23-req-18.4.1");
   66|       |
   67|       |  // MISRA C++:2023 Rule 8.2.3 - const_cast shall not be used
   68|    262|  CheckFactories.registerCheck<AvoidConstCastCheck>(
   69|    262|      "automotive-cpp23-req-8.2.3");
   70|       |
   71|       |  // MISRA C++:2023 Rule 8.2.4 - reinterpret_cast shall not be used
   72|    262|  CheckFactories.registerCheck<AvoidReinterpretCastCheck>(
   73|    262|      "automotive-cpp23-req-8.2.4");
   74|       |
   75|       |  // MISRA C++:2023 Rule 15.1.2 - Conversion operators shall be explicit
   76|    262|  CheckFactories.registerCheck<AvoidImplicitConversionOperatorCheck>(
   77|    262|      "automotive-cpp23-req-15.1.2");
   78|       |
   79|       |  // MISRA C++:2023 Rule 18.4.3 - Throw in noexcept function calls
   80|       |  // std::terminate
   81|    262|  CheckFactories.registerCheck<AvoidThrowInNoexceptCheck>(
   82|    262|      "automotive-cpp23-req-18.4.3");
   83|       |
   84|       |  // MISRA C++:2023 Rule 8.3.1 - Implicit conversions shall be explicit
   85|    262|  CheckFactories.registerCheck<AvoidImplicitConversionCheck>(
   86|    262|      "automotive-cpp23-req-8.3.1");
   87|       |
   88|       |  // MISRA C++:2023 Rule 17.0.1 - Template parameters shall be constrained
   89|    262|  CheckFactories.registerCheck<UnconstrainedTemplateCheck>(
   90|    262|      "automotive-cpp23-adv-17.0.1");
   91|       |
   92|       |  // MISRA C++:2023 Rule 17.1.1 - Concepts shall be properly defined
   93|    262|  CheckFactories.registerCheck<ProperConceptDefinitionCheck>(
   94|    262|      "automotive-cpp23-adv-17.1.1");
   95|    262|}
   96|       |
   97|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidSlicingCheck.cpp:
    1|       |//===--- AvoidSlicingCheck.cpp - clang-tidy ------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidSlicingCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidSlicingCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Only match in C++ code
   19|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (19:7): [True: 0, False: 17]
  ------------------
   20|      0|    return;
   21|       |
   22|       |  // Match copy constructor calls where object slicing occurs
   23|       |  // This happens when a derived class object is used to construct a base class
   24|     17|  Finder->addMatcher(
   25|     17|      cxxConstructExpr(
   26|     17|          hasDeclaration(cxxConstructorDecl(isCopyConstructor())),
   27|     17|          hasArgument(0, expr(hasType(cxxRecordDecl().bind("derived")))))
   28|     17|          .bind("construct"),
   29|     17|      this);
   30|       |
   31|       |  // Match variable declarations that slice
   32|     17|  Finder->addMatcher(varDecl(hasType(cxxRecordDecl().bind("base-var")),
   33|     17|                             hasInitializer(expr(
   34|     17|                                 hasType(cxxRecordDecl().bind("derived-var")))))
   35|     17|                         .bind("var-decl"),
   36|     17|                     this);
   37|     17|}
   38|       |
   39|       |/// Check if slicing occurs between derived and base classes.
   40|       |static bool isSlicing(const CXXRecordDecl *DerivedDecl,
   41|     15|                      const CXXRecordDecl *BaseDecl) {
   42|     15|  if (!DerivedDecl || !BaseDecl)
  ------------------
  |  Branch (42:7): [True: 0, False: 15]
  |  Branch (42:23): [True: 0, False: 15]
  ------------------
   43|      0|    return false;
   44|     15|  return DerivedDecl != BaseDecl && DerivedDecl->isDerivedFrom(BaseDecl);
  ------------------
  |  Branch (44:10): [True: 3, False: 12]
  |  Branch (44:37): [True: 3, False: 0]
  ------------------
   45|     15|}
   46|       |
   47|     97|void AvoidSlicingCheck::check(const MatchFinder::MatchResult &Result) {
   48|       |  // Check constructor-based slicing
   49|     97|  if (const auto *Construct =
  ------------------
  |  Branch (49:19): [True: 27, False: 70]
  ------------------
   50|     97|          Result.Nodes.getNodeAs<CXXConstructExpr>("construct")) {
   51|     27|    if (Result.SourceManager->isInSystemHeader(Construct->getBeginLoc()))
  ------------------
  |  Branch (51:9): [True: 22, False: 5]
  ------------------
   52|     22|      return;
   53|       |
   54|      5|    const auto *DerivedDecl = Result.Nodes.getNodeAs<CXXRecordDecl>("derived");
   55|      5|    const auto *BaseDecl = Construct->getType()->getAsCXXRecordDecl();
   56|       |
   57|      5|    if (isSlicing(DerivedDecl, BaseDecl))
  ------------------
  |  Branch (57:9): [True: 3, False: 2]
  ------------------
   58|      3|      diag(Construct->getBeginLoc(),
   59|      3|           "object slicing occurs when copying derived class '%0' to base "
   60|      3|           "class '%1'")
   61|      3|          << DerivedDecl->getQualifiedNameAsString()
   62|      3|          << BaseDecl->getQualifiedNameAsString();
   63|      5|    return;
   64|     27|  }
   65|       |
   66|       |  // Check variable declaration slicing
   67|     70|  const auto *VarD = Result.Nodes.getNodeAs<VarDecl>("var-decl");
   68|     70|  if (!VarD)
  ------------------
  |  Branch (68:7): [True: 0, False: 70]
  ------------------
   69|      0|    return;
   70|       |
   71|     70|  if (Result.SourceManager->isInSystemHeader(VarD->getBeginLoc()))
  ------------------
  |  Branch (71:7): [True: 60, False: 10]
  ------------------
   72|     60|    return;
   73|       |
   74|     10|  const auto *BaseDecl = Result.Nodes.getNodeAs<CXXRecordDecl>("base-var");
   75|     10|  const auto *DerivedDecl =
   76|     10|      Result.Nodes.getNodeAs<CXXRecordDecl>("derived-var");
   77|       |
   78|     10|  if (isSlicing(DerivedDecl, BaseDecl))
  ------------------
  |  Branch (78:7): [True: 0, False: 10]
  ------------------
   79|      0|    diag(VarD->getBeginLoc(),
   80|      0|         "object slicing occurs when assigning derived class '%0' to base "
   81|      0|         "class '%1' variable")
   82|      0|        << DerivedDecl->getQualifiedNameAsString()
   83|      0|        << BaseDecl->getQualifiedNameAsString();
   84|     10|}
   85|       |
   86|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidNarrowingConversionCheck.h:
    1|       |//===--- AvoidNarrowingConversionCheck.h - clang-tidy -----------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDNARROWINGCONVERSIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDNARROWINGCONVERSIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects narrowing conversions that may lose data.
   18|       |///
   19|       |/// Narrowing conversions can silently lose information and are a common source
   20|       |/// of bugs. This check detects implicit conversions that could result in data
   21|       |/// loss, such as converting a larger integer type to a smaller one, or
   22|       |/// converting floating-point to integer.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 8.4.1
   25|       |/// Narrowing conversions shall not be used.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   double d = 3.14;
   31|       |///   int x = d;  // Warning: narrowing conversion from double to int
   32|       |/// @endcode
   33|       |class AvoidNarrowingConversionCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidNarrowingConversionCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|    131|  ~AvoidNarrowingConversionCheck() override = default;
   39|       |
   40|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   41|    131|    return LangOpts.CPlusPlus;
   42|    131|  }
   43|       |
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |
   47|       |private:
   48|       |  bool isNarrowingConversion(QualType FromType, QualType ToType,
   49|       |                             const ASTContext &Ctx) const;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDNARROWINGCONVERSIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/UnconstrainedTemplateCheck.h:
    1|       |//===--- UnconstrainedTemplateCheck.h - clang-tidy --------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_UNCONSTRAINEDTEMPLATECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_UNCONSTRAINEDTEMPLATECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-templates
   17|       |/// @brief Detects template functions and classes without type constraints.
   18|       |///
   19|       |/// Templates without proper constraints can be instantiated with inappropriate
   20|       |/// types, leading to confusing error messages or undefined behavior. This check
   21|       |/// encourages the use of concepts (C++20) or static_assert for type
   22|       |/// constraints.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 17.0.1
   25|       |/// Template parameters shall be constrained.
   26|       |/// @par Category: Advisory
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   // Warning: unconstrained template
   31|       |///   template <typename T>
   32|       |///   T add(T a, T b) { return a + b; }
   33|       |///
   34|       |///   // OK: constrained with concept (C++20)
   35|       |///   template <typename T>
   36|       |///   requires std::integral<T>
   37|       |///   T add(T a, T b) { return a + b; }
   38|       |///
   39|       |///   // OK: constrained with static_assert
   40|       |///   template <typename T>
   41|       |///   T add(T a, T b) {
   42|       |///     static_assert(std::is_arithmetic_v<T>, "T must be arithmetic");
   43|       |///     return a + b;
   44|       |///   }
   45|       |/// @endcode
   46|       |class UnconstrainedTemplateCheck : public ClangTidyCheck {
   47|       |public:
   48|       |  UnconstrainedTemplateCheck(StringRef Name, ClangTidyContext *Context)
   49|    131|      : ClangTidyCheck(Name, Context) {}
   50|       |
   51|    131|  ~UnconstrainedTemplateCheck() override = default;
   52|       |
   53|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   54|    131|    return LangOpts.CPlusPlus;
   55|    131|  }
   56|       |
   57|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   58|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   59|       |
   60|       |private:
   61|       |  bool hasConstraints(const FunctionTemplateDecl *FTD) const;
   62|       |  bool hasConstraints(const ClassTemplateDecl *CTD) const;
   63|       |  bool hasStaticAssert(const FunctionDecl *FD) const;
   64|       |};
   65|       |
   66|       |} // namespace clang::tidy::automotive
   67|       |
   68|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_UNCONSTRAINEDTEMPLATECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/ProperConceptDefinitionCheck.h:
    1|       |//===--- ProperConceptDefinitionCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_PROPERCONCEPTDEFINITIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_PROPERCONCEPTDEFINITIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-templates
   17|       |/// @brief Ensures C++20 concepts are properly defined and meaningful.
   18|       |///
   19|       |/// Concept definitions should be atomic (testing one thing), composable,
   20|       |/// and clearly documented. This check detects concepts that may be too
   21|       |/// broad or trivially satisfied.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 17.1.1
   24|       |/// Concepts shall be properly constrained.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   // Warning: trivially satisfied concept
   30|       |///   template <typename T>
   31|       |///   concept AlwaysTrue = true;
   32|       |///
   33|       |///   // OK: meaningful constraint
   34|       |///   template <typename T>
   35|       |///   concept Addable = requires(T a, T b) { a + b; };
   36|       |/// @endcode
   37|       |class ProperConceptDefinitionCheck : public ClangTidyCheck {
   38|       |public:
   39|       |  ProperConceptDefinitionCheck(StringRef Name, ClangTidyContext *Context)
   40|    131|      : ClangTidyCheck(Name, Context) {}
   41|       |
   42|    131|  ~ProperConceptDefinitionCheck() override = default;
   43|       |
   44|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   45|    131|    return LangOpts.CPlusPlus20;
   46|    131|  }
   47|       |
   48|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |
   51|       |private:
   52|       |  bool isTrivialConstraint(const Expr *E) const;
   53|       |};
   54|       |
   55|       |} // namespace clang::tidy::automotive
   56|       |
   57|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_PROPERCONCEPTDEFINITIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/NoexceptMoveCheck.h:
    1|       |//===--- NoexceptMoveCheck.h - clang-tidy -----------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_NOEXCEPTMOVECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_NOEXCEPTMOVECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-exceptions
   17|       |/// @brief Detects move constructors and move assignment operators not marked
   18|       |/// noexcept.
   19|       |///
   20|       |/// Move operations should be declared noexcept to enable optimizations in
   21|       |/// standard library containers and algorithms. Non-noexcept move operations
   22|       |/// can cause the standard library to use copy operations instead.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 18.4.2
   25|       |/// Move constructors and move assignment operators shall be noexcept.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   class Foo {
   31|       |///     Foo(Foo&&);  // Warning: should be noexcept
   32|       |///     Foo(Foo&&) noexcept;  // OK
   33|       |///     Foo& operator=(Foo&&);  // Warning: should be noexcept
   34|       |///     Foo& operator=(Foo&&) noexcept;  // OK
   35|       |///   };
   36|       |/// @endcode
   37|       |class NoexceptMoveCheck : public ClangTidyCheck {
   38|       |public:
   39|       |  /// Constructs the check with the given name and context.
   40|       |  /// \param Name The name of the check as registered.
   41|       |  /// \param Context The clang-tidy context for configuration.
   42|       |  NoexceptMoveCheck(StringRef Name, ClangTidyContext *Context)
   43|    131|      : ClangTidyCheck(Name, Context) {}
   44|       |
   45|       |  /// Destructor.
   46|    131|  ~NoexceptMoveCheck() override = default;
   47|       |
   48|       |  /// Determines if this check is language-version sensitive.
   49|       |  /// \param LangOpts Language options to check.
   50|       |  /// \return true if the check is applicable to C++11 and later.
   51|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   52|    131|    return LangOpts.CPlusPlus11;
   53|    131|  }
   54|       |
   55|       |  /// Registers AST matchers for move operations without noexcept.
   56|       |  /// \param Finder The match finder to register matchers with.
   57|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   58|       |
   59|       |  /// Handles matched move operations and emits diagnostics.
   60|       |  /// \param Result The match result containing the matched AST node.
   61|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   62|       |};
   63|       |
   64|       |} // namespace clang::tidy::automotive
   65|       |
   66|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_NOEXCEPTMOVECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidImplicitConversionCheck.cpp:
    1|       |//===--- AvoidImplicitConversionCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidImplicitConversionCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidImplicitConversionCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match implicit casts that are not trivial conversions
   19|       |  // This catches conversions in function arguments, return statements,
   20|       |  // and variable initializations
   21|     17|  Finder->addMatcher(
   22|     17|      implicitCastExpr(unless(isExpansionInSystemHeader()),
   23|     17|                       unless(isInTemplateInstantiation()),
   24|       |                       // Skip implicit casts inside explicit casts
   25|     17|                       unless(hasAncestor(explicitCastExpr())),
   26|       |                       // Only match casts that change the type meaningfully
   27|     17|                       hasImplicitDestinationType(
   28|     17|                           qualType(unless(isAnyPointer())).bind("toType")),
   29|     17|                       hasSourceExpression(expr().bind("fromExpr")))
   30|     17|          .bind("cast"),
   31|     17|      this);
   32|     17|}
   33|       |
   34|       |bool AvoidImplicitConversionCheck::isSignificantConversion(
   35|     20|    QualType From, QualType To, const ASTContext &Ctx) const {
   36|       |  // Get canonical types for comparison
   37|     20|  From = From.getCanonicalType();
   38|     20|  To = To.getCanonicalType();
   39|       |
   40|       |  // Same type - no conversion needed
   41|     20|  if (From == To)
  ------------------
  |  Branch (41:7): [True: 0, False: 20]
  ------------------
   42|      0|    return false;
   43|       |
   44|       |  // Ignore array to pointer decay
   45|     20|  if (From->isArrayType() && To->isPointerType())
  ------------------
  |  Branch (45:7): [True: 0, False: 20]
  |  Branch (45:30): [True: 0, False: 0]
  ------------------
   46|      0|    return false;
   47|       |
   48|       |  // Ignore function to pointer decay
   49|     20|  if (From->isFunctionType() && To->isPointerType())
  ------------------
  |  Branch (49:7): [True: 0, False: 20]
  |  Branch (49:33): [True: 0, False: 0]
  ------------------
   50|      0|    return false;
   51|       |
   52|       |  // Ignore lvalue to rvalue conversions
   53|     20|  if (From.getUnqualifiedType() == To.getUnqualifiedType())
  ------------------
  |  Branch (53:7): [True: 0, False: 20]
  ------------------
   54|      0|    return false;
   55|       |
   56|       |  // Check for numeric conversions
   57|     20|  if (From->isArithmeticType() && To->isArithmeticType()) {
  ------------------
  |  Branch (57:7): [True: 15, False: 5]
  |  Branch (57:35): [True: 15, False: 0]
  ------------------
   58|       |    // Integer to floating point - significant
   59|     15|    if (From->isIntegerType() && To->isFloatingType())
  ------------------
  |  Branch (59:9): [True: 14, False: 1]
  |  Branch (59:34): [True: 3, False: 11]
  ------------------
   60|      3|      return true;
   61|       |
   62|       |    // Floating point to integer - significant (but covered by narrowing check)
   63|     12|    if (From->isFloatingType() && To->isIntegerType())
  ------------------
  |  Branch (63:9): [True: 1, False: 11]
  |  Branch (63:35): [True: 1, False: 0]
  ------------------
   64|      1|      return true;
   65|       |
   66|       |    // Float to double promotion - less significant, allow
   67|       |    // Check by type size: float (32 bit) to double (64 bit)
   68|     11|    if (From->isFloatingType() && To->isFloatingType()) {
  ------------------
  |  Branch (68:9): [True: 0, False: 11]
  |  Branch (68:35): [True: 0, False: 0]
  ------------------
   69|      0|      uint64_t FromSize = Ctx.getTypeSize(From);
   70|      0|      uint64_t ToSize = Ctx.getTypeSize(To);
   71|      0|      if (FromSize < ToSize)
  ------------------
  |  Branch (71:11): [True: 0, False: 0]
  ------------------
   72|      0|        return false; // Promotion is OK
   73|      0|    }
   74|       |
   75|       |    // Signed/unsigned mismatch
   76|     11|    if (From->isSignedIntegerType() && To->isUnsignedIntegerType())
  ------------------
  |  Branch (76:9): [True: 10, False: 1]
  |  Branch (76:40): [True: 7, False: 3]
  ------------------
   77|      7|      return true;
   78|      4|    if (From->isUnsignedIntegerType() && To->isSignedIntegerType())
  ------------------
  |  Branch (78:9): [True: 1, False: 3]
  |  Branch (78:42): [True: 1, False: 0]
  ------------------
   79|      1|      return true;
   80|       |
   81|       |    // Standard integer promotions (char/short to int) - allow
   82|      3|    uint64_t FromSize = Ctx.getTypeSize(From);
   83|      3|    uint64_t ToSize = Ctx.getTypeSize(To);
   84|      3|    if (FromSize < 32 && ToSize >= 32 && From->isIntegerType() &&
  ------------------
  |  Branch (84:9): [True: 0, False: 3]
  |  Branch (84:26): [True: 0, False: 0]
  |  Branch (84:42): [True: 0, False: 0]
  ------------------
   85|      3|        To->isIntegerType())
  ------------------
  |  Branch (85:9): [True: 0, False: 0]
  ------------------
   86|      0|      return false;
   87|      3|  }
   88|       |
   89|       |  // Bool conversions
   90|      8|  if (To->isBooleanType() && !From->isBooleanType())
  ------------------
  |  Branch (90:7): [True: 1, False: 7]
  |  Branch (90:30): [True: 1, False: 0]
  ------------------
   91|      1|    return true;
   92|       |
   93|       |  // Pointer conversions (except null pointer)
   94|      7|  if (From->isPointerType() && To->isPointerType() && From != To)
  ------------------
  |  Branch (94:7): [True: 0, False: 7]
  |  Branch (94:32): [True: 0, False: 0]
  |  Branch (94:55): [True: 0, False: 0]
  ------------------
   95|      0|    return true;
   96|       |
   97|      7|  return false;
   98|      7|}
   99|       |
  100|       |void AvoidImplicitConversionCheck::check(
  101|     48|    const MatchFinder::MatchResult &Result) {
  102|     48|  const auto *Cast = Result.Nodes.getNodeAs<ImplicitCastExpr>("cast");
  103|     48|  if (!Cast)
  ------------------
  |  Branch (103:7): [True: 0, False: 48]
  ------------------
  104|      0|    return;
  105|       |
  106|       |  // Skip system headers
  107|     48|  if (Result.SourceManager->isInSystemHeader(Cast->getBeginLoc()))
  ------------------
  |  Branch (107:7): [True: 0, False: 48]
  ------------------
  108|      0|    return;
  109|       |
  110|       |  // Skip if in a macro
  111|     48|  if (Cast->getBeginLoc().isMacroID())
  ------------------
  |  Branch (111:7): [True: 0, False: 48]
  ------------------
  112|      0|    return;
  113|       |
  114|       |  // Get the cast kind
  115|     48|  CastKind Kind = Cast->getCastKind();
  116|       |
  117|       |  // Skip trivial casts
  118|     48|  if (Kind == CK_LValueToRValue || Kind == CK_NoOp ||
  ------------------
  |  Branch (118:7): [True: 19, False: 29]
  |  Branch (118:36): [True: 7, False: 22]
  ------------------
  119|     48|      Kind == CK_ArrayToPointerDecay || Kind == CK_FunctionToPointerDecay ||
  ------------------
  |  Branch (119:7): [True: 0, False: 22]
  |  Branch (119:41): [True: 0, False: 22]
  ------------------
  120|     48|      Kind == CK_NullToPointer || Kind == CK_NullToMemberPointer ||
  ------------------
  |  Branch (120:7): [True: 0, False: 22]
  |  Branch (120:35): [True: 0, False: 22]
  ------------------
  121|     48|      Kind == CK_ConstructorConversion || Kind == CK_UserDefinedConversion)
  ------------------
  |  Branch (121:7): [True: 0, False: 22]
  |  Branch (121:43): [True: 2, False: 20]
  ------------------
  122|     28|    return;
  123|       |
  124|     20|  QualType FromType = Cast->getSubExpr()->getType();
  125|     20|  QualType ToType = Cast->getType();
  126|       |
  127|     20|  if (!isSignificantConversion(FromType, ToType, *Result.Context))
  ------------------
  |  Branch (127:7): [True: 7, False: 13]
  ------------------
  128|      7|    return;
  129|       |
  130|     13|  diag(Cast->getBeginLoc(),
  131|     13|       "implicit conversion from %0 to %1; consider using an explicit cast")
  132|     13|      << FromType << ToType;
  133|     13|}
  134|       |
  135|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidImplicitConversionOperatorCheck.h:
    1|       |//===--- AvoidImplicitConversionOperatorCheck.h - clang-tidy ----*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONOPERATORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONOPERATORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-classes
   17|       |/// @brief Detects non-explicit conversion operators.
   18|       |///
   19|       |/// Implicit conversion operators can lead to unexpected type conversions and
   20|       |/// make code harder to understand. Conversion operators should be marked
   21|       |/// explicit to require an explicit cast.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 15.1.2
   24|       |/// Conversion operators shall be explicit.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   class Wrapper {
   30|       |///     int value;
   31|       |///   public:
   32|       |///     operator int() { return value; }  // Warning: should be explicit
   33|       |///   };
   34|       |/// @endcode
   35|       |class AvoidImplicitConversionOperatorCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  AvoidImplicitConversionOperatorCheck(StringRef Name,
   38|       |                                       ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|    131|  ~AvoidImplicitConversionOperatorCheck() override = default;
   42|       |
   43|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   44|    131|    return LangOpts.CPlusPlus11; // explicit conversion operators require C++11
   45|    131|  }
   46|       |
   47|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDIMPLICITCONVERSIONOPERATORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/ExplicitConstructorCheck.h:
    1|       |//===--- ExplicitConstructorCheck.h - clang-tidy ----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_EXPLICITCONSTRUCTORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_EXPLICITCONSTRUCTORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-classes
   17|       |/// @brief Detects constructors that should be marked explicit.
   18|       |///
   19|       |/// Single-argument constructors and constructors with default arguments that
   20|       |/// can be called with a single argument should be marked explicit to prevent
   21|       |/// unintended implicit conversions.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 15.1.3
   24|       |/// All constructors that are callable with a single argument of a different
   25|       |/// type shall be declared explicit.
   26|       |/// @par Category: Required
   27|       |///
   28|       |/// Example:
   29|       |/// @code
   30|       |///   class Foo {
   31|       |///     Foo(int x);  // Warning: should be explicit
   32|       |///     explicit Foo(double y);  // OK
   33|       |///   };
   34|       |/// @endcode
   35|       |class ExplicitConstructorCheck : public ClangTidyCheck {
   36|       |public:
   37|       |  /// Constructs the check with the given name and context.
   38|       |  /// \param Name The name of the check as registered.
   39|       |  /// \param Context The clang-tidy context for configuration.
   40|       |  ExplicitConstructorCheck(StringRef Name, ClangTidyContext *Context)
   41|    131|      : ClangTidyCheck(Name, Context) {}
   42|       |
   43|       |  /// Destructor.
   44|    131|  ~ExplicitConstructorCheck() override = default;
   45|       |
   46|       |  /// Determines if this check is language-version sensitive.
   47|       |  /// \param LangOpts Language options to check.
   48|       |  /// \return true if the check is applicable to C++.
   49|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   50|    131|    return LangOpts.CPlusPlus;
   51|    131|  }
   52|       |
   53|       |  /// Registers AST matchers for non-explicit single-argument constructors.
   54|       |  /// \param Finder The match finder to register matchers with.
   55|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   56|       |
   57|       |  /// Handles matched constructors and emits diagnostics.
   58|       |  /// \param Result The match result containing the matched AST node.
   59|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   60|       |};
   61|       |
   62|       |} // namespace clang::tidy::automotive
   63|       |
   64|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_EXPLICITCONSTRUCTORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidDynamicCastCheck.h:
    1|       |//===--- AvoidDynamicCastCheck.h - clang-tidy -------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDDYNAMICCASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDDYNAMICCASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects usage of dynamic_cast.
   18|       |///
   19|       |/// dynamic_cast relies on RTTI and can fail at runtime, throwing std::bad_cast
   20|       |/// for references or returning nullptr for pointers. In safety-critical
   21|       |/// systems, the runtime overhead and potential for failure make it undesirable.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 8.2.5
   24|       |/// dynamic_cast should not be used.
   25|       |/// @par Category: Advisory
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   Base* base = new Derived();
   30|       |///   Derived* d = dynamic_cast<Derived*>(base);  // Warning: dynamic_cast used
   31|       |/// @endcode
   32|       |class AvoidDynamicCastCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  AvoidDynamicCastCheck(StringRef Name, ClangTidyContext *Context)
   35|    131|      : ClangTidyCheck(Name, Context) {}
   36|       |
   37|    131|  ~AvoidDynamicCastCheck() override = default;
   38|       |
   39|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   40|    131|    return LangOpts.CPlusPlus;
   41|    131|  }
   42|       |
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDDYNAMICCASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/ExplicitConstructorCheck.cpp:
    1|       |//===--- ExplicitConstructorCheck.cpp - clang-tidy ------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ExplicitConstructorCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void ExplicitConstructorCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match non-explicit constructors
   22|     17|  Finder->addMatcher(cxxConstructorDecl(unless(isExplicit()),
   23|     17|                                        unless(isImplicit()),
   24|     17|                                        unless(isCopyConstructor()),
   25|     17|                                        unless(isMoveConstructor()))
   26|     17|                         .bind("ctor"),
   27|     17|                     this);
   28|     17|}
   29|       |
   30|    588|void ExplicitConstructorCheck::check(const MatchFinder::MatchResult &Result) {
   31|    588|  const auto *Ctor = Result.Nodes.getNodeAs<CXXConstructorDecl>("ctor");
   32|    588|  if (!Ctor)
  ------------------
  |  Branch (32:7): [True: 0, False: 588]
  ------------------
   33|      0|    return;
   34|       |
   35|       |  // Skip system headers
   36|    588|  if (Result.SourceManager->isInSystemHeader(Ctor->getLocation()))
  ------------------
  |  Branch (36:7): [True: 574, False: 14]
  ------------------
   37|    574|    return;
   38|       |
   39|       |  // Skip deleted constructors
   40|     14|  if (Ctor->isDeleted())
  ------------------
  |  Branch (40:7): [True: 0, False: 14]
  ------------------
   41|      0|    return;
   42|       |
   43|       |  // Skip default constructors (no parameters)
   44|     14|  if (Ctor->getNumParams() == 0)
  ------------------
  |  Branch (44:7): [True: 7, False: 7]
  ------------------
   45|      7|    return;
   46|       |
   47|       |  // Count required parameters (those without defaults)
   48|      7|  unsigned RequiredParams = 0;
   49|     13|  for (const auto *Param : Ctor->parameters()) {
  ------------------
  |  Branch (49:26): [True: 13, False: 7]
  ------------------
   50|     13|    if (!Param->hasDefaultArg())
  ------------------
  |  Branch (50:9): [True: 10, False: 3]
  ------------------
   51|     10|      RequiredParams++;
   52|     13|  }
   53|       |
   54|       |  // Check if constructor can be called with a single argument
   55|      7|  bool CanBeCalledWithSingleArg =
   56|      7|      (Ctor->getNumParams() == 1) ||
  ------------------
  |  Branch (56:7): [True: 3, False: 4]
  ------------------
   57|      7|      (RequiredParams <= 1 && Ctor->getNumParams() > 0);
  ------------------
  |  Branch (57:8): [True: 2, False: 2]
  |  Branch (57:31): [True: 2, False: 0]
  ------------------
   58|       |
   59|      7|  if (!CanBeCalledWithSingleArg)
  ------------------
  |  Branch (59:7): [True: 2, False: 5]
  ------------------
   60|      2|    return;
   61|       |
   62|       |  // Get the parameter type for the message
   63|      5|  QualType ParamType = Ctor->getParamDecl(0)->getType();
   64|       |
   65|       |  // Skip if the parameter type is the same as or derived from the class type
   66|      5|  const CXXRecordDecl *ParentClass = Ctor->getParent();
   67|      5|  QualType ClassType =
   68|      5|      Result.Context->getRecordType(ParentClass).getCanonicalType();
   69|      5|  QualType CanonParamType = ParamType.getNonReferenceType().getCanonicalType();
   70|       |
   71|       |  // Allow implicit copy/move from same type
   72|      5|  if (CanonParamType == ClassType)
  ------------------
  |  Branch (72:7): [True: 0, False: 5]
  ------------------
   73|      0|    return;
   74|       |
   75|      5|  diag(Ctor->getLocation(),
   76|      5|       "single-argument constructor should be marked explicit to prevent "
   77|      5|       "implicit conversions from %0")
   78|      5|      << ParamType;
   79|      5|}
   80|       |
   81|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/UnconstrainedTemplateCheck.cpp:
    1|       |//===--- UnconstrainedTemplateCheck.cpp - clang-tidy ----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnconstrainedTemplateCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/AST/RecursiveASTVisitor.h"
   12|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |namespace {
   19|       |// Helper visitor to check for static_assert in function bodies
   20|       |class StaticAssertFinder : public RecursiveASTVisitor<StaticAssertFinder> {
   21|       |public:
   22|       |  bool Found = false;
   23|       |
   24|      1|  bool VisitStaticAssertDecl(StaticAssertDecl *) {
   25|      1|    Found = true;
   26|      1|    return false; // Stop traversal
   27|      1|  }
   28|       |};
   29|       |} // namespace
   30|       |
   31|     17|void UnconstrainedTemplateCheck::registerMatchers(MatchFinder *Finder) {
   32|       |  // Match function templates
   33|     17|  Finder->addMatcher(functionTemplateDecl(unless(isExpansionInSystemHeader()))
   34|     17|                         .bind("funcTemplate"),
   35|     17|                     this);
   36|       |
   37|       |  // Match class templates
   38|     17|  Finder->addMatcher(classTemplateDecl(unless(isExpansionInSystemHeader()))
   39|     17|                         .bind("classTemplate"),
   40|     17|                     this);
   41|     17|}
   42|       |
   43|       |bool UnconstrainedTemplateCheck::hasConstraints(
   44|      3|    const FunctionTemplateDecl *FTD) const {
   45|       |  // Check if template has requires clause
   46|      3|  if (const auto *FD = FTD->getTemplatedDecl()) {
  ------------------
  |  Branch (46:19): [True: 3, False: 0]
  ------------------
   47|      3|    if (FD->getTrailingRequiresClause())
  ------------------
  |  Branch (47:9): [True: 0, False: 3]
  ------------------
   48|      0|      return true;
   49|      3|  }
   50|       |
   51|       |  // Check template parameters for constraints
   52|      3|  const auto *TPL = FTD->getTemplateParameters();
   53|      3|  if (!TPL)
  ------------------
  |  Branch (53:7): [True: 0, False: 3]
  ------------------
   54|      0|    return false;
   55|       |
   56|      3|  for (const auto *Param : *TPL) {
  ------------------
  |  Branch (56:26): [True: 3, False: 2]
  ------------------
   57|       |    // Check for constrained type parameters (concepts)
   58|      3|    if (const auto *TTPD = dyn_cast<TemplateTypeParmDecl>(Param)) {
  ------------------
  |  Branch (58:21): [True: 2, False: 1]
  ------------------
   59|      2|      if (TTPD->hasTypeConstraint())
  ------------------
  |  Branch (59:11): [True: 0, False: 2]
  ------------------
   60|      0|        return true;
   61|      2|    }
   62|       |    // Non-type template parameters are inherently constrained
   63|      3|    if (isa<NonTypeTemplateParmDecl>(Param))
  ------------------
  |  Branch (63:9): [True: 1, False: 2]
  ------------------
   64|      1|      return true;
   65|      3|  }
   66|       |
   67|      2|  return false;
   68|      3|}
   69|       |
   70|       |bool UnconstrainedTemplateCheck::hasConstraints(
   71|      2|    const ClassTemplateDecl *CTD) const {
   72|       |  // Check template parameters for constraints
   73|      2|  const auto *TPL = CTD->getTemplateParameters();
   74|      2|  if (!TPL)
  ------------------
  |  Branch (74:7): [True: 0, False: 2]
  ------------------
   75|      0|    return false;
   76|       |
   77|      2|  for (const auto *Param : *TPL) {
  ------------------
  |  Branch (77:26): [True: 2, False: 2]
  ------------------
   78|       |    // Check for constrained type parameters (concepts)
   79|      2|    if (const auto *TTPD = dyn_cast<TemplateTypeParmDecl>(Param)) {
  ------------------
  |  Branch (79:21): [True: 2, False: 0]
  ------------------
   80|      2|      if (TTPD->hasTypeConstraint())
  ------------------
  |  Branch (80:11): [True: 0, False: 2]
  ------------------
   81|      0|        return true;
   82|      2|    }
   83|       |    // Non-type template parameters are inherently constrained
   84|      2|    if (isa<NonTypeTemplateParmDecl>(Param))
  ------------------
  |  Branch (84:9): [True: 0, False: 2]
  ------------------
   85|      0|      return true;
   86|      2|  }
   87|       |
   88|       |  // Check if the templated class has a requires clause
   89|      2|  if (const auto *RD = CTD->getTemplatedDecl()) {
  ------------------
  |  Branch (89:19): [True: 2, False: 0]
  ------------------
   90|       |    // Check for static_assert in the class body
   91|      4|    for (const auto *D : RD->decls()) {
  ------------------
  |  Branch (91:24): [True: 4, False: 1]
  ------------------
   92|      4|      if (isa<StaticAssertDecl>(D))
  ------------------
  |  Branch (92:11): [True: 1, False: 3]
  ------------------
   93|      1|        return true;
   94|      4|    }
   95|      2|  }
   96|       |
   97|      1|  return false;
   98|      2|}
   99|       |
  100|      2|bool UnconstrainedTemplateCheck::hasStaticAssert(const FunctionDecl *FD) const {
  101|      2|  if (!FD->hasBody())
  ------------------
  |  Branch (101:7): [True: 0, False: 2]
  ------------------
  102|      0|    return false;
  103|       |
  104|      2|  StaticAssertFinder Finder;
  105|      2|  Finder.TraverseStmt(FD->getBody());
  106|      2|  return Finder.Found;
  107|      2|}
  108|       |
  109|      5|void UnconstrainedTemplateCheck::check(const MatchFinder::MatchResult &Result) {
  110|      5|  if (const auto *FTD =
  ------------------
  |  Branch (110:19): [True: 3, False: 2]
  ------------------
  111|      5|          Result.Nodes.getNodeAs<FunctionTemplateDecl>("funcTemplate")) {
  112|       |    // Skip if template has constraints
  113|      3|    if (hasConstraints(FTD))
  ------------------
  |  Branch (113:9): [True: 1, False: 2]
  ------------------
  114|      1|      return;
  115|       |
  116|       |    // Skip if function body has static_assert
  117|      2|    if (const auto *FD = FTD->getTemplatedDecl()) {
  ------------------
  |  Branch (117:21): [True: 2, False: 0]
  ------------------
  118|      2|      if (hasStaticAssert(FD))
  ------------------
  |  Branch (118:11): [True: 1, False: 1]
  ------------------
  119|      1|        return;
  120|       |
  121|       |      // Skip member functions of class templates (class already handles
  122|       |      // constraints)
  123|      1|      if (FD->isCXXClassMember())
  ------------------
  |  Branch (123:11): [True: 0, False: 1]
  ------------------
  124|      0|        return;
  125|       |
  126|       |      // Skip operator overloads
  127|      1|      if (FD->isOverloadedOperator())
  ------------------
  |  Branch (127:11): [True: 0, False: 1]
  ------------------
  128|      0|        return;
  129|      1|    }
  130|       |
  131|      1|    diag(FTD->getLocation(),
  132|      1|         "function template %0 has unconstrained type parameters; consider "
  133|      1|         "using concepts or static_assert")
  134|      1|        << FTD;
  135|      1|    return;
  136|      2|  }
  137|       |
  138|      2|  if (const auto *CTD =
  ------------------
  |  Branch (138:19): [True: 2, False: 0]
  ------------------
  139|      2|          Result.Nodes.getNodeAs<ClassTemplateDecl>("classTemplate")) {
  140|       |    // Skip if template has constraints
  141|      2|    if (hasConstraints(CTD))
  ------------------
  |  Branch (141:9): [True: 1, False: 1]
  ------------------
  142|      1|      return;
  143|       |
  144|      1|    diag(CTD->getLocation(),
  145|      1|         "class template %0 has unconstrained type parameters; consider "
  146|      1|         "using concepts or static_assert")
  147|      1|        << CTD;
  148|      1|  }
  149|      2|}
  150|       |
  151|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidConstCastCheck.h:
    1|       |//===--- AvoidConstCastCheck.h - clang-tidy ---------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCONSTCASTCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCONSTCASTCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-expressions
   17|       |/// @brief Detects usage of const_cast.
   18|       |///
   19|       |/// const_cast can be used to cast away const or volatile qualifiers, which
   20|       |/// can lead to undefined behavior if the underlying object is actually const.
   21|       |/// It should be avoided in safety-critical code.
   22|       |///
   23|       |/// @par MISRA C++:2023 Rule 8.2.3
   24|       |/// const_cast shall not be used.
   25|       |/// @par Category: Required
   26|       |///
   27|       |/// Example:
   28|       |/// @code
   29|       |///   const int x = 42;
   30|       |///   int* p = const_cast<int*>(&x);  // Warning
   31|       |///   *p = 10;  // Undefined behavior!
   32|       |/// @endcode
   33|       |class AvoidConstCastCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  AvoidConstCastCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|    131|  ~AvoidConstCastCheck() override = default;
   39|       |
   40|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   41|    131|    return LangOpts.CPlusPlus;
   42|    131|  }
   43|       |
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   46|       |};
   47|       |
   48|       |} // namespace clang::tidy::automotive
   49|       |
   50|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDCONSTCASTCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/RuleOfFiveCheck.cpp:
    1|       |//===--- RuleOfFiveCheck.cpp - clang-tidy ---------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "RuleOfFiveCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void RuleOfFiveCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus11)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match class/struct definitions
   22|     17|  Finder->addMatcher(cxxRecordDecl(isDefinition()).bind("class"), this);
   23|     17|}
   24|       |
   25|  2.44k|void RuleOfFiveCheck::check(const MatchFinder::MatchResult &Result) {
   26|  2.44k|  const auto *ClassDecl = Result.Nodes.getNodeAs<CXXRecordDecl>("class");
   27|  2.44k|  if (!ClassDecl)
  ------------------
  |  Branch (27:7): [True: 0, False: 2.44k]
  ------------------
   28|      0|    return;
   29|       |
   30|       |  // Skip system headers
   31|  2.44k|  if (Result.SourceManager->isInSystemHeader(ClassDecl->getLocation()))
  ------------------
  |  Branch (31:7): [True: 2.39k, False: 54]
  ------------------
   32|  2.39k|    return;
   33|       |
   34|       |  // Skip implicit/compiler-generated classes
   35|     54|  if (ClassDecl->isImplicit())
  ------------------
  |  Branch (35:7): [True: 0, False: 54]
  ------------------
   36|      0|    return;
   37|       |
   38|       |  // Skip templates - they're checked when instantiated
   39|     54|  if (ClassDecl->getDescribedClassTemplate())
  ------------------
  |  Branch (39:7): [True: 2, False: 52]
  ------------------
   40|      2|    return;
   41|       |
   42|       |  // Check which special members are user-declared
   43|     52|  bool HasUserDeclaredDestructor = ClassDecl->hasUserDeclaredDestructor();
   44|     52|  bool HasUserDeclaredCopyConstructor =
   45|     52|      ClassDecl->hasUserDeclaredCopyConstructor();
   46|     52|  bool HasUserDeclaredCopyAssignment =
   47|     52|      ClassDecl->hasUserDeclaredCopyAssignment();
   48|     52|  bool HasUserDeclaredMoveConstructor =
   49|     52|      ClassDecl->hasUserDeclaredMoveConstructor();
   50|     52|  bool HasUserDeclaredMoveAssignment =
   51|     52|      ClassDecl->hasUserDeclaredMoveAssignment();
   52|       |
   53|       |  // Count how many are user-declared
   54|     52|  int DeclaredCount = 0;
   55|     52|  if (HasUserDeclaredDestructor)
  ------------------
  |  Branch (55:7): [True: 21, False: 31]
  ------------------
   56|     21|    DeclaredCount++;
   57|     52|  if (HasUserDeclaredCopyConstructor)
  ------------------
  |  Branch (57:7): [True: 6, False: 46]
  ------------------
   58|      6|    DeclaredCount++;
   59|     52|  if (HasUserDeclaredCopyAssignment)
  ------------------
  |  Branch (59:7): [True: 2, False: 50]
  ------------------
   60|      2|    DeclaredCount++;
   61|     52|  if (HasUserDeclaredMoveConstructor)
  ------------------
  |  Branch (61:7): [True: 7, False: 45]
  ------------------
   62|      7|    DeclaredCount++;
   63|     52|  if (HasUserDeclaredMoveAssignment)
  ------------------
  |  Branch (63:7): [True: 6, False: 46]
  ------------------
   64|      6|    DeclaredCount++;
   65|       |
   66|       |  // If none or all five are declared, the rule is satisfied
   67|     52|  if (DeclaredCount == 0 || DeclaredCount == 5)
  ------------------
  |  Branch (67:7): [True: 22, False: 30]
  |  Branch (67:29): [True: 1, False: 29]
  ------------------
   68|     23|    return;
   69|       |
   70|       |  // Build list of missing members
   71|     29|  llvm::SmallVector<StringRef, 5> Missing;
   72|     29|  if (!HasUserDeclaredDestructor)
  ------------------
  |  Branch (72:7): [True: 9, False: 20]
  ------------------
   73|      9|    Missing.push_back("destructor");
   74|     29|  if (!HasUserDeclaredCopyConstructor)
  ------------------
  |  Branch (74:7): [True: 24, False: 5]
  ------------------
   75|     24|    Missing.push_back("copy constructor");
   76|     29|  if (!HasUserDeclaredCopyAssignment)
  ------------------
  |  Branch (76:7): [True: 28, False: 1]
  ------------------
   77|     28|    Missing.push_back("copy assignment operator");
   78|     29|  if (!HasUserDeclaredMoveConstructor)
  ------------------
  |  Branch (78:7): [True: 23, False: 6]
  ------------------
   79|     23|    Missing.push_back("move constructor");
   80|     29|  if (!HasUserDeclaredMoveAssignment)
  ------------------
  |  Branch (80:7): [True: 24, False: 5]
  ------------------
   81|     24|    Missing.push_back("move assignment operator");
   82|       |
   83|       |  // Build list of declared members
   84|     29|  llvm::SmallVector<StringRef, 5> Declared;
   85|     29|  if (HasUserDeclaredDestructor)
  ------------------
  |  Branch (85:7): [True: 20, False: 9]
  ------------------
   86|     20|    Declared.push_back("destructor");
   87|     29|  if (HasUserDeclaredCopyConstructor)
  ------------------
  |  Branch (87:7): [True: 5, False: 24]
  ------------------
   88|      5|    Declared.push_back("copy constructor");
   89|     29|  if (HasUserDeclaredCopyAssignment)
  ------------------
  |  Branch (89:7): [True: 1, False: 28]
  ------------------
   90|      1|    Declared.push_back("copy assignment operator");
   91|     29|  if (HasUserDeclaredMoveConstructor)
  ------------------
  |  Branch (91:7): [True: 6, False: 23]
  ------------------
   92|      6|    Declared.push_back("move constructor");
   93|     29|  if (HasUserDeclaredMoveAssignment)
  ------------------
  |  Branch (93:7): [True: 5, False: 24]
  ------------------
   94|      5|    Declared.push_back("move assignment operator");
   95|       |
   96|       |  // Format the message
   97|     29|  std::string DeclaredStr;
   98|     66|  for (size_t I = 0; I < Declared.size(); ++I) {
  ------------------
  |  Branch (98:22): [True: 37, False: 29]
  ------------------
   99|     37|    if (I > 0) {
  ------------------
  |  Branch (99:9): [True: 8, False: 29]
  ------------------
  100|      8|      if (I == Declared.size() - 1)
  ------------------
  |  Branch (100:11): [True: 8, False: 0]
  ------------------
  101|      8|        DeclaredStr += " and ";
  102|      0|      else
  103|      0|        DeclaredStr += ", ";
  104|      8|    }
  105|     37|    DeclaredStr += Declared[I];
  106|     37|  }
  107|       |
  108|     29|  std::string MissingStr;
  109|    137|  for (size_t I = 0; I < Missing.size(); ++I) {
  ------------------
  |  Branch (109:22): [True: 108, False: 29]
  ------------------
  110|    108|    if (I > 0) {
  ------------------
  |  Branch (110:9): [True: 79, False: 29]
  ------------------
  111|     79|      if (I == Missing.size() - 1)
  ------------------
  |  Branch (111:11): [True: 29, False: 50]
  ------------------
  112|     29|        MissingStr += " and ";
  113|     50|      else
  114|     50|        MissingStr += ", ";
  115|     79|    }
  116|    108|    MissingStr += Missing[I];
  117|    108|  }
  118|       |
  119|     29|  diag(ClassDecl->getLocation(),
  120|     29|       "class %0 defines %1 but is missing %2; consider defining all five "
  121|     29|       "special member functions (Rule of Five)")
  122|     29|      << ClassDecl << DeclaredStr << MissingStr;
  123|     29|}
  124|       |
  125|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidImplicitConversionOperatorCheck.cpp:
    1|       |//===--- AvoidImplicitConversionOperatorCheck.cpp - clang-tidy ------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidImplicitConversionOperatorCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void AvoidImplicitConversionOperatorCheck::registerMatchers(
   18|     17|    MatchFinder *Finder) {
   19|     17|  if (!getLangOpts().CPlusPlus11)
  ------------------
  |  Branch (19:7): [True: 0, False: 17]
  ------------------
   20|      0|    return;
   21|       |
   22|       |  // Match conversion operators that are not explicit
   23|     17|  Finder->addMatcher(cxxConversionDecl(unless(isExplicit())).bind("conversion"),
   24|     17|                     this);
   25|     17|}
   26|       |
   27|       |void AvoidImplicitConversionOperatorCheck::check(
   28|     26|    const MatchFinder::MatchResult &Result) {
   29|     26|  const auto *Conversion =
   30|     26|      Result.Nodes.getNodeAs<CXXConversionDecl>("conversion");
   31|     26|  if (!Conversion)
  ------------------
  |  Branch (31:7): [True: 0, False: 26]
  ------------------
   32|      0|    return;
   33|       |
   34|       |  // Skip system headers
   35|     26|  if (Result.SourceManager->isInSystemHeader(Conversion->getLocation()))
  ------------------
  |  Branch (35:7): [True: 24, False: 2]
  ------------------
   36|     24|    return;
   37|       |
   38|       |  // Skip implicit/compiler-generated conversions
   39|      2|  if (Conversion->isImplicit())
  ------------------
  |  Branch (39:7): [True: 0, False: 2]
  ------------------
   40|      0|    return;
   41|       |
   42|       |  // Skip deleted conversions
   43|      2|  if (Conversion->isDeleted())
  ------------------
  |  Branch (43:7): [True: 0, False: 2]
  ------------------
   44|      0|    return;
   45|       |
   46|       |  // Get the conversion target type for the message
   47|      2|  QualType ConvType = Conversion->getConversionType();
   48|       |
   49|      2|  diag(Conversion->getLocation(),
   50|      2|       "conversion operator to %0 should be explicit to avoid unintended "
   51|      2|       "implicit conversions")
   52|      2|      << ConvType
   53|      2|      << FixItHint::CreateInsertion(Conversion->getLocation(), "explicit ");
   54|      2|}
   55|       |
   56|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidThrowInNoexceptCheck.cpp:
    1|       |//===--- AvoidThrowInNoexceptCheck.cpp - clang-tidy -----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidThrowInNoexceptCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidThrowInNoexceptCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus11)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match throw expressions inside noexcept functions
   22|     17|  Finder->addMatcher(
   23|     17|      cxxThrowExpr(hasAncestor(functionDecl(isNoThrow()).bind("func")))
   24|     17|          .bind("throw"),
   25|     17|      this);
   26|     17|}
   27|       |
   28|      5|void AvoidThrowInNoexceptCheck::check(const MatchFinder::MatchResult &Result) {
   29|      5|  const auto *Throw = Result.Nodes.getNodeAs<CXXThrowExpr>("throw");
   30|      5|  const auto *Func = Result.Nodes.getNodeAs<FunctionDecl>("func");
   31|       |
   32|       |  // LCOV_EXCL_START - defensive check, matcher guarantees these exist
   33|      5|  if (!Throw || !Func)
  ------------------
  |  Branch (33:7): [True: 0, False: 5]
  |  Branch (33:17): [True: 0, False: 5]
  ------------------
   34|      0|    return;
   35|       |  // LCOV_EXCL_STOP
   36|       |
   37|       |  // Skip system headers
   38|      5|  if (Result.SourceManager->isInSystemHeader(Throw->getThrowLoc()))
  ------------------
  |  Branch (38:7): [True: 0, False: 5]
  ------------------
   39|      0|    return;
   40|       |
   41|      5|  diag(Throw->getThrowLoc(),
   42|      5|       "throw expression in noexcept function %0 will call std::terminate if "
   43|      5|       "exception propagates")
   44|      5|      << Func;
   45|      5|}
   46|       |
   47|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidSlicingCheck.h:
    1|       |//===--- AvoidSlicingCheck.h - clang-tidy ----------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDSLICINGCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDSLICINGCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-cpp23-classes
   17|       |/// @brief Detects object slicing when passing derived class objects to base
   18|       |/// class by value.
   19|       |///
   20|       |/// Object slicing occurs when a derived class object is assigned to a base
   21|       |/// class object by value. The derived class portions are "sliced off" and
   22|       |/// only the base class portion remains, often leading to unexpected behavior.
   23|       |///
   24|       |/// @par MISRA C++:2023 Rule 15.3.1
   25|       |/// An object shall not be copy-constructed or copy-assigned such that
   26|       |/// slicing occurs.
   27|       |/// @par Category: Required
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   class Base { int x; };
   32|       |///   class Derived : public Base { int y; };
   33|       |///   void func(Base b) { }  // Pass by value
   34|       |///   Derived d;
   35|       |///   func(d);  // Warning: object slicing occurs
   36|       |/// @endcode
   37|       |class AvoidSlicingCheck : public ClangTidyCheck {
   38|       |public:
   39|       |  /// Constructs the check with the given name and context.
   40|       |  /// \param Name The name of the check as registered.
   41|       |  /// \param Context The clang-tidy context for configuration.
   42|       |  AvoidSlicingCheck(StringRef Name, ClangTidyContext *Context)
   43|    131|      : ClangTidyCheck(Name, Context) {}
   44|       |
   45|       |  /// Destructor.
   46|    131|  ~AvoidSlicingCheck() override = default;
   47|       |
   48|       |  /// Determines if this check is language-version sensitive.
   49|       |  /// \param LangOpts Language options to check.
   50|       |  /// \return true if the check is applicable to C++.
   51|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   52|    131|    return LangOpts.CPlusPlus;
   53|    131|  }
   54|       |
   55|       |  /// Registers AST matchers for object slicing scenarios.
   56|       |  /// \param Finder The match finder to register matchers with.
   57|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   58|       |
   59|       |  /// Handles matched slicing operations and emits diagnostics.
   60|       |  /// \param Result The match result containing the matched AST node.
   61|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   62|       |};
   63|       |
   64|       |} // namespace clang::tidy::automotive
   65|       |
   66|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_CPP23_AVOIDSLICINGCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/cpp23/AvoidThrowingDestructorCheck.cpp:
    1|       |//===--- AvoidThrowingDestructorCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidThrowingDestructorCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|     17|void AvoidThrowingDestructorCheck::registerMatchers(MatchFinder *Finder) {
   18|     17|  if (!getLangOpts().CPlusPlus)
  ------------------
  |  Branch (18:7): [True: 0, False: 17]
  ------------------
   19|      0|    return;
   20|       |
   21|       |  // Match throw expressions inside destructors
   22|     17|  Finder->addMatcher(
   23|     17|      cxxThrowExpr(hasAncestor(cxxDestructorDecl().bind("destructor")))
   24|     17|          .bind("throw"),
   25|     17|      this);
   26|       |
   27|       |  // Also match destructors that are not noexcept (in C++11 and later,
   28|       |  // destructors should be implicitly noexcept)
   29|     17|  Finder->addMatcher(
   30|     17|      cxxDestructorDecl(unless(isNoThrow())).bind("non_noexcept_dtor"), this);
   31|     17|}
   32|       |
   33|       |void AvoidThrowingDestructorCheck::check(
   34|     19|    const MatchFinder::MatchResult &Result) {
   35|       |  // Check for throw expressions in destructors
   36|     19|  if (const auto *Throw = Result.Nodes.getNodeAs<CXXThrowExpr>("throw")) {
  ------------------
  |  Branch (36:19): [True: 2, False: 17]
  ------------------
   37|      2|    const auto *Dtor = Result.Nodes.getNodeAs<CXXDestructorDecl>("destructor");
   38|       |
   39|      2|    if (Result.SourceManager->isInSystemHeader(Throw->getThrowLoc()))
  ------------------
  |  Branch (39:9): [True: 0, False: 2]
  ------------------
   40|      0|      return;
   41|       |
   42|      2|    diag(Throw->getThrowLoc(),
   43|      2|         "throw expression in destructor %0; destructors should not throw "
   44|      2|         "exceptions")
   45|      2|        << Dtor;
   46|      2|    return;
   47|      2|  }
   48|       |
   49|       |  // Check for non-noexcept destructors
   50|     17|  if (const auto *Dtor =
  ------------------
  |  Branch (50:19): [True: 17, False: 0]
  ------------------
   51|     17|          Result.Nodes.getNodeAs<CXXDestructorDecl>("non_noexcept_dtor")) {
   52|     17|    if (Result.SourceManager->isInSystemHeader(Dtor->getLocation()))
  ------------------
  |  Branch (52:9): [True: 16, False: 1]
  ------------------
   53|     16|      return;
   54|       |
   55|       |    // Skip if destructor is defaulted or deleted
   56|      1|    if (Dtor->isDefaulted() || Dtor->isDeleted())
  ------------------
  |  Branch (56:9): [True: 0, False: 1]
  |  Branch (56:32): [True: 0, False: 1]
  ------------------
   57|      0|      return;
   58|       |
   59|       |    // Skip if destructor is implicitly generated
   60|      1|    if (Dtor->isImplicit())
  ------------------
  |  Branch (60:9): [True: 0, False: 1]
  ------------------
   61|      0|      return;
   62|       |
   63|       |    // In C++11 and later, user-declared destructors should be noexcept
   64|       |    // unless they explicitly specify otherwise
   65|      1|    const auto *ExceptionSpec = Dtor->getType()->getAs<FunctionProtoType>();
   66|       |    // LCOV_EXCL_START - defensive check, destructor always has prototype
   67|      1|    if (!ExceptionSpec)
  ------------------
  |  Branch (67:9): [True: 0, False: 1]
  ------------------
   68|      0|      return;
   69|       |    // LCOV_EXCL_STOP
   70|       |
   71|       |    // If the destructor has an explicit non-noexcept specification, warn
   72|      1|    if (ExceptionSpec->hasExceptionSpec() &&
  ------------------
  |  Branch (72:9): [True: 1, False: 0]
  ------------------
   73|      1|        ExceptionSpec->getExceptionSpecType() != EST_NoThrow &&
  ------------------
  |  Branch (73:9): [True: 1, False: 0]
  ------------------
   74|      1|        ExceptionSpec->getExceptionSpecType() != EST_BasicNoexcept &&
  ------------------
  |  Branch (74:9): [True: 1, False: 0]
  ------------------
   75|      1|        ExceptionSpec->getExceptionSpecType() != EST_NoexceptTrue) {
  ------------------
  |  Branch (75:9): [True: 1, False: 0]
  ------------------
   76|      1|      diag(Dtor->getLocation(),
   77|      1|           "destructor %0 has exception specification that may throw; "
   78|      1|           "destructors should be noexcept")
   79|      1|          << Dtor;
   80|      1|    }
   81|      1|  }
   82|     17|}
   83|       |
   84|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/operator/WrongShiftOperandCheck.cpp:
    1|       |//===--- WrongShiftOperandCheck.cpp - clang-tidy --------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "WrongShiftOperandCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void WrongShiftOperandCheck::registerMatchers(MatchFinder *Finder) {
   18|       |  // Match left and right shift operators
   19|    131|  Finder->addMatcher(
   20|    131|      binaryOperator(hasAnyOperatorName("<<", ">>", "<<=", ">>="))
   21|    131|          .bind("shift"),
   22|    131|      this);
   23|    131|}
   24|       |
   25|    224|void WrongShiftOperandCheck::check(const MatchFinder::MatchResult &Result) {
   26|    224|  const auto *ShiftOp = Result.Nodes.getNodeAs<BinaryOperator>("shift");
   27|    224|  if (!ShiftOp)
  ------------------
  |  Branch (27:7): [True: 0, False: 224]
  ------------------
   28|      0|    return;
   29|       |
   30|       |  // Skip if in system header
   31|    224|  if (Result.SourceManager->isInSystemHeader(ShiftOp->getOperatorLoc()))
  ------------------
  |  Branch (31:7): [True: 188, False: 36]
  ------------------
   32|    188|    return;
   33|       |
   34|     36|  const Expr *LHS = ShiftOp->getLHS()->IgnoreParenImpCasts();
   35|     36|  const Expr *RHS = ShiftOp->getRHS()->IgnoreParenImpCasts();
   36|       |
   37|       |  // Get the type of the left operand to determine bit width
   38|     36|  QualType LHSType = LHS->getType();
   39|     36|  if (LHSType.isNull())
  ------------------
  |  Branch (39:7): [True: 0, False: 36]
  ------------------
   40|      0|    return;
   41|       |
   42|       |  // Get the bit width of the left operand type
   43|     36|  const ASTContext &Ctx = *Result.Context;
   44|     36|  uint64_t TypeBitWidth = Ctx.getTypeSize(LHSType);
   45|       |
   46|       |  // Try to evaluate the right operand as a constant
   47|     36|  Expr::EvalResult EvalResult;
   48|     36|  if (!RHS->EvaluateAsInt(EvalResult, Ctx))
  ------------------
  |  Branch (48:7): [True: 4, False: 32]
  ------------------
   49|      4|    return; // Can't evaluate at compile time, skip
   50|       |
   51|     32|  llvm::APSInt ShiftAmount = EvalResult.Val.getInt();
   52|       |
   53|       |  // Check for negative shift amount
   54|     32|  if (ShiftAmount.isNegative()) {
  ------------------
  |  Branch (54:7): [True: 0, False: 32]
  ------------------
   55|      0|    diag(RHS->getBeginLoc(),
   56|      0|         "shift amount is negative (%0), which is undefined behavior")
   57|      0|        << static_cast<int>(ShiftAmount.getSExtValue());
   58|      0|    return;
   59|      0|  }
   60|       |
   61|       |  // Check for shift amount >= bit width
   62|     32|  if (ShiftAmount.getZExtValue() >= TypeBitWidth) {
  ------------------
  |  Branch (62:7): [True: 7, False: 25]
  ------------------
   63|      7|    diag(RHS->getBeginLoc(),
   64|      7|         "shift amount (%0) is greater than or equal to the width of the "
   65|      7|         "type (%1 bits)")
   66|      7|        << static_cast<unsigned>(ShiftAmount.getZExtValue())
   67|      7|        << static_cast<unsigned>(TypeBitWidth);
   68|      7|  }
   69|     32|}
   70|       |
   71|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/operator/AvoidCommaOperatorCheck.h:
    1|       |//===--- AvoidCommaOperatorCheck.h - clang-tidy -----------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMAOPERATORCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMAOPERATORCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of the comma operator outside of for loop initialization.
   17|       |///
   18|       |/// The comma operator evaluates multiple expressions sequentially and returns
   19|       |/// the result of the last expression. This can obscure the program's control
   20|       |/// flow and make code harder to understand and maintain. Side effects from
   21|       |/// earlier expressions in a comma sequence may be overlooked during code
   22|       |/// review.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 12.3 - The comma operator should not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int x = (a = 1, b = 2, a + b);  // Warning: comma operator used
   29|       |/// \endcode
   30|       |class AvoidCommaOperatorCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidCommaOperatorCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidCommaOperatorCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for comma operator usage.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched comma operators and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDCOMMAOPERATORCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/operator/AvoidCommaOperatorCheck.cpp:
    1|       |//===--- AvoidCommaOperatorCheck.cpp - clang-tidy -------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidCommaOperatorCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidCommaOperatorCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(binaryOperator(hasOperatorName(",")).bind("commaOp"),
   19|    131|                     this);
   20|    131|}
   21|       |
   22|     30|void AvoidCommaOperatorCheck::check(const MatchFinder::MatchResult &Result) {
   23|     30|  const auto *MatchedCommaOp =
   24|     30|      Result.Nodes.getNodeAs<BinaryOperator>("commaOp");
   25|       |
   26|     30|  if (MatchedCommaOp) {
  ------------------
  |  Branch (26:7): [True: 30, False: 0]
  ------------------
   27|     30|    diag(MatchedCommaOp->getOperatorLoc(), "avoid comma operator");
   28|     30|  }
   29|     30|}
   30|       |
   31|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/operator/OperatorComponent.cpp:
    1|       |//===--- OperatorComponent.cpp - clang-tidy -------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "OperatorComponent.h"
   10|       |#include "AvoidCommaOperatorCheck.h"
   11|       |#include "WrongShiftOperandCheck.h"
   12|       |
   13|       |namespace clang::tidy::automotive {
   14|       |
   15|       |void OperatorComponent::addCheckFactories(
   16|    262|    ClangTidyCheckFactories &CheckFactories) {
   17|       |
   18|    262|  CheckFactories.registerCheck<AvoidCommaOperatorCheck>(
   19|    262|      "automotive-avoid-comma-operator");
   20|       |
   21|       |  // Rule 12.2 - Shift operator bounds (Required)
   22|    262|  CheckFactories.registerCheck<WrongShiftOperandCheck>(
   23|    262|      "automotive-c23-req-12.2");
   24|    262|}
   25|       |
   26|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/operator/WrongShiftOperandCheck.h:
    1|       |//===--- WrongShiftOperandCheck.h - clang-tidy ------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGSHIFTOPERANDCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGSHIFTOPERANDCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-operator
   17|       |/// @brief Detects shift operators with out-of-bounds shift amounts.
   18|       |///
   19|       |/// The right-hand operand of a shift operator shall lie in the range zero to
   20|       |/// one less than the width in bits of the essential type of the left-hand
   21|       |/// operand. Shifting by negative amounts or by amounts equal to or greater
   22|       |/// than the bit width results in undefined behavior.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 12.2
   25|       |/// The right hand operand of a shift operator shall lie in the range zero to
   26|       |/// one less than the width in bits of the essential type of the left hand
   27|       |/// operand.
   28|       |/// @par Category: Required
   29|       |///
   30|       |/// Example:
   31|       |/// @code
   32|       |///   uint32_t x = 1;
   33|       |///   uint32_t y = x << 32;  // Warning: shift amount equals bit width
   34|       |///   uint32_t z = x << -1;  // Warning: negative shift amount
   35|       |///   uint8_t  a = 1;
   36|       |///   uint8_t  b = a << 8;   // Warning: shift amount equals bit width of
   37|       |///   uint8_t
   38|       |/// @endcode
   39|       |class WrongShiftOperandCheck : public ClangTidyCheck {
   40|       |public:
   41|       |  WrongShiftOperandCheck(StringRef Name, ClangTidyContext *Context)
   42|    131|      : ClangTidyCheck(Name, Context) {}
   43|       |
   44|       |  /// Destructor.
   45|    131|  ~WrongShiftOperandCheck() override = default;
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_WRONGSHIFTOPERANDCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidTrigraphCheck.cpp:
    1|       |//===--- AvoidTrigraphCheck.cpp - clang-tidy -----------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidTrigraphCheck.h"
   10|       |#include "clang/Lex/PPCallbacks.h"
   11|       |#include "clang/Lex/Preprocessor.h"
   12|       |
   13|       |namespace clang::tidy::automotive {
   14|       |
   15|       |namespace {
   16|       |
   17|       |class AvoidTrigraphPPCallbacks : public PPCallbacks {
   18|       |public:
   19|       |  AvoidTrigraphPPCallbacks(ClangTidyCheck &Check, const SourceManager &SM)
   20|    131|      : Check(Check), SM(SM) {}
   21|       |
   22|       |  void FileChanged(SourceLocation Loc, FileChangeReason Reason,
   23|       |                   SrcMgr::CharacteristicKind FileType,
   24|  3.21k|                   FileID PrevFID) override {
   25|       |    // Only scan the main file and included files
   26|  3.21k|    if (Reason != EnterFile)
  ------------------
  |  Branch (26:9): [True: 1.65k, False: 1.55k]
  ------------------
   27|  1.65k|      return;
   28|       |
   29|  1.55k|    FileID FID = SM.getFileID(Loc);
   30|  1.55k|    if (!FID.isValid() || ScannedFiles.count(FID))
  ------------------
  |  Branch (30:9): [True: 0, False: 1.55k]
  |  Branch (30:27): [True: 131, False: 1.42k]
  ------------------
   31|    131|      return;
   32|       |
   33|  1.42k|    ScannedFiles.insert(FID);
   34|  1.42k|    scanFileForTrigraphs(FID);
   35|  1.42k|  }
   36|       |
   37|    131|  void EndOfMainFile() override {
   38|       |    // Ensure main file is scanned
   39|    131|    FileID MainFileID = SM.getMainFileID();
   40|       |    // LCOV_EXCL_START - main file is typically scanned via FileChanged first
   41|    131|    if (!ScannedFiles.count(MainFileID)) {
  ------------------
  |  Branch (41:9): [True: 0, False: 131]
  ------------------
   42|      0|      scanFileForTrigraphs(MainFileID);
   43|      0|    }
   44|       |    // LCOV_EXCL_STOP
   45|    131|  }
   46|       |
   47|       |private:
   48|       |  ClangTidyCheck &Check;
   49|       |  const SourceManager &SM;
   50|       |  llvm::DenseSet<FileID> ScannedFiles;
   51|       |
   52|       |  /// Get trigraph replacement character, or '\0' if not a valid trigraph.
   53|       |  // LCOV_EXCL_START - not all trigraph types need test coverage
   54|      1|  static char getTrigraphReplacement(char ThirdChar) {
   55|      1|    switch (ThirdChar) {
   56|      0|    case '=':
  ------------------
  |  Branch (56:5): [True: 0, False: 1]
  ------------------
   57|      0|      return '#';
   58|      0|    case '(':
  ------------------
  |  Branch (58:5): [True: 0, False: 1]
  ------------------
   59|      0|      return '[';
   60|      0|    case ')':
  ------------------
  |  Branch (60:5): [True: 0, False: 1]
  ------------------
   61|      0|      return ']';
   62|      0|    case '<':
  ------------------
  |  Branch (62:5): [True: 0, False: 1]
  ------------------
   63|      0|      return '{';
   64|      0|    case '>':
  ------------------
  |  Branch (64:5): [True: 0, False: 1]
  ------------------
   65|      0|      return '}';
   66|      1|    case '/':
  ------------------
  |  Branch (66:5): [True: 1, False: 0]
  ------------------
   67|      1|      return '\\';
   68|      0|    case '\'':
  ------------------
  |  Branch (68:5): [True: 0, False: 1]
  ------------------
   69|      0|      return '^';
   70|      0|    case '!':
  ------------------
  |  Branch (70:5): [True: 0, False: 1]
  ------------------
   71|      0|      return '|';
   72|      0|    case '-':
  ------------------
  |  Branch (72:5): [True: 0, False: 1]
  ------------------
   73|      0|      return '~';
   74|      0|    default:
  ------------------
  |  Branch (74:5): [True: 0, False: 1]
  ------------------
   75|      0|      return '\0';
   76|      1|    }
   77|      1|  }
   78|       |  // LCOV_EXCL_STOP
   79|       |
   80|  1.42k|  void scanFileForTrigraphs(FileID FID) {
   81|  1.42k|    bool Invalid = false;
   82|  1.42k|    StringRef Buffer = SM.getBufferData(FID, &Invalid);
   83|       |    // LCOV_EXCL_START - defensive check for invalid buffer
   84|  1.42k|    if (Invalid)
  ------------------
  |  Branch (84:9): [True: 0, False: 1.42k]
  ------------------
   85|      0|      return;
   86|       |    // LCOV_EXCL_STOP
   87|       |
   88|  1.42k|    SourceLocation FileStart = SM.getLocForStartOfFile(FID);
   89|       |
   90|  8.79M|    for (size_t Pos = 0; Pos < Buffer.size() - 2; ++Pos) {
  ------------------
  |  Branch (90:26): [True: 8.79M, False: 1.42k]
  ------------------
   91|  8.79M|      if (Buffer[Pos] != '?' || Buffer[Pos + 1] != '?')
  ------------------
  |  Branch (91:11): [True: 8.79M, False: 450]
  |  Branch (91:33): [True: 449, False: 1]
  ------------------
   92|  8.79M|        continue;
   93|       |
   94|      1|      char ThirdChar = Buffer[Pos + 2];
   95|      1|      char Replacement = getTrigraphReplacement(ThirdChar);
   96|      1|      if (Replacement == '\0')
  ------------------
  |  Branch (96:11): [True: 0, False: 1]
  ------------------
   97|      0|        continue;
   98|       |
   99|      1|      SourceLocation TrigraphLoc = FileStart.getLocWithOffset(Pos);
  100|      1|      SmallString<64> Message;
  101|      1|      llvm::raw_svector_ostream OS(Message);
  102|      1|      OS << "avoid trigraph sequence '??" << ThirdChar << "' (expands to '"
  103|      1|         << Replacement << "')";
  104|      1|      Check.diag(TrigraphLoc, Message);
  105|      1|    }
  106|  1.42k|  }
  107|       |};
  108|       |
  109|       |} // anonymous namespace
  110|       |
  111|       |void AvoidTrigraphCheck::registerPPCallbacks(const SourceManager &SM,
  112|       |                                             Preprocessor *PP,
  113|    131|                                             Preprocessor *ModuleExpanderPP) {
  114|    131|  PP->addPPCallbacks(::std::make_unique<AvoidTrigraphPPCallbacks>(*this, SM));
  115|    131|}
  116|       |
  117|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidOctalNumberCheck.cpp:
    1|       |//===--- AvoidOctalNumberCheck.cpp - clang-tidy ---------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidOctalNumberCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "clang/Lex/Lexer.h"
   13|       |#include "clang/Lex/Token.h"
   14|       |#include "llvm/Support/Regex.h"
   15|       |
   16|       |using namespace clang::ast_matchers;
   17|       |
   18|       |namespace clang::tidy::automotive {
   19|       |
   20|    131|void AvoidOctalNumberCheck::registerMatchers(MatchFinder *Finder) {
   21|    131|  Finder->addMatcher(integerLiteral().bind("integer"), this);
   22|    131|}
   23|       |
   24|  4.66k|void AvoidOctalNumberCheck::check(const MatchFinder::MatchResult &Result) {
   25|  4.66k|  const auto *MatchedDecl = Result.Nodes.getNodeAs<IntegerLiteral>("integer");
   26|  4.66k|  if (!MatchedDecl)
  ------------------
  |  Branch (26:7): [True: 0, False: 4.66k]
  ------------------
   27|      0|    return;
   28|       |
   29|  4.66k|  const SourceManager &SM = *Result.SourceManager;
   30|  4.66k|  const LangOptions &LangOpts = Result.Context->getLangOpts();
   31|  4.66k|  const llvm::Regex RE("^0[0-9]+[luLU]?$");
   32|       |
   33|  4.66k|  StringRef Token = Lexer::getSourceText(
   34|  4.66k|      CharSourceRange::getTokenRange(MatchedDecl->getBeginLoc(),
   35|  4.66k|                                     MatchedDecl->getEndLoc()),
   36|  4.66k|      SM, LangOpts);
   37|       |
   38|  4.66k|  if (RE.match(Token))
  ------------------
  |  Branch (38:7): [True: 19, False: 4.64k]
  ------------------
   39|     19|    diag(MatchedDecl->getBeginLoc(), "Avoid octal number");
   40|  4.66k|}
   41|       |
   42|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidLowercaseLiteralSuffixCheck.h:
    1|       |//===--- AvoidLowercaseLiteralSuffixCheck.h - clang-tidy --------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLOWERCASELITERALSUFFIXCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLOWERCASELITERALSUFFIXCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects lowercase literal suffixes on numeric constants.
   17|       |///
   18|       |/// Lowercase 'l' can be easily confused with the digit '1', especially in
   19|       |/// certain fonts. Using uppercase 'L' or 'U' for literal suffixes improves
   20|       |/// readability and prevents misinterpretation of numeric literals.
   21|       |///
   22|       |/// Related MISRA C:2025 Rule: 7.3 - The lowercase character 'l' shall not be
   23|       |/// used in a literal suffix.
   24|       |///
   25|       |/// Example:
   26|       |/// \code
   27|       |///   long x = 100l;   // Warning: lowercase 'l' suffix
   28|       |///   unsigned y = 5u; // Warning: lowercase 'u' suffix
   29|       |/// \endcode
   30|       |class AvoidLowercaseLiteralSuffixCheck : public ClangTidyCheck {
   31|       |public:
   32|       |  /// Constructs the check with the given name and context.
   33|       |  /// \param Name The name of the check as registered.
   34|       |  /// \param Context The clang-tidy context for configuration.
   35|       |  AvoidLowercaseLiteralSuffixCheck(StringRef Name, ClangTidyContext *Context)
   36|    131|      : ClangTidyCheck(Name, Context) {}
   37|       |
   38|       |  /// Destructor.
   39|    131|  ~AvoidLowercaseLiteralSuffixCheck() override = default;
   40|       |
   41|       |  /// Registers AST matchers for numeric literals.
   42|       |  /// \param Finder The match finder to register matchers with.
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |
   45|       |  /// Handles matched literals and emits diagnostics.
   46|       |  /// \param Result The match result containing the matched AST node.
   47|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   48|       |};
   49|       |
   50|       |} // namespace clang::tidy::automotive
   51|       |
   52|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDLOWERCASELITERALSUFFIXCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/literal/LiteralComponent.cpp:
    1|       |//===--- LiteralComponent.cpp - clang-tidy --------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "LiteralComponent.h"
   10|       |#include "AvoidLowercaseLiteralSuffixCheck.h"
   11|       |#include "AvoidOctalNumberCheck.h"
   12|       |#include "AvoidTrigraphCheck.h"
   13|       |#include "UnterminatedEscapeSequenceCheck.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |void LiteralComponent::addCheckFactories(
   18|    262|    ClangTidyCheckFactories &CheckFactories) {
   19|       |
   20|    262|  CheckFactories.registerCheck<AvoidOctalNumberCheck>(
   21|    262|      "automotive-avoid-octal-number");
   22|    262|  CheckFactories.registerCheck<AvoidLowercaseLiteralSuffixCheck>(
   23|    262|      "automotive-avoid-lowercase-literal-suffix");
   24|    262|  CheckFactories.registerCheck<AvoidTrigraphCheck>("automotive-c23-adv-4.2");
   25|    262|  CheckFactories.registerCheck<UnterminatedEscapeSequenceCheck>(
   26|    262|      "automotive-unterminated-escape-sequence");
   27|    262|}
   28|       |
   29|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidOctalNumberCheck.h:
    1|       |//===--- AvoidOctalNumberCheck.h - clang-tidy --------------------*- C++
    2|       |//-*-===//
    3|       |//
    4|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    5|       |// See https://llvm.org/LICENSE.txt for license information.
    6|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    7|       |//
    8|       |//===----------------------------------------------------------------------===//
    9|       |
   10|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDOCTALNUMBERCHECK_H
   11|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDOCTALNUMBERCHECK_H
   12|       |
   13|       |#include "../../ClangTidyCheck.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Detects octal literal constants (except zero).
   18|       |///
   19|       |/// Octal literals are denoted by a leading zero, which can be easily
   20|       |/// overlooked or added accidentally. This can lead to confusion where a
   21|       |/// developer intends a decimal value but accidentally creates an octal
   22|       |/// constant, resulting in unexpected values.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 7.1 - Octal constants shall not be used.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   int x = 0123;  // Warning: octal literal (decimal 83)
   29|       |///   int y = 0;     // OK: zero is allowed
   30|       |/// \endcode
   31|       |class AvoidOctalNumberCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  AvoidOctalNumberCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~AvoidOctalNumberCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for integer literals.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched octal literals and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDOCTALNUMBERCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/literal/UnterminatedEscapeSequenceCheck.cpp:
    1|       |//===--- UnterminatedEscapeSequenceCheck.cpp - clang-tidy -----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UnterminatedEscapeSequenceCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |#include "llvm/Support/Regex.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void UnterminatedEscapeSequenceCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(stringLiteral().bind("stringLiteral"), this);
   19|    131|  Finder->addMatcher(characterLiteral().bind("charLiteral"), this);
   20|    131|}
   21|       |
   22|       |void UnterminatedEscapeSequenceCheck::check(
   23|    509|    const ast_matchers::MatchFinder::MatchResult &Result) {
   24|       |
   25|    509|  const auto *MatchString =
   26|    509|      Result.Nodes.getNodeAs<StringLiteral>("stringLiteral");
   27|    509|  if (MatchString) {
  ------------------
  |  Branch (27:7): [True: 377, False: 132]
  ------------------
   28|       |    // Only check narrow character strings (char width 1)
   29|       |    // Wide strings (wchar_t, char16_t, char32_t) are not supported
   30|    377|    if (MatchString->getCharByteWidth() != 1)
  ------------------
  |  Branch (30:9): [True: 18, False: 359]
  ------------------
   31|     18|      return;
   32|    359|    checkEscapeSequences(MatchString->getEndLoc(), MatchString->getBeginLoc(),
   33|    359|                         MatchString->getString());
   34|    359|    return;
   35|    377|  }
   36|       |
   37|    132|  const auto *MatchChar =
   38|    132|      Result.Nodes.getNodeAs<CharacterLiteral>("charLiteral");
   39|    132|  if (MatchChar) {
  ------------------
  |  Branch (39:7): [True: 132, False: 0]
  ------------------
   40|    132|    char Value = MatchChar->getValue();
   41|    132|    checkEscapeSequences(MatchChar->getBeginLoc(), MatchChar->getEndLoc(),
   42|    132|                         StringRef(&Value, 1));
   43|    132|    return;
   44|    132|  }
   45|    132|}
   46|       |
   47|       |void UnterminatedEscapeSequenceCheck::checkEscapeSequences(
   48|    491|    SourceLocation StartLoc, SourceLocation EndLoc, StringRef Str) {
   49|    491|  diag(StartLoc, "'%0'") << Str;
   50|    491|}
   51|       |
   52|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidTrigraphCheck.h:
    1|       |//===--- AvoidTrigraphCheck.h - clang-tidy ----------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDTRIGRAPHCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDTRIGRAPHCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects usage of trigraph sequences in source code.
   17|       |///
   18|       |/// Trigraphs are three-character sequences starting with ?? that are replaced
   19|       |/// by the preprocessor before tokenization. They were introduced in C89 to
   20|       |/// support systems with limited character sets but are now obsolete and can
   21|       |/// lead to confusion.
   22|       |///
   23|       |/// Related MISRA C:2023 Rule: 4.2 - Trigraph sequences should not be used.
   24|       |///
   25|       |/// The following trigraphs are detected:
   26|       |/// - ??= becomes #
   27|       |/// - ??( becomes [
   28|       |/// - ??) becomes ]
   29|       |/// - ??< becomes {
   30|       |/// - ??> becomes }
   31|       |/// - ??/ becomes \
   32|       |/// - ??' becomes ^
   33|       |/// - ??! becomes |
   34|       |/// - ??- becomes ~
   35|       |///
   36|       |/// Example:
   37|       |/// \code
   38|       |///   int array??(??) = {0};  // Warning: trigraph ??( and ??) used
   39|       |///   ??=define MAX 100       // Warning: trigraph ??= used
   40|       |/// \endcode
   41|       |class AvoidTrigraphCheck : public ClangTidyCheck {
   42|       |public:
   43|       |  /// Constructs the check with the given name and context.
   44|       |  /// \param Name The name of the check as registered.
   45|       |  /// \param Context The clang-tidy context for configuration.
   46|       |  AvoidTrigraphCheck(StringRef Name, ClangTidyContext *Context)
   47|    131|      : ClangTidyCheck(Name, Context) {}
   48|       |
   49|       |  /// Destructor.
   50|    131|  ~AvoidTrigraphCheck() override = default;
   51|       |
   52|       |  /// Registers preprocessor callbacks for trigraph detection.
   53|       |  /// \param SM The source manager.
   54|       |  /// \param PP The preprocessor instance.
   55|       |  /// \param ModuleExpanderPP The module expander preprocessor.
   56|       |  void registerPPCallbacks(const SourceManager &SM, Preprocessor *PP,
   57|       |                           Preprocessor *ModuleExpanderPP) override;
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDTRIGRAPHCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/literal/AvoidLowercaseLiteralSuffixCheck.cpp:
    1|       |//===--- AvoidLowercaseLiteralSuffixCheck.cpp - clang-tidy ----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidLowercaseLiteralSuffixCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |#include "clang/Lex/Lexer.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void AvoidLowercaseLiteralSuffixCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(expr(anyOf(integerLiteral().bind("literal"),
   19|    131|                                floatLiteral().bind("literal"))),
   20|    131|                     this);
   21|    131|}
   22|       |
   23|       |void AvoidLowercaseLiteralSuffixCheck::check(
   24|  4.71k|    const MatchFinder::MatchResult &Result) {
   25|  4.71k|  const auto *MatchedLiteral = Result.Nodes.getNodeAs<Expr>("literal");
   26|       |
   27|  4.71k|  if (!MatchedLiteral)
  ------------------
  |  Branch (27:7): [True: 0, False: 4.71k]
  ------------------
   28|      0|    return;
   29|       |
   30|  4.71k|  SourceRange Range = MatchedLiteral->getSourceRange();
   31|  4.71k|  SourceManager &SM = *Result.SourceManager;
   32|  4.71k|  LangOptions LangOpts = Result.Context->getLangOpts();
   33|  4.71k|  StringRef LiteralText =
   34|  4.71k|      Lexer::getSourceText(CharSourceRange::getTokenRange(Range), SM, LangOpts);
   35|       |
   36|  4.71k|  if (!LiteralText.empty()) {
  ------------------
  |  Branch (36:7): [True: 4.36k, False: 347]
  ------------------
   37|  4.36k|    static constexpr char Digits[] = "0123456789";
   38|  4.36k|    size_t SuffixStart = LiteralText.find_last_of(Digits) + 1;
   39|       |
   40|  6.61k|    for (size_t Index = SuffixStart; Index < LiteralText.size(); ++Index) {
  ------------------
  |  Branch (40:38): [True: 2.26k, False: 4.34k]
  ------------------
   41|  2.26k|      char Ch = LiteralText[Index];
   42|       |
   43|  2.26k|      if (Ch == 'l') {
  ------------------
  |  Branch (43:11): [True: 21, False: 2.24k]
  ------------------
   44|     21|        auto SuffixLoc =
   45|     21|            MatchedLiteral->getBeginLoc().getLocWithOffset(SuffixStart);
   46|     21|        diag(SuffixLoc, "avoid lowercase 'l' in a literal suffix");
   47|     21|        return;
   48|     21|      }
   49|  2.26k|    }
   50|  4.36k|  }
   51|  4.71k|}
   52|       |
   53|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/literal/UnterminatedEscapeSequenceCheck.h:
    1|       |//===--- UnterminatedEscapeSequenceCheck.h - clang-tidy ---------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNTERMINATEDESCAPESEQUENCECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNTERMINATEDESCAPESEQUENCECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "clang/Basic/SourceLocation.h"
   14|       |#include "llvm/ADT/StringRef.h"
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|       |/// Detects unterminated or invalid escape sequences in string literals.
   19|       |///
   20|       |/// Escape sequences in strings and character constants must be well-formed.
   21|       |/// Invalid escape sequences have implementation-defined behavior and can lead
   22|       |/// to portability issues. Common errors include incomplete octal or hexadecimal
   23|       |/// escape sequences that may silently produce unexpected characters.
   24|       |///
   25|       |/// Related MISRA C:2025 Rule: 4.1 - Escape sequences shall be well-formed.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   char str[] = "\x";    // Warning: incomplete hex escape sequence
   30|       |///   char ch = '\77';      // Warning: incomplete octal escape
   31|       |/// \endcode
   32|       |class UnterminatedEscapeSequenceCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  UnterminatedEscapeSequenceCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~UnterminatedEscapeSequenceCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for string and character literals.
   44|       |  /// \param Finder The match finder to register matchers with.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched literals and emits diagnostics.
   48|       |  /// \param Result The match result containing the matched AST node.
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |
   51|       |private:
   52|       |  /// Checks for invalid escape sequences in a string.
   53|       |  /// \param StartLoc The starting location of the string literal.
   54|       |  /// \param EndLoc The ending location of the string literal.
   55|       |  /// \param Str The string content to check.
   56|       |  void checkEscapeSequences(SourceLocation StartLoc, SourceLocation EndLoc,
   57|       |                            StringRef Str);
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNTERMINATEDESCAPESEQUENCECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/AvoidFunctionParameterModificationCheck.cpp:
    1|       |//===--- AvoidFunctionParameterModificationCheck.cpp - clang-tidy ---------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidFunctionParameterModificationCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |void AvoidFunctionParameterModificationCheck::registerMatchers(
   17|    131|    MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(binaryOperator(isAssignmentOperator(),
   19|    131|                                    hasLHS(ignoringParenImpCasts(declRefExpr(
   20|    131|                                        to(parmVarDecl().bind("param"))))))
   21|    131|                         .bind("operator"),
   22|    131|                     this);
   23|       |
   24|    131|  Finder->addMatcher(
   25|    131|      unaryOperator(anyOf(hasOperatorName("++"), hasOperatorName("--")),
   26|    131|                    hasUnaryOperand(ignoringParenImpCasts(
   27|    131|                        declRefExpr(to(parmVarDecl().bind("param"))))))
   28|    131|          .bind("operator"),
   29|    131|      this);
   30|    131|}
   31|       |
   32|       |void AvoidFunctionParameterModificationCheck::check(
   33|    419|    const MatchFinder::MatchResult &Result) {
   34|    419|  const auto *MatchedParam = Result.Nodes.getNodeAs<ParmVarDecl>("param");
   35|    419|  const auto *MatchedOperator = Result.Nodes.getNodeAs<Expr>("operator");
   36|       |
   37|    419|  if (MatchedParam && MatchedOperator) {
  ------------------
  |  Branch (37:7): [True: 419, False: 0]
  |  Branch (37:23): [True: 419, False: 0]
  ------------------
   38|       |    // Check if the operator is an assignment or increment/decrement and give a
   39|       |    // specific message
   40|    419|    if (isa<BinaryOperator>(MatchedOperator)) {
  ------------------
  |  Branch (40:9): [True: 238, False: 181]
  ------------------
   41|    238|      diag(MatchedOperator->getExprLoc(),
   42|    238|           "avoid modifying function parameter '%0' with assignment operator")
   43|    238|          << MatchedParam->getName();
   44|    238|    } else if (isa<UnaryOperator>(MatchedOperator)) {
  ------------------
  |  Branch (44:16): [True: 181, False: 0]
  ------------------
   45|    181|      diag(MatchedOperator->getExprLoc(),
   46|    181|           "avoid modifying function parameter '%0' with increment/decrement "
   47|    181|           "operator")
   48|    181|          << MatchedParam->getName();
   49|    181|    }
   50|       |
   51|       |    // Provide the location where the parameter is declared
   52|    419|    diag(MatchedParam->getLocation(), "function parameter '%0' declared here",
   53|    419|         DiagnosticIDs::Note)
   54|    419|        << MatchedParam->getName();
   55|    419|  }
   56|    419|}
   57|       |
   58|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/ImplicitFunctionDeclCheck.cpp:
    1|       |//===--- ImplicitFunctionDeclCheck.cpp - clang-tidy -----------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "ImplicitFunctionDeclCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|      1|void ImplicitFunctionDeclCheck::registerMatchers(MatchFinder *Finder) {
   17|      1|  Finder->addMatcher(callExpr(callee(functionDecl().bind("func"))).bind("call"),
   18|      1|                     this);
   19|      1|}
   20|       |
   21|      8|void ImplicitFunctionDeclCheck::check(const MatchFinder::MatchResult &Result) {
   22|      8|  const auto *MatchedCall = Result.Nodes.getNodeAs<CallExpr>("call");
   23|      8|  const auto *MatchedFunc = Result.Nodes.getNodeAs<FunctionDecl>("func");
   24|       |
   25|      8|  if (!MatchedCall || !MatchedFunc)
  ------------------
  |  Branch (25:7): [True: 0, False: 8]
  |  Branch (25:23): [True: 0, False: 8]
  ------------------
   26|      0|    return;
   27|       |
   28|      8|  if (MatchedFunc->hasPrototype())
  ------------------
  |  Branch (28:7): [True: 4, False: 4]
  ------------------
   29|      4|    return;
   30|       |
   31|      4|  diag(MatchedCall->getBeginLoc(),
   32|      4|       "function '%0' is called without a prior declaration")
   33|      4|      << MatchedFunc->getName();
   34|      4|}
   35|       |
   36|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/ImplicitFunctionDeclCheck.h:
    1|       |//===--- ImplicitFunctionDeclCheck.h - clang-tidy ---------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITFUNCTIONDECLCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITFUNCTIONDECLCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |#include "../utils/Utils.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Detects calls to functions without prior declarations.
   18|       |///
   19|       |/// In C90, calling a function without a prior declaration causes the compiler
   20|       |/// to implicitly declare it with default return type int. This can lead to
   21|       |/// type mismatches, runtime errors, and undefined behavior if the actual
   22|       |/// function signature differs from the implicit declaration.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 8.1 - Functions shall have prototypes and the
   25|       |/// prototype shall be visible at the point of call.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   int main(void) {
   30|       |///     foo();  // Warning: implicit function declaration (C90)
   31|       |///   }
   32|       |/// \endcode
   33|       |class ImplicitFunctionDeclCheck : public ClangTidyCheck {
   34|       |public:
   35|       |  /// Constructs the check with the given name and context.
   36|       |  /// \param Name The name of the check as registered.
   37|       |  /// \param Context The clang-tidy context for configuration.
   38|       |  ImplicitFunctionDeclCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~ImplicitFunctionDeclCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for function calls.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched function calls and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |
   52|       |  /// Only applies to C90 language mode.
   53|       |  /// \param LangOpts The language options for the current translation unit.
   54|       |  /// \return true if the language is C90.
   55|    131|  bool isLanguageVersionSupported(const LangOptions &LangOpts) const override {
   56|    131|    return utils::isLanguageC90(LangOpts);
   57|    131|  }
   58|       |};
   59|       |
   60|       |} // namespace clang::tidy::automotive
   61|       |
   62|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_IMPLICITFUNCTIONDECLCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/UncompleteFunctionPrototypeCheck.cpp:
    1|       |//===--- UncompleteFunctionPrototypeCheck.cpp - clang-tidy ----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "UncompleteFunctionPrototypeCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void UncompleteFunctionPrototypeCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(functionDecl().bind("func"), this);
   18|    131|}
   19|       |
   20|       |void UncompleteFunctionPrototypeCheck::check(
   21|  9.98k|    const MatchFinder::MatchResult &Result) {
   22|  9.98k|  const auto *MatchedFunc = Result.Nodes.getNodeAs<FunctionDecl>("func");
   23|  9.98k|  if (!MatchedFunc)
  ------------------
  |  Branch (23:7): [True: 0, False: 9.98k]
  ------------------
   24|      0|    return;
   25|       |
   26|       |  // Skip system headers and invalid locations
   27|  9.98k|  if (!MatchedFunc->getLocation().isValid() ||
  ------------------
  |  Branch (27:7): [True: 72, False: 9.91k]
  |  Branch (27:7): [True: 9.23k, False: 745]
  ------------------
   28|  9.98k|      Result.SourceManager->isInSystemHeader(MatchedFunc->getLocation()))
  ------------------
  |  Branch (28:7): [True: 9.16k, False: 745]
  ------------------
   29|  9.23k|    return;
   30|       |
   31|    745|  if (!MatchedFunc->hasPrototype())
  ------------------
  |  Branch (31:7): [True: 13, False: 732]
  ------------------
   32|     13|    diag(MatchedFunc->getLocation(), "function is not in prototype form");
   33|       |
   34|    745|  for (const ParmVarDecl *Param : MatchedFunc->parameters()) {
  ------------------
  |  Branch (34:33): [True: 382, False: 745]
  ------------------
   35|    382|    if (Param->getName().empty() && Param->getLocation().isValid())
  ------------------
  |  Branch (35:9): [True: 64, False: 318]
  |  Branch (35:9): [True: 52, False: 330]
  |  Branch (35:37): [True: 52, False: 12]
  ------------------
   36|     52|      diag(Param->getLocation(), "function parameter is unnamed");
   37|    382|  }
   38|       |
   39|    745|  if (MatchedFunc->parameters().empty() && !MatchedFunc->hasWrittenPrototype())
  ------------------
  |  Branch (39:7): [True: 432, False: 313]
  |  Branch (39:7): [True: 12, False: 733]
  |  Branch (39:44): [True: 12, False: 420]
  ------------------
   40|     12|    diag(MatchedFunc->getLocation(),
   41|     12|         "function with no parameters must use 'void' in prototype");
   42|    745|}
   43|       |
   44|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/StaticInlineCheck.cpp:
    1|       |//===--- StaticInlineCheck.cpp - clang-tidy -------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "StaticInlineCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |
   13|       |using namespace clang::ast_matchers;
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|    131|void StaticInlineCheck::registerMatchers(MatchFinder *Finder) {
   18|    131|  Finder->addMatcher(
   19|    131|      functionDecl(allOf(isInline(), unless(isStaticStorageClass())))
   20|    131|          .bind("inline"),
   21|    131|      this);
   22|    131|}
   23|       |
   24|  1.16k|void StaticInlineCheck::check(const MatchFinder::MatchResult &Result) {
   25|  1.16k|  const auto *MatchedDecl = Result.Nodes.getNodeAs<FunctionDecl>("inline");
   26|       |
   27|  1.16k|  if (MatchedDecl) {
  ------------------
  |  Branch (27:7): [True: 1.16k, False: 0]
  ------------------
   28|  1.16k|    diag(MatchedDecl->getBeginLoc(), "inline function shall be static")
   29|  1.16k|        << FixItHint::CreateInsertion(MatchedDecl->getBeginLoc(), "static ");
   30|  1.16k|  }
   31|  1.16k|}
   32|       |
   33|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/FunctionDeclarationMismatchCheck.cpp:
    1|       |//===--- FunctionDeclarationMismatchCheck.cpp - clang-tidy ----------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "FunctionDeclarationMismatchCheck.h"
   10|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   11|       |
   12|       |using namespace clang::ast_matchers;
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|    131|void FunctionDeclarationMismatchCheck::registerMatchers(MatchFinder *Finder) {
   17|    131|  Finder->addMatcher(functionDecl(isDefinition()).bind("funcDecl"), this);
   18|    131|}
   19|       |
   20|       |void FunctionDeclarationMismatchCheck::check(
   21|  4.64k|    const MatchFinder::MatchResult &Result) {
   22|  4.64k|  const auto *FuncDecl = Result.Nodes.getNodeAs<FunctionDecl>("funcDecl");
   23|       |
   24|  4.64k|  if (!FuncDecl || !FuncDecl->getPreviousDecl())
  ------------------
  |  Branch (24:7): [True: 0, False: 4.64k]
  |  Branch (24:20): [True: 4.51k, False: 129]
  ------------------
   25|  4.51k|    return;
   26|       |
   27|       |  // Skip C++ special member functions (constructors, destructors, operators)
   28|       |  // which don't have simple identifier names
   29|    129|  if (!FuncDecl->getDeclName().isIdentifier())
  ------------------
  |  Branch (29:7): [True: 16, False: 113]
  ------------------
   30|     16|    return;
   31|       |
   32|    113|  const auto *PrevDecl = FuncDecl->getPreviousDecl();
   33|       |
   34|    113|  if (FuncDecl->getType().getCanonicalType().getUnqualifiedType() !=
  ------------------
  |  Branch (34:7): [True: 0, False: 113]
  ------------------
   35|    113|      PrevDecl->getType().getCanonicalType().getUnqualifiedType()) {
   36|      0|    diag(FuncDecl->getLocation(),
   37|      0|         "Inconsistent function declaration types for '%0'")
   38|      0|        << FuncDecl->getName();
   39|      0|  }
   40|       |
   41|       |  // Compare parameter types and names
   42|    113|  if (FuncDecl->param_size() == PrevDecl->param_size()) {
  ------------------
  |  Branch (42:7): [True: 113, False: 0]
  ------------------
   43|    374|    for (unsigned i = 0; i < FuncDecl->param_size(); ++i) {
  ------------------
  |  Branch (43:26): [True: 261, False: 113]
  ------------------
   44|    261|      const ParmVarDecl *ParamDecl = FuncDecl->getParamDecl(i);
   45|    261|      const ParmVarDecl *PrevParamDecl = PrevDecl->getParamDecl(i);
   46|       |
   47|       |      // Compare parameter names
   48|    261|      if (ParamDecl->getName() != PrevParamDecl->getName()) {
  ------------------
  |  Branch (48:11): [True: 24, False: 237]
  ------------------
   49|     24|        diag(ParamDecl->getLocation(),
   50|     24|             "parameter name '%0' mismatch with '%1' in function '%2'")
   51|     24|            << ParamDecl->getName() << PrevParamDecl->getName()
   52|     24|            << FuncDecl->getName();
   53|     24|        diag(PrevParamDecl->getLocation(), "position of '%0'",
   54|     24|             DiagnosticIDs::Note)
   55|     24|            << PrevParamDecl->getName();
   56|     24|      }
   57|       |
   58|       |      // Compare parameter type qualifiers
   59|    261|      if (ParamDecl->getType().getCanonicalType() !=
  ------------------
  |  Branch (59:11): [True: 0, False: 261]
  ------------------
   60|    261|          PrevParamDecl->getType().getCanonicalType()) {
   61|      0|        diag(FuncDecl->getLocation(),
   62|      0|             "Mismatched type qualifiers between declarations of function '%0'")
   63|      0|            << FuncDecl->getName();
   64|      0|      }
   65|    261|    }
   66|    113|  }
   67|    113|}
   68|       |
   69|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/AvoidFunctionParameterModificationCheck.h:
    1|       |//===--- AvoidFunctionParameterModificationCheck.h - clang-tidy -*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFUNCTIONPARAMETERMODIFICATIONCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFUNCTIONPARAMETERMODIFICATIONCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects modifications to function parameters within the function body.
   17|       |///
   18|       |/// Modifying function parameters can make code harder to understand and
   19|       |/// debug, as the parameter value changes during execution. This can lead to
   20|       |/// confusion about the original input value and makes the function's behavior
   21|       |/// less predictable. Using local copies for modifications is clearer.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 17.8 - A function parameter should not be
   24|       |/// modified.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   void func(int x) {
   29|       |///     x = x + 1;  // Warning: modifying parameter
   30|       |///   }
   31|       |/// \endcode
   32|       |class AvoidFunctionParameterModificationCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  AvoidFunctionParameterModificationCheck(StringRef Name,
   38|       |                                          ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidFunctionParameterModificationCheck() override = default;
   43|       |
   44|       |  /// Registers AST matchers for parameter modifications.
   45|       |  /// \param Finder The match finder to register matchers with.
   46|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   47|       |
   48|       |  /// Handles matched parameter modifications and emits diagnostics.
   49|       |  /// \param Result The match result containing the matched AST node.
   50|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   51|       |};
   52|       |
   53|       |} // namespace clang::tidy::automotive
   54|       |
   55|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDFUNCTIONPARAMETERMODIFICATIONCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/AvoidStaticInArrayParamCheck.h:
    1|       |//===--- AvoidStaticInArrayParamCheck.h - clang-tidy ------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTATICINARRAYPARAMCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTATICINARRAYPARAMCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// @ingroup misra-c25-function
   17|       |/// @brief Detects static keyword in array parameter declarations.
   18|       |///
   19|       |/// The declaration of an array parameter shall not contain the static keyword
   20|       |/// between the [ ]. The C99 static keyword in array parameters specifies a
   21|       |/// minimum array size but is not widely understood and has subtle semantics
   22|       |/// that can lead to undefined behavior if violated.
   23|       |///
   24|       |/// @par MISRA C:2025 Rule 17.6
   25|       |/// The declaration of an array parameter shall not contain the static keyword
   26|       |/// between the [ ].
   27|       |/// @par Category: Mandatory
   28|       |///
   29|       |/// Example:
   30|       |/// @code
   31|       |///   void func1(int arr[static 10]);  // Warning: static in array parameter
   32|       |///   void func2(int arr[10]);         // Compliant: no static keyword
   33|       |///   void func3(int arr[]);           // Compliant: unsized array
   34|       |///   void func4(int *arr);            // Compliant: pointer parameter
   35|       |/// @endcode
   36|       |class AvoidStaticInArrayParamCheck : public ClangTidyCheck {
   37|       |public:
   38|       |  AvoidStaticInArrayParamCheck(StringRef Name, ClangTidyContext *Context)
   39|    131|      : ClangTidyCheck(Name, Context) {}
   40|       |
   41|       |  /// Destructor.
   42|    131|  ~AvoidStaticInArrayParamCheck() override = default;
   43|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   44|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   45|       |};
   46|       |
   47|       |} // namespace clang::tidy::automotive
   48|       |
   49|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_AVOIDSTATICINARRAYPARAMCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/FunctionDeclarationMismatchCheck.h:
    1|       |//===--- FunctionDeclarationMismatchCheck.h - clang-tidy --------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FUNCTIONDECLARATIONMISMATCHCHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FUNCTIONDECLARATIONMISMATCHCHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects mismatches between function declarations and definitions.
   17|       |///
   18|       |/// Function declarations and their corresponding definitions must match
   19|       |/// exactly in terms of return type, parameter types, and qualifiers. Mismatches
   20|       |/// can lead to undefined behavior, linking errors, or subtle bugs that are
   21|       |/// difficult to diagnose, especially in multi-file projects.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 8.3 - All declarations and definitions of an
   24|       |/// object or function shall use compatible types.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   void func(int x);       // Declaration
   29|       |///   void func(long x) {}    // Warning: parameter type mismatch
   30|       |/// \endcode
   31|       |class FunctionDeclarationMismatchCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  FunctionDeclarationMismatchCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~FunctionDeclarationMismatchCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for function declarations.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched function declarations and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_FUNCTIONDECLARATIONMISMATCHCHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/UncompleteFunctionPrototypeCheck.h:
    1|       |//===--- FunctionPrototypeWithNamedParametersCheck.h - clang-tidy *- C++
    2|       |//-*-===//
    3|       |//
    4|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    5|       |// See https://llvm.org/LICENSE.txt for license information.
    6|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    7|       |//
    8|       |//===----------------------------------------------------------------------===//
    9|       |
   10|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNCOMPLETEFUNCTIONPROTOTYPECHECK_H
   11|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNCOMPLETEFUNCTIONPROTOTYPECHECK_H
   12|       |
   13|       |#include "../../ClangTidyCheck.h"
   14|       |
   15|       |namespace clang::tidy::automotive {
   16|       |
   17|       |/// Detects function prototypes without complete parameter type information.
   18|       |///
   19|       |/// Function prototypes should include complete parameter type information.
   20|       |/// Old-style K&R function declarations or prototypes with empty parameter
   21|       |/// lists provide no type checking for arguments, which can lead to type
   22|       |/// mismatches and undefined behavior at call sites.
   23|       |///
   24|       |/// Related MISRA C:2025 Rule: 8.2 - Function types shall be in prototype form
   25|       |/// with named parameters.
   26|       |///
   27|       |/// Example:
   28|       |/// \code
   29|       |///   int func();      // Warning: incomplete prototype (no parameter info)
   30|       |///   int foo(a, b);   // Warning: K&R style declaration
   31|       |/// \endcode
   32|       |class UncompleteFunctionPrototypeCheck : public ClangTidyCheck {
   33|       |public:
   34|       |  /// Constructs the check with the given name and context.
   35|       |  /// \param Name The name of the check as registered.
   36|       |  /// \param Context The clang-tidy context for configuration.
   37|       |  UncompleteFunctionPrototypeCheck(StringRef Name, ClangTidyContext *Context)
   38|    131|      : ClangTidyCheck(Name, Context) {}
   39|       |
   40|       |  /// Destructor.
   41|    131|  ~UncompleteFunctionPrototypeCheck() override = default;
   42|       |
   43|       |  /// Registers AST matchers for function declarations.
   44|       |  /// \param Finder The match finder to register matchers with.
   45|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   46|       |
   47|       |  /// Handles matched function declarations and emits diagnostics.
   48|       |  /// \param Result The match result containing the matched AST node.
   49|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   50|       |};
   51|       |
   52|       |} // namespace clang::tidy::automotive
   53|       |
   54|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_UNCOMPLETEFUNCTIONPROTOTYPECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/StaticInlineCheck.h:
    1|       |//===--- StaticInlineCheck.h - clang-tidy -----------------------*- C++ -*-===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_STATICINLINECHECK_H
   10|       |#define LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_STATICINLINECHECK_H
   11|       |
   12|       |#include "../../ClangTidyCheck.h"
   13|       |
   14|       |namespace clang::tidy::automotive {
   15|       |
   16|       |/// Detects inline functions that lack the static storage class specifier.
   17|       |///
   18|       |/// Inline functions should be declared static to ensure they have internal
   19|       |/// linkage and avoid potential multiple definition errors when included in
   20|       |/// multiple translation units. Without static, inline functions can lead to
   21|       |/// ODR (One Definition Rule) violations and linker issues.
   22|       |///
   23|       |/// Related MISRA C:2025 Rule: 8.9 - An inline function shall be declared with
   24|       |/// the static storage class.
   25|       |///
   26|       |/// Example:
   27|       |/// \code
   28|       |///   inline int func(void) { return 0; }  // Warning: missing static
   29|       |///   static inline int foo(void) { return 1; }  // OK
   30|       |/// \endcode
   31|       |class StaticInlineCheck : public ClangTidyCheck {
   32|       |public:
   33|       |  /// Constructs the check with the given name and context.
   34|       |  /// \param Name The name of the check as registered.
   35|       |  /// \param Context The clang-tidy context for configuration.
   36|       |  StaticInlineCheck(StringRef Name, ClangTidyContext *Context)
   37|    131|      : ClangTidyCheck(Name, Context) {}
   38|       |
   39|       |  /// Destructor.
   40|    131|  ~StaticInlineCheck() override = default;
   41|       |
   42|       |  /// Registers AST matchers for inline function declarations.
   43|       |  /// \param Finder The match finder to register matchers with.
   44|       |  void registerMatchers(ast_matchers::MatchFinder *Finder) override;
   45|       |
   46|       |  /// Handles matched inline functions and emits diagnostics.
   47|       |  /// \param Result The match result containing the matched AST node.
   48|       |  void check(const ast_matchers::MatchFinder::MatchResult &Result) override;
   49|       |};
   50|       |
   51|       |} // namespace clang::tidy::automotive
   52|       |
   53|       |#endif // LLVM_CLANG_TOOLS_EXTRA_CLANG_TIDY_AUTOMOTIVE_STATICINLINECHECK_H

/home/e/Development/clang-tidy-automotive/src/automotive/function/FunctionComponent.cpp:
    1|       |//===--- FunctionComponent.cpp - clang-tidy -------------------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "FunctionComponent.h"
   10|       |#include "AvoidFunctionParameterModificationCheck.h"
   11|       |#include "AvoidStaticInArrayParamCheck.h"
   12|       |#include "FunctionDeclarationMismatchCheck.h"
   13|       |#include "ImplicitFunctionDeclCheck.h"
   14|       |#include "StaticInlineCheck.h"
   15|       |#include "UncompleteFunctionPrototypeCheck.h"
   16|       |
   17|       |namespace clang::tidy::automotive {
   18|       |
   19|       |void FunctionComponent::addCheckFactories(
   20|    262|    ClangTidyCheckFactories &CheckFactories) {
   21|       |
   22|    262|  CheckFactories.registerCheck<UncompleteFunctionPrototypeCheck>(
   23|    262|      "automotive-uncomplete-function-prototype");
   24|    262|  CheckFactories.registerCheck<FunctionDeclarationMismatchCheck>(
   25|    262|      "automotive-function-declaration-mismatch");
   26|    262|  CheckFactories.registerCheck<StaticInlineCheck>(
   27|    262|      "automotive-missing-static-inline");
   28|       |
   29|    262|  CheckFactories.registerCheck<ImplicitFunctionDeclCheck>(
   30|    262|      "automotive-implicit-function-decl");
   31|    262|  CheckFactories.registerCheck<AvoidFunctionParameterModificationCheck>(
   32|    262|      "automotive-avoid-function-parameter-modification");
   33|       |
   34|       |  // Rule 17.6 - Static keyword in array parameters (Mandatory)
   35|    262|  CheckFactories.registerCheck<AvoidStaticInArrayParamCheck>(
   36|    262|      "automotive-c23-mand-17.6");
   37|    262|}
   38|       |
   39|       |} // namespace clang::tidy::automotive

/home/e/Development/clang-tidy-automotive/src/automotive/function/AvoidStaticInArrayParamCheck.cpp:
    1|       |//===--- AvoidStaticInArrayParamCheck.cpp - clang-tidy --------------------===//
    2|       |//
    3|       |// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
    4|       |// See https://llvm.org/LICENSE.txt for license information.
    5|       |// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
    6|       |//
    7|       |//===----------------------------------------------------------------------===//
    8|       |
    9|       |#include "AvoidStaticInArrayParamCheck.h"
   10|       |#include "clang/AST/ASTContext.h"
   11|       |#include "clang/ASTMatchers/ASTMatchFinder.h"
   12|       |#include "clang/Lex/Lexer.h"
   13|       |
   14|       |using namespace clang::ast_matchers;
   15|       |
   16|       |namespace clang::tidy::automotive {
   17|       |
   18|    131|void AvoidStaticInArrayParamCheck::registerMatchers(MatchFinder *Finder) {
   19|       |  // Match function declarations with parameters
   20|    131|  Finder->addMatcher(
   21|    131|      functionDecl(hasAnyParameter(parmVarDecl().bind("param"))).bind("func"),
   22|    131|      this);
   23|    131|}
   24|       |
   25|       |void AvoidStaticInArrayParamCheck::check(
   26|  7.99k|    const MatchFinder::MatchResult &Result) {
   27|  7.99k|  const auto *Param = Result.Nodes.getNodeAs<ParmVarDecl>("param");
   28|  7.99k|  if (!Param)
  ------------------
  |  Branch (28:7): [True: 0, False: 7.99k]
  ------------------
   29|      0|    return;
   30|       |
   31|       |  // Skip if in system header
   32|  7.99k|  if (Result.SourceManager->isInSystemHeader(Param->getLocation()))
  ------------------
  |  Branch (32:7): [True: 7.29k, False: 706]
  ------------------
   33|  7.29k|    return;
   34|       |
   35|       |  // Get the source range of the parameter
   36|    706|  SourceRange ParamRange = Param->getSourceRange();
   37|    706|  if (ParamRange.isInvalid())
  ------------------
  |  Branch (37:7): [True: 402, False: 304]
  ------------------
   38|    402|    return;
   39|       |
   40|    304|  const SourceManager &SM = *Result.SourceManager;
   41|    304|  const LangOptions &LangOpts = Result.Context->getLangOpts();
   42|       |
   43|       |  // Get the source text for this parameter
   44|    304|  CharSourceRange CharRange = CharSourceRange::getTokenRange(ParamRange);
   45|    304|  StringRef ParamText = Lexer::getSourceText(CharRange, SM, LangOpts);
   46|       |
   47|    304|  if (ParamText.empty())
  ------------------
  |  Branch (47:7): [True: 0, False: 304]
  ------------------
   48|      0|    return;
   49|       |
   50|       |  // Look for [static pattern in the parameter declaration
   51|       |  // Valid patterns: [static N], [static N], [static sizeof(x)], etc.
   52|    304|  size_t BracketPos = ParamText.find('[');
   53|    304|  if (BracketPos == StringRef::npos)
  ------------------
  |  Branch (53:7): [True: 294, False: 10]
  ------------------
   54|    294|    return;
   55|       |
   56|       |  // Check if 'static' follows the opening bracket (allowing whitespace)
   57|     10|  StringRef AfterBracket = ParamText.substr(BracketPos + 1).ltrim();
   58|     10|  if (AfterBracket.starts_with("static")) {
  ------------------
  |  Branch (58:7): [True: 3, False: 7]
  ------------------
   59|       |    // Verify it's actually the keyword (not part of identifier)
   60|      3|    StringRef AfterStatic = AfterBracket.substr(6);
   61|      3|    if (AfterStatic.empty() || !std::isalnum(AfterStatic[0])) {
  ------------------
  |  Branch (61:9): [True: 0, False: 3]
  |  Branch (61:32): [True: 3, False: 0]
  ------------------
   62|      3|      diag(Param->getLocation(),
   63|      3|           "array parameter '%0' uses 'static' keyword which is not permitted "
   64|      3|           "by MISRA C")
   65|      3|          << Param->getName();
   66|      3|    }
   67|      3|  }
   68|     10|}
   69|       |
   70|       |} // namespace clang::tidy::automotive

